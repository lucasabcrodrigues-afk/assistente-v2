<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ERP Comercial Profissional</title>

<style>
/*
  A maioria das vari√°veis de cor e estilo √© definida na raiz (``:root``) para que
  possamos alternar facilmente entre temas escuros e claros. As vari√°veis da
  paleta padr√£o permanecem inalteradas; um tema claro pode sobrescrev√™-las
  dinamicamente via JavaScript. O restante do CSS original foi mantido, com
  pequenos ajustes para suportar o modo claro e transi√ß√µes suaves.
*/
:root{
  --bg:#070b16;
  --panel:#0f1435;
  --panel2:#0b1030;
  --primary:#2c3dd1;
  --primary2:#4257ff;
  --text:#f0f0ff;
  --muted:#b7c1ff;
  --border:#2c3380;
  --ok:#4cff9a;
  --bad:#ff6b6b;
  --warn:#ffcc00;
  --shadow: 0 12px 35px rgba(0,0,0,.45);
  --shadow2: 0 8px 24px rgba(0,0,0,.35);

  /* Espa√ßamentos padronizados para construir um design-system consistente.
     Podem ser usados em margens, paddings e gap entre elementos. */
  --space-xxs: 2px;
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 12px;
  --space-lg: 16px;

  /* Raio padr√£o para bot√µes e cards; aumenta suavidade visual. */
  --radius-btn: 8px;
  --radius-card: 12px;
}

/* Aumenta globalmente a fonte quando ativado.  A classe ``large-font``
   √© aplicada ao elemento ``body`` para proporcionar uma experi√™ncia
   ``idoso‚Äëfriendly`` com texto maior. */
body.large-font{
  font-size: 18px;
}

/* Navega√ß√£o de categorias dentro da tela de Ajustes.
   Para uma experi√™ncia mais organizada, os bot√µes s√£o dispostos em um grid
   responsivo com espa√ßamento uniforme. O estilo aplica cores do tema,
   bordas e transi√ß√µes suaves para um design intuitivo. */
.config-nav {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
}
.config-nav button {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: var(--space-sm) var(--space-md);
  background: var(--panel2);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: var(--radius-btn);
  transition: background-color .15s ease, transform .1s ease;
}
.config-nav button:hover {
  background: var(--panel);
  transform: translateY(-2px);
}
.config-nav button:active {
  transform: scale(0.97);
}
.config-nav button.danger {
  background: var(--bad);
  color: #fff;
}
/* O bot√£o ativo de Ajustes recebe um brilho adicional para indicar sele√ß√£o */
.config-nav button.active {
  filter: brightness(1.15);
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary2) 40%, transparent);
}

/* Estilos para o chat do Assistente Virtual */
.message{
  margin: 2px 0;
  padding: 4px 8px;
  border-radius: 6px;
  max-width: 85%;
  word-break: break-word;
  font-size: 14px;
  display: inline-block;
}
.message.user{
  background: var(--primary2);
  color: #fff;
  align-self: flex-end;
}
.message.assistant{
  background: var(--panel);
  color: var(--text);
  align-self: flex-start;
}

*{box-sizing:border-box}
html, body{height:100%}
body{
  margin:0;
  font-family:Segoe UI,Arial,sans-serif;
  /* A cor de fundo usa vari√°veis para permitir temas din√¢micos */
  background:radial-gradient(1200px 800px at 20% 0%, rgba(66,87,255,.18), transparent 55%),
             radial-gradient(1200px 800px at 80% 20%, rgba(44,61,209,.18), transparent 55%),
             linear-gradient(180deg,var(--bg),var(--panel2));
  color:var(--text);
  padding-bottom: 56px;
  overflow-x:hidden;
  transition: background-color .3s ease, color .3s ease;
}

/* Destaque em buscas: utiliza um tom da cor prim√°ria para evidenciar
   ocorr√™ncias de texto encontrados. Ajusta o contraste para ficar
   leg√≠vel tanto no modo escuro quanto no claro. */
mark{
  background: color-mix(in srgb, var(--primary) 30%, transparent);
  color: inherit;
  padding: 0 2px;
  border-radius: 3px;
}

/* Bot√µes com a classe 'active' indicam estado ligado de filtros e
   pagina√ß√£o. Real√ßamos sutilmente com brilho e uma borda. */
button.active{
  filter: brightness(1.15);
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary2) 40%, transparent);
}

header{
  padding:15px;
  text-align:center;
  font-size:22px;
  font-weight:800;
  /* Cabe√ßalho usa as cores prim√°rias do tema para suportar modo claro/escuro */
  background:linear-gradient(135deg, var(--primary), var(--primary2));
  box-shadow: var(--shadow2);
  position: sticky;
  top: 0;
  z-index: 10;
}

nav{
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:10px;
  padding:10px;
  /* Use cores do tema para nav para que se adaptem ao modo claro/escuro */
  background: var(--panel);
  border-bottom: 1px solid var(--border);
  backdrop-filter: blur(8px);
}

nav button{
  padding:10px 14px;
  border:0;
  border-radius:10px;
  /* Ajuste do gradiente para adaptar ao tema atual e remover azul escuro
     fixo. Usamos as duas vari√°veis de cor prim√°ria para compor o
     gradiente, garantindo que tanto o modo escuro quanto o modo claro
     fiquem harm√¥nicos. */
  background:linear-gradient(135deg, var(--primary), var(--primary2));
  /* O texto dos bot√µes agora usa a vari√°vel de texto do tema para
     garantir boa legibilidade tanto no modo escuro quanto no modo
     claro. Isto substitui a cor fixa branca anterior. */
  color: var(--text);
  font-weight:700;
  cursor:pointer;
  transform: translateZ(0);
  transition: transform .12s ease, filter .12s ease, opacity .12s ease;
  box-shadow: 0 10px 22px rgba(0,0,0,.28);
}
nav button:hover{filter:brightness(1.07); transform: translateY(-1px);} 
nav button:active{transform: translateY(1px) scale(.98);} 

/* =======================
   Componentes de Bot√µes
   =======================
   Defini√ß√µes reutiliz√°veis para bot√µes prim√°rios, secund√°rios e de
   perigo. Estas classes permitem que outras partes da interface usem
   bot√µes consistentes, independentemente de onde estejam.  Elas se
   baseiam nas vari√°veis de espa√ßo e raio do design-system. */
.button{
  display:inline-block;
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-btn);
  cursor:pointer;
  font-weight:600;
  border:0;
  transition: background-color .16s ease, filter .16s ease;
}
.button-primary{
  background: linear-gradient(135deg, var(--primary), var(--primary2));
  color: var(--text);
}
.button-secondary{
  background: var(--panel2);
  color: var(--text);
}
.button-danger{
  background: var(--bad);
  color: #fff;
}
.button:disabled{
  opacity:0.6;
  pointer-events:none;
}

section{display:none;padding:15px}
section.active{
  display:block;
  animation: pageIn .18s ease-out;
}
@keyframes pageIn{
  from{opacity:0; transform: translateY(8px)}
  to{opacity:1; transform: translateY(0)}
}

.card{
  /* Use vari√°vel de painel para se adaptar ao tema escolhido */
  background:var(--panel);
  padding:15px;
  border-radius:16px;
  margin-bottom:15px;
  box-shadow: var(--shadow);
  border:1px solid var(--border);
  transform: translateZ(0);
  transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
  animation: cardIn .22s ease-out;
}

/* =================
   Ajustes extras
   ================= */
/* O container de ferramentas extras recebe um layout em coluna com espa√ßamento
   uniforme entre as ferramentas. Cada sub-card usa ``--panel2`` como fundo
   secund√°rio para melhor contraste no modo claro. */
#ajusteExtras{
  /* Distribui as ferramentas em um grid responsivo. Cada coluna tem largura
     m√≠nima de 280px e se expande conforme o espa√ßo dispon√≠vel. */
  display:grid;
  grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));
  gap:16px;
}
#ajusteExtras .card{
  background:var(--panel2);
  border:1px solid var(--border);
  box-shadow: var(--shadow);
}
#ajusteExtras .grid{ gap:8px; }
.card:hover{
  transform: translateY(-1px);
  /* Ajustar sombra e borda no hover para ambos temas */
  box-shadow: 0 16px 40px rgba(0,0,0,.12);
  border-color: var(--border);
}
@keyframes cardIn{
  from{opacity:0; transform: translateY(10px) scale(.99)}
  to{opacity:1; transform: translateY(0) scale(1)}
}

.grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
  gap:10px;
}

input,select{
  /*
    Inputs e seletores agora usam vari√°veis de tema para se adaptar aos modos
    claro e escuro. O fundo usa ``--panel2`` (painel secund√°rio), a borda
    ``--border`` e a cor do texto ``--text``. No foco, a borda adota a cor
    prim√°ria e uma sombra suave baseada em ``--primary2``.
  */
  width:100%;
  padding:9px;
  border-radius:10px;
  border:1px solid var(--border);
  background:var(--panel2);
  color:var(--text);
  outline:none;
  transition: border-color .14s ease, box-shadow .14s ease, transform .12s ease;
}
input:focus, select:focus{
  border-color:var(--primary);
/* Use a sombra baseada na cor prim√°ria atual, evitando refer√™ncia fixa
   ao azul escuro. A multiplica√ß√£o autom√°tica do alpha mant√©m o efeito
   suave tanto no modo escuro quanto no claro. */
box-shadow:0 0 0 3px color-mix(in srgb, var(--primary) 30%, transparent);
}
input:active, select:active{transform: scale(.995)}

button{
  padding:10px 14px;
  border-radius:10px;
  border:0;
  /* Ajuste do gradiente para remover azul escuro fixo. Neste segundo bloco
     (provavelmente usado em bot√µes secund√°rios), aplicamos o mesmo
     gradiente adaptativo usando as vari√°veis de cor prim√°ria. */
  background:linear-gradient(135deg, var(--primary), var(--primary2));
  /* O texto dos bot√µes gerais tamb√©m usa a vari√°vel ``--text`` para
     adaptar-se ao tema atual, substituindo a cor branca fixa. */
  color: var(--text);
  font-weight:700;
  cursor:pointer;
  transition: transform .12s ease, filter .12s ease, opacity .12s ease;
  box-shadow: 0 10px 22px rgba(0,0,0,.22);
}
button:hover{filter:brightness(1.07); transform: translateY(-1px);} 
button:active{transform: translateY(1px) scale(.98);} 

table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;
  margin-top:10px;
  overflow:hidden;
  border-radius:12px;
}
th,td{
  /* Usa cor da borda do tema ao inv√©s de azul fixo */
  border:1px solid var(--border);
  padding:7px;
  text-align:center;
}
/* Table headers should adjust to the active theme rather than use a fixed dark background. */
th{background: var(--panel2);}
tr{transition: background-color .12s ease}
/* Ao passar o cursor sobre uma linha da tabela, use a cor prim√°ria
   com um alpha leve. Isso substitui o antigo azul fixo e segue o
   tema ativo. */
tbody tr:hover{background: color-mix(in srgb, var(--primary) 8%, transparent)}
tr.flash{animation: flashRow .35s ease}
@keyframes flashRow{
  0%{background: rgba(76,255,154,.18)}
  100%{background: transparent}
}

.flex{display:flex;flex-wrap:wrap;gap:10px; align-items:center}
/* Estat√≠sticas em cards utilizam as cores do tema para que se adaptem ao modo claro/escuro */
.stat{
  background: var(--panel);
  padding:12px;
  border-radius:14px;
  min-width:170px;
  border:1px solid var(--border);
  transition: transform .16s ease, border-color .16s ease;
}
.stat:hover{
  transform: translateY(-1px);
  border-color: var(--border);
}

.ok{color:var(--ok)}
.bad{color:var(--bad)}
.warn{color:var(--warn)}
.small{font-size:12px;color:var(--muted)}
/* Bot√£o estilo "ghost" adaptado para ambos temas */
button.ghost{
  background: var(--panel);
  border: 1px solid var(--border);
  color: var(--text);
}
button.ghost:hover{
  background: var(--panel2);
}
button.danger{
  background:linear-gradient(135deg,#b62424,#d33535);
  /* Para bot√µes de a√ß√£o perigosa, mantemos o texto branco para
     garantir contraste adequado com o fundo vermelho, mesmo que
     outros bot√µes usem a vari√°vel ``--text``. */
  color:#fff;
}
button.danger:hover{filter:brightness(1.05)}

.barwrap{
  width:100%;
  height:12px;
  /* Ajuste: usa pain√©is e bordas do tema ao inv√©s de cores fixas */
  background:var(--panel2);
  border:1px solid var(--border);
  border-radius:999px;
  overflow:hidden;
}
.bar{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, var(--primary), var(--primary2));
  transition: width .35s ease;
}
.rowleft{ text-align:left }
.tight td{ padding:6px }

/* Toast */
#toastWrap{
  position:fixed;
  right:14px;
  bottom:72px;
  display:flex;
  flex-direction:column;
  gap:10px;
  z-index:9999;
  pointer-events:none;
}
.toast{
  pointer-events:none;
  min-width:240px;
  max-width:380px;
  padding:12px 14px;
  border-radius:14px;
  border:1px solid var(--border);
  background: var(--panel);
  box-shadow: var(--shadow);
  backdrop-filter:blur(10px);
  display:flex;
  align-items:flex-start;
  gap:10px;
  animation:toastIn .18s ease-out;
}
.toast .ico{font-size:18px; line-height:18px; margin-top:2px;}
.toast .msg{font-size:13px; color:var(--text);} 
.toast.ok{border-color:rgba(76,255,154,.35)}
.toast.bad{border-color:rgba(255,107,107,.35)}
.toast.warn{border-color:rgba(255,204,0,.35)}
@keyframes toastIn{
  from{transform:translateY(10px);opacity:0}
  to{transform:translateY(0);opacity:1}
}

/* Footer */
footer#credits{
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px 12px;
  text-align: center;
  font-size: 12px;
  color: var(--muted);
  background: var(--panel);
  border-top: 1px solid var(--border);
  backdrop-filter: blur(8px);
  z-index: 9998;
}
footer#credits b{
  /*
    Ajustamos a cor do nome e contato no rodap√© para utilizar a vari√°vel
    --text do tema atual. Isso garante contraste adequado tanto no modo
    escuro quanto no modo branco. Anteriormente estava fixado em branco,
    o que tornava o texto invis√≠vel no tema claro.
  */
  color: var(--text);
}

/* Badges */
/* Badge usa cores do tema para fundo e borda */
.badge{
  display:inline-block;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  font-size:12px;
  background: var(--panel);
}

/* Vendas: seletor de modo */
.modeWrap{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:center;
  margin-top:10px;
}
.modeBtn{
  /* Use theme variables instead of hardcoded dark blues. This ensures the
     buttons adapt to the current theme (light or dark). In light mode,
     the panel colours are light blues/greys; in dark mode, they remain dark. */
  border:1px solid var(--border);
  background: var(--panel2);
}
.modeBtn.active{
  /* Keep the gradient for the active state and rely on the theme's border
     colour rather than a fixed light blue. */
  background:linear-gradient(135deg, var(--primary), var(--primary2));
  border-color: var(--border);
}
.divider{
  height:1px;
  /* The divider uses the theme's border colour instead of a hardcoded dark blue. */
  background: var(--border);
  opacity:.85;
  margin:12px 0;
}

/* ‚úÖ Transi√ß√£o suave entre Quick/Cart */
.fadeSwap{
  animation: fadeSwap .18s ease-out;
}
@keyframes fadeSwap{
  from{opacity:0; transform: translateY(6px)}
  to{opacity:1; transform: translateY(0)}
}

/* ‚úÖ Anima√ß√£o carrinho */
.cartPulse{
  animation: cartPulse .18s ease-out;
}
@keyframes cartPulse{
  from{transform: scale(.99); filter:brightness(1.02)}
  to{transform: scale(1); filter:brightness(1)}
}

/* Acessibilidade */
@media (prefers-reduced-motion: reduce){
  *{animation:none!important; transition:none!important}
}

/* =======================
   Interface Simples
   =======================
   Quando a classe `simple-mode` √© adicionada ao `<body>`, a navega√ß√£o e o
   conte√∫do s√£o reorganizados para priorizar uma experi√™ncia mais limpa e
   intuitiva. O menu lateral ocupa a altura total da tela e utiliza bot√µes
   maiores, enquanto diversas se√ß√µes avan√ßadas ficam ocultas para reduzir
   a complexidade. */
/* Lateral navigation occupies full height with generous width and spacing
   for easier tapping. */
.simple-mode nav{
  flex-direction: column;
  align-items: stretch;
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  width: 260px;
  overflow-y: auto;
  padding: 14px 0;
  gap: 8px;
  background: var(--panel);
  box-shadow: var(--shadow);
}

/* Ajusta os grids para uma √∫nica coluna, ideal em telas menores ou em modo
   simplificado. */
.simple-mode .grid{
  grid-template-columns: 1fr !important;
}

/* Estat√≠sticas ocupam toda a largura e apresentam espa√ßamento inferior extra. */
.simple-mode .stat{
  width:100%;
  margin-bottom:12px;
}

/* O conte√∫do principal come√ßa √† direita do menu lateral. */
.simple-mode section{
  /* Compensa a largura do menu lateral (260px) para posicionar o conte√∫do
     principal ao lado. */
  margin-left: 260px;
  padding:20px;
  width: calc(100% - 260px);
}

/* Aumenta o tamanho do t√≠tulo no cabe√ßalho quando em modo simples para
   refor√ßar a hierarquia visual. */
.simple-mode header{
  font-size:26px;
}

/* Em modo simples, as estat√≠sticas recebem destaque com fonte maior. */
.simple-mode .stat b{
  font-size:1.6rem;
}

/* Bot√µes de navega√ß√£o ficam maiores e com margens uniformes. */
.simple-mode nav button{
  width:92%;
  margin:6px auto;
  font-size:1.3rem;
  padding:18px 20px;
  justify-content:flex-start;
  line-height:1.3;
}

/* Em modo simples, esconda recursos avan√ßados de vendas (carrinho) para
   simplificar a opera√ß√£o. */
.simple-mode #saleCartWrap,
.simple-mode #btnModeCompleta{
  display:none !important;
}

/* Esconde elementos marcados para n√£o aparecerem na interface simples */
.simple-mode .hiddenInSimple{
  display:none !important;
}

/* === Modal de scanner ===
   O scanner pode aparecer sobre a interface como uma janela flutuante. O
   cont√™iner de overlay escurece levemente o fundo, enquanto a
   ``scan-modal`` centraliza e estiliza a janela. */
/*
  O cont√™iner #scannerOverlay cobre toda a tela quando o modo de scanner
  est√° ativo. Definimos um z-index extremamente alto (99999) para ter
  certeza de que nenhuma parte da interface o sobrep√µe. Por padr√£o ele
  permanece oculto e n√£o captura eventos; a exibi√ß√£o √© controlada via
  JavaScript em openScanOverlay() e closeScanOverlay().
*/
#scannerOverlay{
  position: fixed;
  top:0;
  left:0;
  right:0;
  bottom:0;
  background: rgba(0,0,0,0.45);
  z-index: 99999;
  /* Come√ßa oculto e inerte */
  display: none;
  pointer-events: none;
  justify-content: center;
  align-items: center;
  padding: 20px;
}
/* Posiciona a janela minimizada no rodap√© em modo reduzido */
#scannerOverlay.minimized{
  align-items: flex-end;
  padding: 0;
}
.scan-modal{
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: var(--shadow);
  width: 100%;
  max-width: 860px;
  max-height: 90vh;
  overflow-y: auto;
  overflow-x: hidden;
}
/* Ajustes da janela do scanner quando minimizada */
#scannerOverlay.minimized .scan-modal{
  width: 100%;
  max-width: none;
  max-height: 40vh;
  border-radius: 12px 12px 0 0;
}

/* =======================
   Modo Smartphone
   =======================
   O modo smartphone √© ativado adicionando a classe ``smartphone`` ao
   elemento ``<body>``. Ele reorganiza a navega√ß√£o e transforma tabelas em
   cart√µes responsivos para facilitar a leitura e a intera√ß√£o em telas
   pequenas. */
body.smartphone{
  font-size: 18px;
}
/* Oculta a navega√ß√£o superior no modo smartphone, substituindo-a por uma
   barra inferior fixa. */
body.smartphone nav{
  display:none;
}
/* Container da barra inferior, oculto por padr√£o. Ao entrar no modo
   smartphone, ele se torna flex√≠vel para distribuir igualmente os
   bot√µes. */
#bottomNav{
  display:none;
  width:100%;
  background: var(--panel);
  border-top: 1px solid var(--border);
  position:fixed;
  bottom:0;
  left:0;
  right:0;
  z-index:20;
}
body.smartphone #bottomNav{
  display:flex;
}
#bottomNav button{
  flex:1;
  padding:10px 0;
  border:0;
  background:none;
  color: var(--text);
  font-size:14px;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:2px;
  cursor:pointer;
  transition: filter .16s ease;
}
#bottomNav button.active{
  filter: brightness(1.15);
}
/* Reserva espa√ßo inferior nas se√ß√µes para que o conte√∫do n√£o fique
   escondido atr√°s da barra inferior. */
body.smartphone section{
  padding-bottom:80px;
}
/* Tabelas s√£o convertidas em listas de cart√µes: remove cabe√ßalho e
   exibe cada linha como um bloco com r√≥tulos. */
body.smartphone table{
  border-collapse:separate;
  border-spacing:0;
  width:100%;
}
body.smartphone thead{
  display:none;
}
body.smartphone table tbody tr{
  display:block;
  margin-bottom:10px;
  background: var(--panel2);
  border:1px solid var(--border);
  border-radius: var(--radius-card);
  box-shadow: var(--shadow);
  overflow:hidden;
}
body.smartphone table tbody tr td{
  display:flex;
  justify-content:space-between;
  padding:6px 10px;
  word-break:break-word;
}
body.smartphone table tbody tr td::before{
  content: attr(data-label);
  font-weight:600;
  margin-right:8px;
}

/* =======================
   Interface Celular (mobile-mode)
   =======================
   Esta varia√ß√£o oferece uma experi√™ncia totalmente otimizada para telas
   pequenas na orienta√ß√£o vertical. Ela usa a mesma base do modo
   smartphone (barra inferior e cart√µes responsivos), mas ajusta
   margens, tipografia e o layout das grids para uma navega√ß√£o ainda
   mais intuitiva e confort√°vel em celulares. */
body.mobile-mode{
  font-size: 18px;
}
/* Oculta a navega√ß√£o superior e utiliza a barra inferior no modo
   celular. */
body.mobile-mode nav{
  display:none;
}
body.mobile-mode #bottomNav{
  display:flex;
}
/* Ajusta espa√ßamento inferior para acomodar a barra */
body.mobile-mode section{
  padding-bottom:80px;
}
/* Altera grids para coluna √∫nica no modo celular para facilitar a
   leitura e a intera√ß√£o em telas estreitas. */
body.mobile-mode .grid{
  grid-template-columns:1fr !important;
}
/* Ajusta as estat√≠sticas e cart√µes para largura total com margens
   menores, permitindo rolagem suave. */
body.mobile-mode .stat{
  width:100%;
  margin-bottom:12px;
}
body.mobile-mode .card{
  margin:12px 0;
}
/* Melhora o espa√ßamento dos bot√µes na barra inferior em telas
   menores. */
body.mobile-mode #bottomNav button{
  padding:12px 0;
  font-size:14px;
}
</style>
    <!-- Biblioteca de leitura de c√≥digos de barras (QuaggaJS) -->
    <!-- Substitu√≠mos a biblioteca QuaggaJS pela html5‚Äëqrcode para suporte moderno a scanners -->
    <!-- script html5-qrcode removido: substitu√≠do pelo m√≥dulo skan -->
</head>

<body>
<!-- Atualizado: t√≠tulo exibido no cabe√ßalho do sistema -->
<header>üî• LRS Assistente de empresas üî•</header>
<div id="toastWrap"></div>

<!-- LOGIN -->
<section id="loginSection" class="active">
  <div class="card" style="max-width:420px;margin:auto;">
    <h3>Login do Sistema</h3>
    <div class="grid">
      <input id="l_user" placeholder="Usu√°rio" autocomplete="username" />
      <input id="l_pass" type="password" placeholder="Senha" autocomplete="current-password" />
    </div>
    <!-- Campo opcional de token para multi‚Äëcliente -->
    <label for="l_token" style="font-size:14px;margin-top:8px;display:block;">Token</label>
    <input id="l_token" placeholder="Ex.: B1, B2, B3" autocomplete="off" />
    <br>
    <button onclick="doLogin()">Entrar</button>
    <p style="font-size:12px;color:var(--muted);margin-top:10px">
      Lucas Softwares ‚Üí <b>admin</b> pe√ßa sua licen√ßa ja! ‚Üí <b></b>
    </p>
  </div>
</section>

  <!-- Modal de scanner removido desta posi√ß√£o: ele ser√° renderizado dentro do systemSection -->


<!-- SISTEMA -->
<section id="systemSection" style="display:none;">
  <nav>
    <button onclick="show('dashboard')">üìä Dashboard</button>
    <button onclick="show('estoque')">üì¶ Estoque</button>
    <button onclick="show('vendas')">üí∞ Vendas</button>
    <button onclick="show('caixa')">üßæ Caixa</button>
    <!-- Ajustes centraliza todas as op√ß√µes administrativas e de tema -->
    <button onclick="show('ajustes')">‚öôÔ∏è Ajustes</button>
  </nav>

  <!-- Barra inferior para modo smartphone.  Este elemento √© exibido
       somente quando o modo de UI est√° definido como 'smartphone'. Os
       bot√µes chamam a mesma fun√ß√£o ``show()`` usada pela navega√ß√£o
       superior, garantindo compatibilidade com as se√ß√µes existentes. -->
  <div id="bottomNav">
    <button onclick="show('dashboard')"><span class="icon">üè†</span><span>Dashboard</span></button>
    <button onclick="show('estoque')"><span class="icon">üì¶</span><span>Estoque</span></button>
    <button onclick="show('vendas')"><span class="icon">üí∞</span><span>Vendas</span></button>
    <button onclick="show('caixa')"><span class="icon">üßæ</span><span>Caixa</span></button>
    <button onclick="show('ajustes')"><span class="icon">‚öôÔ∏è</span><span>Ajustes</span></button>
  </div>

  <!--
    Modal PDV/Scanner
    Esta janela √© renderizada dentro de systemSection para garantir que
    permane√ßa dispon√≠vel quando o usu√°rio estiver autenticado. O overlay
    cobre toda a tela com um fundo semi‚Äëtransparente; o conte√∫do √©
    centralizado e cont√©m o leitor de c√≥digos, entrada manual e o
    carrinho. A estrutura e os IDs devem permanecer inalterados para
    compatibilidade com as fun√ß√µes de scanner.
  -->
  <!-- Modal PDV/Scanner
    Esta janela √© renderizada dentro de systemSection para garantir que
    permane√ßa dispon√≠vel quando o usu√°rio estiver autenticado. O overlay
    cobre toda a tela com um fundo semi‚Äëtransparente; o conte√∫do √©
    centralizado e cont√©m o leitor de c√≥digos, entrada manual e o
    carrinho. A estrutura e os IDs devem permanecer inalterados para
    compatibilidade com as fun√ß√µes de scanner. -->
  <div id="scannerOverlay" style="display:none;">
    <div id="scanner" class="scan-modal" style="padding:1rem; display:block;">
      <!-- Barra superior do modal de scanner: inclui t√≠tulo e bot√µes de a√ß√£o -->
      <nav class="flex" style="justify-content:space-between; align-items:center; margin-bottom:1rem; flex-wrap:wrap; gap:4px;">
        <h3 style="margin:0;">PDV / Scanner</h3>
        <div class="flex" style="gap:6px; flex-wrap:wrap;">
          <!-- Bot√£o para verificar estoque do √∫ltimo c√≥digo lido ou digitado -->
          <button onclick="checkScanStock()">üîç Verificar Estoque</button>
          <!-- Bot√£o para finalizar e registrar a venda -->
          <button onclick="finalizarScanVenda()">üõí Registrar Venda</button>
          <!-- Bot√£o para fechar o modal -->
          <button onclick="closeScanOverlay()">‚úñ Fechar</button>
          <!-- Bot√£o oculto para alternar o scanner (mant√©m compatibilidade com updateScanButton) -->
          <button id="scanToggleBtn" onclick="toggleScan()" style="display:none;">üì∑ Scan On</button>
        </div>
      </nav>
      <div class="flex wrap" style="gap:1rem;">
        <!-- √Årea de leitura do c√≥digo de barras -->
        <div class="card" style="flex:2; min-width:300px;">
          <h3>Leitor de C√≥digo de Barras</h3>
          <div id="scan_view" style="width:100%; height:240px; border:2px dashed var(--primary); border-radius:4px; background:#000; position:relative; overflow:hidden;">
            <!-- Elemento de v√≠deo para o BarcodeDetector e html5-qrcode -->
            <video id="scan_video" autoplay playsinline style="width:100%; height:100%; object-fit:cover;"></video>
          </div>
          <p id="scan_status" class="small" style="margin-top:.5rem; color: var(--muted);">Aguardando‚Ä¶</p>
          <p id="lastScanCode" class="small" style="color: var(--muted);"></p>
          <!-- Entrada manual para testes ou quando o leitor n√£o estiver dispon√≠vel.
               Permite digitar um c√≥digo de barras manualmente e adicion√°‚Äëlo ao
               carrinho utilizando a mesma l√≥gica do scanner. -->
          <div class="flex" style="margin-top:.5rem; gap:4px; align-items:center;">
            <input type="text" id="manual_scan_code" placeholder="C√≥digo manual" style="flex:1; min-width:0;" />
            <button onclick="manualAddScan()">Adicionar</button>
          </div>
          <!-- Exibe informa√ß√µes do √∫ltimo produto lido ou digitado -->
          <p id="scan_product_info" class="small" style="margin-top:.4rem; color: var(--ok); display:none;"></p>
        </div>
        <!-- Carrinho de itens lidos -->
        <div class="card" style="flex:3; min-width:320px;">
          <h3>Carrinho</h3>
          <table>
            <thead><tr><th>C√≥digo</th><th class="rowleft">Produto</th><th>Pre√ßo</th><th>Qtd</th><th>Subtotal</th><th>A√ß√µes</th></tr></thead>
            <tbody id="scanCartTable"></tbody>
          </table>
          <div class="grid" style="margin-top:6px; grid-template-columns:1fr 1fr 1fr; gap:4px;">
            <div>Itens: <b id="scan_items">0</b></div>
            <div>Subtotal: R$ <b id="scan_subtotal">0,00</b></div>
            <div>Total: R$ <b id="scan_total">0,00</b></div>
          </div>
          <div class="grid" style="margin-top:6px; grid-template-columns:1fr 1fr; gap:4px;">
            <input type="text" id="scan_service" placeholder="Servi√ßo (R$)" inputmode="decimal" />
            <input type="text" id="scan_discount" placeholder="Desconto (R$)" inputmode="decimal" />
          </div>
          <div class="grid" style="margin-top:6px; grid-template-columns:1fr 1fr; gap:4px;">
            <input type="text" id="scan_recebido" placeholder="Recebido (R$ - dinheiro)" inputmode="decimal" />
            <div>Troco: <b id="scan_troco">0,00</b></div>
          </div>
          <div class="grid" style="margin-top:8px; grid-template-columns:1fr 1fr; gap:4px;">
            <button onclick="finalizarScanVenda()">Finalizar</button>
            <button class="danger" onclick="limparScanCarrinho()">Limpar</button>
          </div>
        </div>
      </div>
    </div>
    </div>

  <!-- Novo m√≥dulo de scanner: overlay leve para leitura de c√≥digos -->
  <div id="skanOverlay" style="display:none; position:fixed; z-index:99999; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); align-items:center; justify-content:center;">
    <div id="skanContainer" style="background:var(--panel2, #ffffff); padding:1rem; border-radius:8px; max-width:500px; width:90%; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
      <div class="flex" style="justify-content:space-between; align-items:center;">
        <h3 style="margin:0;">Scanner</h3>
        <button type="button" onclick="stopSkan()" style="background:none; border:none; font-size:1.2rem; cursor:pointer;">‚úñ</button>
      </div>
      <div id="skanCameraView" style="width:100%; height:240px; border:2px dashed var(--primary, #007bff); border-radius:4px; background:#000; position:relative; margin-top:8px; overflow:hidden;">
        <video id="skanVideo" autoplay playsinline style="width:100%; height:100%; object-fit:cover;"></video>
      </div>
      <p id="skanStatus" class="small" style="margin-top:.5rem; color:var(--muted, #888);">Aguardando‚Ä¶</p>
    </div>
  </div>

  <!-- DASHBOARD -->
  <section id="dashboard" class="active">
    <div class="flex">
      <div class="stat">üí∞ Faturamento<br><b>R$ <span id="d_fat">0,00</span></b></div>
      <div class="stat">üìà Lucro Bruto<br><b>R$ <span id="d_lucro">0,00</span></b></div>
      <div class="stat">üõí Vendas<br><b><span id="d_vendas">0</span></b></div>
      <div class="stat">üî• Ticket M√©dio<br><b>R$ <span id="d_ticket">0,00</span></b></div>
      <div class="stat">üßæ Caixa<br><b><span id="d_caixa_status">FECHADO</span></b></div>
    </div>

    <div class="card hiddenInSimple">
      <h3>‚ö† Estoque baixo</h3>
      <div class="small" id="d_alertInfo"></div>
      <table>
        <thead>
          <tr><th>C√≥digo</th><th>Produto</th><th>Qtd</th><th>M√≠n</th></tr>
        </thead>
        <tbody id="tAlertas"></tbody>
      </table>
      <!-- Formul√°rio de edi√ß√£o de usu√°rio removido desta localiza√ß√£o. Agora ele √© inserido na se√ß√£o de Usu√°rios para melhor fluxo. -->
    </div>

    <div class="card hiddenInSimple">
      <h3>üìà Gr√°ficos (Top / Acabando / Evolu√ß√£o)</h3>

      <div class="grid" style="margin-top:10px;">
        <div class="card" style="margin:0;">
          <h4 style="margin:6px 0;">üèÜ Top 10 Mais Vendidos (Qtd)</h4>
          <table class="tight">
            <thead><tr><th>#</th><th class="rowleft">Produto</th><th>Qtd</th><th>Barra</th></tr></thead>
            <tbody id="g_top_qtd"></tbody>
          </table>
        </div>

        <div class="card" style="margin:0;">
          <h4 style="margin:6px 0;">üí∞ Top 10 Maior Faturamento</h4>
          <table class="tight">
            <thead><tr><th>#</th><th class="rowleft">Produto</th><th>R$</th><th>Barra</th></tr></thead>
            <tbody id="g_top_fat"></tbody>
          </table>
        </div>

        <div class="card" style="margin:0;">
          <h4 style="margin:6px 0;">üìà Top 10 Maior Lucro</h4>
          <table class="tight">
            <thead><tr><th>#</th><th class="rowleft">Produto</th><th>R$</th><th>Barra</th></tr></thead>
            <tbody id="g_top_luc"></tbody>
          </table>
        </div>

        <div class="card" style="margin:0;">
          <h4 style="margin:6px 0;">‚ö† Produtos Acabando (abaixo do m√≠nimo)</h4>
          <table class="tight">
            <thead><tr><th>C√≥digo</th><th class="rowleft">Produto</th><th>Qtd</th><th>M√≠n</th></tr></thead>
            <tbody id="g_acabando"></tbody>
          </table>
        </div>
      </div>

      <!-- A evolu√ß√£o do faturamento √© complexa para a maioria dos usu√°rios, por isso
           √© ocultada no modo de interface simples adicionando a classe
           ``hiddenInSimple``. -->
      <div class="card hiddenInSimple" style="margin-top:12px;">
        <div class="flex" style="justify-content:space-between; align-items:center;">
          <h4 style="margin:6px 0;">üìÖ Evolu√ß√£o do Faturamento (√∫ltimos 30 dias)</h4>
          <!-- Bot√£o para minimizar/expandir a evolu√ß√£o do faturamento -->
          <button class="ghost" onclick="toggleFatEvolution()" id="fatToggleBtn">üîΩ</button>
        </div>
        <div id="fatEvolutionContent">
          <table class="tight">
            <thead><tr><th>Dia</th><th>R$</th><th>Barra</th></tr></thead>
            <tbody id="g_fat_dia"></tbody>
          </table>
          <div class="small">Obs: considera apenas vendas N√ÉO canceladas.</div>
        </div>
      </div>
    </div>
    <!-- Bloco devedores: exibido apenas quando houver fiado em aberto.
         Este card sintetiza os valores totais, a quantidade de devedores
         e lista os maiores valores com uma pequena barra proporcional.  A
         visibilidade √© controlada via JS (exibe somente quando existir
         algum devedor pendente).  A classe hiddenInSimple garante que o
         bloco n√£o aparece no modo de interface simples.  A largura
         flex√≠vel permite adapta√ß√£o no mobile. -->
    <div class="card hiddenInSimple" id="dash_devedores" style="display:none;">
      <h3>üí≥ Devedores</h3>
      <div class="flex" style="gap:16px; flex-wrap:wrap;">
        <div class="stat small">Total em Aberto<br><b>R$ <span id="d_dev_total">0,00</span></b></div>
        <div class="stat small">Devedores<br><b><span id="d_dev_count">0</span></b></div>
      </div>
      <h4 style="margin:6px 0;">üèÜ Top 5 Maiores Devedores</h4>
      <table class="tight">
        <thead><tr><th>#</th><th class="rowleft">Nome</th><th>R$</th><th>Barra</th></tr></thead>
        <tbody id="g_dev_top"></tbody>
      </table>
    </div>
  </section>

  <!-- ESTOQUE -->
  <section id="estoque">
    <div class="card">
      <h3>Cadastro / Reposi√ß√£o / Edi√ß√£o</h3>
      <div class="small" id="estoqueModeInfo"></div>
      <!-- Bot√£o de scanner para estoque -->
      <div style="margin:6px 0;">
        <!-- Utiliza a nova fun√ß√£o de scanner para estoque. Esta a√ß√£o abre a c√¢mera (ou input) e preenche
             automaticamente o campo apropriado. A label permanece fixa para n√£o ser sobrescrita pelo
             updateButtons(). -->
        <!-- Atualizado para usar o m√≥dulo de leitura Skan. O bot√£o agora chama
             toggleSkan('estoque'), que aciona a c√¢mera ou o leitor USB para
             preencher automaticamente o c√≥digo do produto. O atributo type
             continua como "button" para evitar submiss√£o de formul√°rios. -->
        <button id="skan_estoque_btn" type="button" onclick="toggleSkan('estoque')" style="padding:8px 10px; border-radius:8px;">üì∑ Scanner</button>
      </div>
      <div class="grid">
        <input id="e_cod" placeholder="C√≥digo" />
        <input id="e_nome" placeholder="Nome" />
        <input id="e_qtd" type="number" placeholder="Qtd" min="0" step="1" />
        <input id="e_min" type="number" placeholder="Estoque m√≠nimo" min="0" step="1" />
        <input id="e_custo" placeholder="Custo (ex: 12,50)" inputmode="decimal" />
        <input id="e_preco" placeholder="Pre√ßo (ex: 19,99)" inputmode="decimal" />
        <!-- Campo para definir a porcentagem de lucro desejada. Ao alterar, recalcula automaticamente o pre√ßo de venda. -->
        <input id="e_lucro" type="number" placeholder="% lucro" min="0" step="0.01" title="Porcentagem de lucro" />
      </div>
      <!-- Configura√ß√µes de c√°lculo de lucro (markup/margem) e arredondamento -->
      <div class="grid" style="margin-top:6px;">
        <select id="profitMode" title="M√©todo de c√°lculo de pre√ßo" onchange="setProfitMode(this.value)">
          <option value="markup">Markup (sobre custo)</option>
          <option value="margin">Margem (sobre pre√ßo)</option>
        </select>
        <select id="profitRound" title="Arredondamento do pre√ßo" onchange="setProfitRounding(this.value)">
          <option value="none">Sem arredondamento</option>
          <option value="0.99">Final 0,99</option>
          <option value="0.90">Final 0,90</option>
          <option value="integer">Inteiro</option>
        </select>
      </div>
      <br>
      <div class="flex">
        <button id="btnSalvarProduto" onclick="addProduto()">Salvar Produto</button>
        <button class="ghost" id="btnCancelarEdicao" style="display:none" onclick="cancelEditProduto()">Cancelar edi√ß√£o</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Dica: clique em <b>Editar</b> na tabela para alterar qualquer campo (inclusive c√≥digo).
      </div>
    </div>

    <div class="card">
      <h3>Estoque Atual</h3>
      <!-- Bot√£o para imprimir uma rela√ß√£o simples do estoque. Ao clicar, gera um
           documento em nova janela contendo os itens do estoque com c√≥digo,
           nome e valor de venda (pre√ßo). O bot√£o usa a classe ghost para
           harmonizar com outros controles e um pequeno √≠cone de impressora. -->
      <button id="btnPrintRelacao" class="ghost" onclick="imprimirRelacao()" style="margin-bottom:8px;">
        üñ®Ô∏è Imprimir Rela√ß√£o
      </button>

      <!-- Sele√ß√£o de ordena√ß√£o do estoque: permite alternar entre alfab√©tica e data de adi√ß√£o -->
      <div id="estoqueOrderWrap" style="display:flex; align-items:center; gap:6px; margin-bottom:8px;">
        <label for="estoqueOrderSelect">Ordenar por:</label>
        <select id="estoqueOrderSelect" onchange="setEstoqueOrder(this.value)">
          <option value="nome">Alfab√©tica (A-Z)</option>
          <option value="added">Data de adicionado</option>
        </select>
      </div>
      <!-- Campo de busca para filtrar itens do estoque por c√≥digo ou nome -->
      <div id="estoqueSearchWrap" style="display:flex; align-items:center; gap:6px; margin:6px 0;">
        <span style="font-size:1.2em;">üîé</span>
        <!--
          Campo de busca do estoque.  Ao digitar, normalizamos o texto (sem acentos) e
          separamos termos m√∫ltiplos para permitir combina√ß√µes como "cafe 500g".
          A fun√ß√£o updateEstoqueSearch() atualiza a lista de termos e em seguida
          renderiza a tabela.  O atalho "/" foca este campo e ESC limpa o valor.
        -->
        <input id="estoqueSearch" placeholder="Buscar por c√≥digo ou nome" title="Digite termos para buscar (use / para focar, ESC para limpar)" oninput="updateEstoqueSearch(); render(true)" style="flex:1;" />
        <button class="ghost" onclick="clearEstoqueSearch()" title="Limpar busca">‚úñ</button>
      </div>
      <!-- Bot√£o para ativar ou desativar a exibi√ß√£o da porcentagem de lucro na tabela -->
      <button id="btnToggleLucroPct" class="ghost" onclick="toggleLucroPct()" style="margin-bottom:8px;">Ativar visualiza√ß√£o de %</button>
      <!--
        Filtros r√°pidos de estoque.
        Cada bot√£o ativa/desativa um filtro espec√≠fico: produtos abaixo do m√≠nimo,
        com lucro negativo, sem pre√ßo de venda ou sem custo definido.  O estado
        visual do bot√£o muda via classe 'active' aplicada dinamicamente em
        toggleEstoqueFilter().
      -->
      <div id="estoqueFilters" class="flex" style="flex-wrap:wrap; gap:6px; margin:4px 0;">
        <button class="ghost" id="f_belowMin" onclick="toggleEstoqueFilter('belowMin')" title="Abaixo do m√≠nimo">Abaixo do m√≠nimo</button>
        <button class="ghost" id="f_negProfit" onclick="toggleEstoqueFilter('negProfit')" title="Lucro negativo">Lucro negativo</button>
        <button class="ghost" id="f_noPrice" onclick="toggleEstoqueFilter('noPrice')" title="Sem pre√ßo">Sem pre√ßo</button>
        <button class="ghost" id="f_noCost" onclick="toggleEstoqueFilter('noCost')" title="Sem custo">Sem custo</button>
      </div>
      <table>
        <thead>
          <tr>
            <!-- Cabe√ßalhos clic√°veis que ordenam a tabela.  A dire√ß√£o alterna
                 entre ascendente e descendente.  A propriedade CSS 'cursor'
                 indica que os t√≠tulos s√£o interativos. -->
            <th onclick="sortEstoque('cod')" style="cursor:pointer;">C√≥digo</th>
            <th onclick="sortEstoque('nome')" style="cursor:pointer;">Nome</th>
            <th onclick="sortEstoque('qtd')" style="cursor:pointer;">Qtd</th>
            <th onclick="sortEstoque('min')" style="cursor:pointer;">M√≠n</th>
            <th>Status</th>
            <th onclick="sortEstoque('custo')" style="cursor:pointer;">Custo</th>
            <th onclick="sortEstoque('preco')" style="cursor:pointer;">Venda</th>
            <th id="thLucro" onclick="sortEstoque('lucro')" style="cursor:pointer;">Lucro</th>
            <th>A√ß√µes</th>
          </tr>
        </thead>
        <tbody id="tEstoque"></tbody>
        <!-- Controles de pagina√ß√£o ser√£o populados via render() -->
      </table>
      <div id="estoquePagination" class="flex" style="justify-content:center; gap:4px; margin-top:8px;"></div>
    </div>
  </section>

  <!-- VENDAS -->
  <section id="vendas">
    <div class="card">
      <div class="flex" style="justify-content:space-between;align-items:flex-start;">
        <div>
          <h3 style="margin:0 0 6px 0;">üí∞ Vendas</h3>
          <div class="small">Escolha o modo: r√°pido (1 item) ou completo (carrinho + troco).</div>
        </div>
        <span class="badge">Caixa: <b><span id="v_caixa_badge">FECHADO</span></b></span>
      </div>

      <div class="modeWrap">
        <button id="btnModeRapida" class="modeBtn active" onclick="setSalesMode('rapida')">‚ö° Venda r√°pida</button>
        <button id="btnModeCompleta" class="modeBtn" onclick="setSalesMode('completa')">üõí Venda completa (carrinho)</button>
        <span class="badge">Dica: Troco s√≥ em dinheiro</span>
      </div>

      <div class="divider"></div>

      <!-- MODO: VENDA R√ÅPIDA -->
      <div id="saleQuickWrap" class="fadeSwap">
        <h3 style="margin-top:0;">Registrar Venda R√°pida (1 item)</h3>
        <div class="grid">
          <input id="v_busca" placeholder="Buscar produto (nome ou c√≥digo)" />
          <select id="v_prod"></select>
          <input id="v_qtd" type="number" placeholder="Qtd" min="1" step="1" />
          <!-- Bot√µes de ajuste r√°pido de quantidade -->
          <button id="btn_qtd_minus" class="ghost" title="Diminuir quantidade" onclick="changeQuickQty(-1)">‚ûñ</button>
          <button id="btn_qtd_plus" class="ghost" title="Aumentar quantidade" onclick="changeQuickQty(1)">‚ûï</button>
          <input id="v_servico" placeholder="Servi√ßo / M√£o de obra (R$)" inputmode="decimal" />
          <!-- Desconto por item (%) -->
          <input id="v_desc_item" type="number" placeholder="Desc item %" min="0" step="0.01" title="Desconto percentual por item" />
          <!-- Desconto no total (%) -->
          <input id="v_desc_total" type="number" placeholder="Desc total %" min="0" step="0.01" title="Desconto percentual no total" />
          <!-- Bot√£o para abrir o leitor de c√≥digos diretamente na venda r√°pida -->
          <!-- Scanner: unificado com modo carrinho; usa openCamera se dispon√≠vel -->
          <!-- O scanner da venda r√°pida agora usa o m√≥dulo de leitura Skan. Ao clicar,
               inicia a leitura via c√¢mera ou leitor USB para inserir o c√≥digo do produto.
               Mant√©m-se type="button" para n√£o disparar submiss√£o do formul√°rio. -->
          <button id="btnScannerQuick" type="button" title="Scanner" onclick="toggleSkan('vendas')" style="padding:9px 10px; border-radius:10px;">üì∑ Scanner</button>
          <select id="v_pag">
            <option value="dinheiro">Dinheiro</option>
            <option value="pix">Pix</option>
            <option value="debito">D√©bito</option>
            <option value="credito">Cr√©dito</option>
          </select>
          <!-- Campos adicionais para venda r√°pida: valor recebido e troco -->
          <input id="v_recebido" placeholder="Recebido (s√≥ dinheiro)" inputmode="decimal" />
          <input id="v_troco" placeholder="Troco" disabled />
          <!-- Segundo pagamento removido no modo Venda R√°pida -->
        </div>
        <div class="small" id="v_hint" style="margin-top:8px;"></div>
        <div class="flex" style="margin-top:10px;">
          <button onclick="registrarVenda()">‚úÖ Confirmar Venda</button>
          <!-- Bot√£o de or√ßamento identific√°vel para ser habilitado/desabilitado via prefer√™ncias -->
          <button id="btnOrcamentoRapida" class="ghost" onclick="abrirOrcamentoUI()">üßæ Or√ßamento</button>
        </div>
        <div class="small" style="margin-top:8px;">
          Dica: Enter em <b>Qtd</b> confirma a venda. O troco √© calculado apenas para pagamentos em dinheiro.
        </div>
      </div>

      <!-- MODO: VENDA COMPLETA -->
      <div id="saleCartWrap" class="fadeSwap" style="display:none;">
        <h3 style="margin-top:0;">Venda Completa (Carrinho: m√∫ltiplos itens + troco)</h3>

        <!--
          O estilo "background" anterior utilizava um tom escuro semi-transparente. Removemos
          essa cor fixa para utilizar a vari√°vel de tema ``--panel2``. Isso
          garante que o cart√£o se adapte ao modo claro, exibindo um painel
          branco suave, e ao modo escuro, mantendo o painel mais escuro.
        -->
        <div class="card cartPulse" id="cartCard" style="margin:0; background:var(--panel2);">
          <div class="grid">
            <input id="c_busca" placeholder="Buscar produto (nome ou c√≥digo)" />
            <select id="c_prod"></select>
            <input id="c_qtd" type="number" placeholder="Qtd" min="1" step="1" value="1" />
            <button onclick="addToCart()">‚ûï Adicionar</button>
          </div>

          <div class="grid" style="margin-top:10px;">
            <input id="c_servico" placeholder="Servi√ßo / M√£o de obra (R$)" inputmode="decimal" />
            <select id="c_pag">
              <option value="dinheiro">Dinheiro</option>
              <option value="pix">Pix</option>
              <option value="debito">D√©bito</option>
              <option value="credito">Cr√©dito</option>
            </select>
            <input id="c_recebido" placeholder="Recebido (s√≥ dinheiro)" inputmode="decimal" />
            <input id="c_troco" placeholder="Troco" disabled />
          </div>

          <div class="small" style="margin-top:8px;" id="c_hint"></div>

          <table class="tight">
            <thead>
              <tr>
                <th>#</th>
                <th class="rowleft">Item</th>
                <th>Qtd</th>
                <th>Unit</th>
                <th>Total</th>
                <th>A√ß√£o</th>
              </tr>
            </thead>
            <tbody id="tCart"></tbody>
          </table>

          <div class="flex" style="margin-top:10px;">
            <div class="stat">üì¶ Itens<br><b><span id="c_itens">0</span></b></div>
            <div class="stat">üí∞ Subtotal<br><b>R$ <span id="c_sub">0,00</span></b></div>
            <!-- Identificador espec√≠fico para a estat√≠stica de servi√ßo, permitindo ocult√°-la nas prefer√™ncias -->
            <div id="c_srv_stat" class="stat">üõ† Servi√ßo<br><b>R$ <span id="c_srv">0,00</span></b></div>
            <div class="stat">‚úÖ Total<br><b>R$ <span id="c_total">0,00</span></b></div>
            <div class="stat">üßÆ Troco<br><b>R$ <span id="c_troco_view">0,00</span></b></div>
          </div>

          <div class="flex" style="margin-top:10px;">
            <button onclick="finalizarCarrinho()">‚úÖ Finalizar Venda (Carrinho)</button>
            <button class="ghost" onclick="limparCarrinho()">üßπ Limpar carrinho</button>
            <!-- Novo bot√£o de scanner: usa o mesmo handler da venda r√°pida para unificar o comportamento.  
                 Ao inv√©s de abrir o modal legado de scanner no modo de venda completa, utilizamos
                 a fun√ß√£o onScannerQuickClick() que aciona o leitor de c√≥digo moderno via Update.scanner.
                 Isso remove a depend√™ncia do sistema de scanner separado na venda completa. -->
            <!-- Scanner no carrinho de venda completa usando o m√≥dulo Skan. Este bot√£o
                 compartilha o mesmo contexto 'vendas' da venda r√°pida para permitir
                 leituras de c√≥digo por c√¢mera e leitores USB. -->
            <button id="btnScannerCart" type="button" class="ghost" onclick="toggleSkan('vendas')">üì∑ Scanner</button>
            <button id="btnPrintReceipt" class="ghost" style="display:none" onclick="imprimirUltimoComprovante()">üñ® Imprimir comprovante</button>
            <!-- Bot√£o para abrir o m√≥dulo de or√ßamento tamb√©m na venda completa -->
            <button id="btnOrcamentoCart" class="ghost" onclick="abrirOrcamentoUI()">üßæ Or√ßamento</button>
          </div>

          <div class="small" style="margin-top:8px;">
            Dicas: Enter na Qtd adiciona item ‚Ä¢ Troco s√≥ em <b>Dinheiro</b> ‚Ä¢ Finalizar exige caixa aberto.
          </div>
        </div>
      </div>
    </div>

    <div class="card hiddenInSimple">
      <h3>Hist√≥rico de Vendas <button id="btnVendasOrder" class="ghost small" title="Alternar ordem" style="margin-left:8px;" onclick="toggleVendasOrder()">‚áÖ Ordem</button></h3>
      <table>
        <thead>
          <tr><th>Data</th><th>Produto</th><th>Qtd</th><th>Total</th><th>Pagamento</th><th>Status</th><th>A√ß√£o</th></tr></thead>
        <tbody id="tVendas"></tbody>
      </table>
      <div class="small" style="margin-top:8px;">
        Obs: vendas do carrinho aparecem como m√∫ltiplas linhas com o mesmo grupo.
      </div>
    </div>

    <!-- OR√áAMENTO -->
    <div class="card" id="orcCard" style="display:none;">
      <h3>üßæ Or√ßamento (n√£o d√° baixa no estoque)</h3>

      <div class="grid">
        <input id="o_cliente" placeholder="Nome do cliente (opcional)" />
        <input id="o_contato" placeholder="Contato do cliente (opcional)" />
        <input id="o_validade" type="number" min="1" step="1" placeholder="Validade (dias) ex: 7" />
      </div>

      <hr style="border:0;border-top:1px solid var(--border);margin:12px 0;opacity:.85">

      <div class="grid">
        <input id="o_busca" placeholder="Buscar produto (nome ou c√≥digo)" />
        <select id="o_prod"></select>
        <input id="o_qtd" type="number" placeholder="Qtd" min="1" step="1" />
        <button onclick="addItemOrc()">‚ûï Adicionar item</button>
      </div>

      <div class="grid" style="margin-top:10px;">
        <input id="o_servico" placeholder="M√£o de obra (R$)" inputmode="decimal" />
        <input id="o_obs" placeholder="Observa√ß√µes do or√ßamento (opcional)" />
      </div>

      <div style="margin-top:12px;">
        <h4 style="margin:6px 0;">Itens do or√ßamento</h4>
        <table class="tight">
          <thead>
            <tr>
              <th>#</th>
              <th class="rowleft">Descri√ß√£o</th>
              <th>Qtd</th>
              <th>Valor</th>
              <th>Total</th>
              <th>A√ß√£o</th>
            </tr>
          </thead>
          <tbody id="tOrcItens"></tbody>
        </table>

        <div class="flex" style="margin-top:10px;">
          <div class="stat">üì¶ Itens<br><b><span id="o_itens">0</span></b></div>
          <div class="stat">üí∞ Subtotal<br><b>R$ <span id="o_sub">0,00</span></b></div>
          <div class="stat">üõ† M√£o de obra<br><b>R$ <span id="o_mao">0,00</span></b></div>
          <div class="stat">‚úÖ Total<br><b>R$ <span id="o_total">0,00</span></b></div>
        </div>

        <div class="flex" style="margin-top:10px;">
          <button onclick="gerarOrcamentoPDF()">üñ® Gerar PDF (Imprimir)</button>
          <button class="ghost" onclick="limparOrc()">üßπ Limpar or√ßamento</button>
          <button class="ghost" onclick="fecharOrcamentoUI()">‚úñ Fechar</button>
        </div>

        <div class="small" style="margin-top:8px;">
          Dicas: <b>Enter</b> na Qtd adiciona item ‚Ä¢ <b>ESC</b> fecha or√ßamento ‚Ä¢ PDF via ‚ÄúSalvar como PDF‚Äù.
        </div>
      </div>
    </div>
  </section>

  <!-- CAIXA -->
  <section id="caixa">
    <div class="card">
      <h3>Abertura de Caixa</h3>
      <input id="cx_abertura" placeholder="Valor inicial (R$)" inputmode="decimal" /><br><br>
      <button onclick="abrirCaixa()">Abrir Caixa</button>
    </div>

    <div class="card">
      <h3>‚ûï‚ûñ Movimento Manual (Entrada / Sa√≠da)</h3>
      <div class="grid">
        <select id="cx_tipo">
          <option value="entrada">Entrada</option>
          <option value="saida">Sa√≠da</option>
        </select>

        <select id="cx_categoria">
          <option value="troco">Troco</option>
          <option value="fornecedor">Fornecedor</option>
          <option value="despesa">Despesa</option>
          <option value="sangria">Sangria</option>
          <option value="outros">Outros</option>
        </select>

        <select id="cx_pag">
          <option value="dinheiro">Dinheiro</option>
          <option value="pix">Pix</option>
          <option value="debito">D√©bito</option>
          <option value="credito">Cr√©dito</option>
        </select>

        <input id="cx_valor" placeholder="Valor (R$)" inputmode="decimal" />
      </div>

      <div class="grid" style="margin-top:10px;">
        <input id="cx_obs" placeholder="Observa√ß√£o (opcional)" />
      </div>

      <br>
      <button onclick="movimentoManual()">Lan√ßar Movimento</button>

      <div class="small" style="margin-top:8px;">
        Use ‚ÄúSa√≠da‚Äù para despesas/fornecedor/sangria. ‚ÄúEntrada‚Äù para ajustes.
      </div>
    </div>

    <div class="card">
      <h3>Fechamento de Caixa</h3>
      <input id="cx_fechamento" placeholder="Valor contado (R$)" inputmode="decimal" /><br><br>
      <button onclick="fecharCaixa()">Fechar Caixa</button>
      <div id="cx_relatorio" style="margin-top:10px"></div>
    </div>

    <!-- Hist√≥rico de Caixa e Impress√£o -->
    <div class="card">
      <h3>Hist√≥rico de Caixa</h3>
      <div class="grid" style="margin-bottom:6px;">
        <input type="date" id="cx_filter_inicio" title="Data inicial" onchange="renderCaixaTable()" />
        <input type="date" id="cx_filter_fim" title="Data final" onchange="renderCaixaTable()" />
        <select id="cx_filter_tipo" title="Filtrar por tipo" onchange="renderCaixaTable()">
          <option value="">Todos</option>
          <option value="entrada">Entradas</option>
          <option value="saida">Sa√≠das</option>
        </select>
        <input id="cx_search" placeholder="Buscar (descri√ß√£o, categoria, respons√°vel)" oninput="renderCaixaTable()" style="flex:1;" />
      </div>
      <table class="tight">
        <thead>
          <tr>
            <th>Data/Hora</th>
            <th>Tipo</th>
            <th>Categoria</th>
            <th>Valor</th>
            <th>Descri√ß√£o</th>
            <th>Pagamento</th>
            <th>Respons√°vel</th>
            <th>A√ß√µes</th>
          </tr>
        </thead>
        <tbody id="tCaixa"></tbody>
      </table>
      <div id="cx_totais" class="small" style="margin-top:8px;"></div>
    </div>
    <div class="card">
      <h3>Impress√£o de Fluxo</h3>
      <div class="grid" style="margin-bottom:6px;">
        <button onclick="imprimirFluxo('diario')">üñ®Ô∏è Imprimir Fluxo Di√°rio</button>
        <button onclick="imprimirFluxo('mensal')">üñ®Ô∏è Imprimir Fluxo Mensal</button>
      </div>
      <div class="small">
        Gera um relat√≥rio detalhado do fluxo de caixa no per√≠odo selecionado e abre a janela de impress√£o.
      </div>
    </div>
  </section>

  <!-- USU√ÅRIOS -->
  <section id="usuarios">
    <div class="card">
      <h3>Cadastro de Usu√°rios</h3>
      <div class="grid">
        <input id="u_user" placeholder="Usu√°rio" />
        <input id="u_pass" type="password" placeholder="Senha" />
        <select id="u_role">
          <option value="admin">Admin</option>
          <option value="operador">Operador</option>
          <option value="caixa">Caixa</option>
          <option value="consulta">Consulta</option>
        </select>
      </div><br>
      <button onclick="addUser()">Criar Usu√°rio</button>

      <table>
        <thead><tr><th>Usu√°rio</th><th>Perfil</th><th>A√ß√µes</th></tr></thead>
        <tbody id="tUsers"></tbody>
      </table>

      <!-- Formul√°rio de edi√ß√£o de usu√°rio -->
      <div id="editUserCard" class="card" style="display:none;">
        <h3>Editar Usu√°rio</h3>
        <div class="grid">
          <input id="edit_username" placeholder="Usu√°rio" readonly />
          <select id="edit_role">
            <option value="admin">Admin</option>
            <option value="operador">Operador</option>
            <option value="caixa">Caixa</option>
            <option value="consulta">Consulta</option>
          </select>
          <label><input type="checkbox" id="perm_editCost" /> Editar custo</label>
          <label><input type="checkbox" id="perm_editPrice" /> Editar pre√ßo</label>
          <label><input type="checkbox" id="perm_deleteProduct" /> Apagar produto</label>
          <label><input type="checkbox" id="perm_cancelSale" /> Cancelar venda</label>
          <label><input type="checkbox" id="perm_closeBox" /> Fechar caixa</label>
          <label><input type="checkbox" id="perm_exportImportBackup" /> Backup/import</label>
          <label><input type="checkbox" id="perm_manageUsers" /> Gerenciar usu√°rios</label>
          <label><input type="checkbox" id="edit_active" /> Ativo</label>
        </div>
        <br>
        <button onclick="saveUserEdit()" class="button-primary">Salvar Altera√ß√µes</button>
        <button onclick="cancelUserEdit()" class="button-secondary">Cancelar</button>
      </div>
    </div>
  </section>

  <!-- PERFIL -->
  <section id="perfil">
    <div class="card">
      <h3>üè¢ Perfil da Empresa</h3>
      <div class="grid">
        <input id="p_nome" placeholder="Nome da empresa" />
        <input id="p_cnpj" placeholder="CNPJ" />
        <input id="p_contato" placeholder="Contato (telefone / e-mail)" />
        <!-- Campos adicionais: endere√ßo, celular e e‚Äëmail. Foram inclu√≠dos aqui para que possam
             ser preenchidos juntos com os demais dados da empresa. -->
        <input id="p_endereco" placeholder="Endere√ßo" />
        <input id="p_celular" placeholder="Celular" />
        <input id="p_email" placeholder="E-mail" />
      </div>
      <!-- Campo para upload do logotipo da empresa -->
      <div style="margin-top:10px;">
        <!-- Esconde o input de arquivo e mostra um bot√£o mais intuitivo para sele√ß√£o -->
        <input id="p_logo" type="file" accept="image/*" style="display:none" />
        <button id="p_logo_btn" type="button" onclick="document.getElementById('p_logo').click()">üì§ Fazer upload de logotipo</button>
      </div>
      <!-- Pr√©-visualiza√ß√£o do logotipo salvo -->
      <img id="p_logo_preview" style="max-width:160px; max-height:160px; margin-top:10px; display:none; border:1px solid var(--border); border-radius:8px;" />
      <br>
      <button onclick="salvarPerfil()">Salvar Perfil</button>
      <div class="small" style="margin-top:10px;">
        Criador: Lucas Rodrigues de Souza ‚Äî 91993017125
      </div>
    </div>

    <div class="card">
      <h3>üìå Dados salvos</h3>
      <div class="small" id="p_view"></div>
    </div>
  </section>

  <!-- AJUSTES -->
  <!-- Nova se√ß√£o centralizando op√ß√µes administrativas, temas e extras -->
  <section id="ajustes">
    <div class="card">
      <h3>‚öôÔ∏è Ajustes</h3>
      <div class="grid config-nav">
        <!-- Navega√ß√£o principal de Ajustes
             Cada bot√£o abaixo ativa uma subse√ß√£o espec√≠fica ou navega para outra tela. -->
        <button onclick="show('perfil')" id="btnCfg_empresa">üè¢ Empresa</button>
        <button onclick="show('usuarios')" id="btnCfg_usuarios">üë• Usu√°rios</button>
        <button onclick="toggleSubAjuste('preferencias')" id="btnCfg_aparencia">‚öôÔ∏è Prefer√™ncias</button>
        <!-- Bot√£o Financeiro removido conforme solicita√ß√£o do cliente. O m√≥dulo financeiro permanece acess√≠vel internamente, mas n√£o √© exibido na navega√ß√£o de ajustes. -->
        <!-- <button onclick="toggleSubAjuste('financeiro')" id="btnCfg_financeiro">üí∞ Financeiro</button> -->
        <!-- Removido bot√£o de Or√ßamentos dos Ajustes. O acesso aos or√ßamentos agora foi movido para Ferramentas. -->
        <button onclick="toggleSubAjuste('arquivo')" id="btnCfg_dados">üíæ Backup &amp; Dados</button>
        <!-- Seguran√ßa removido da navega√ß√£o (fun√ß√µes permanecem acess√≠veis via c√≥digo) -->
        <!-- <button onclick="toggleSubAjuste('seguranca')" id="btnCfg_seguranca">üîí Seguran√ßa</button> -->
        <button onclick="toggleSubAjuste('extras')" id="btnCfg_ferramentas">üõ† Ferramentas</button>
        <button class="danger" onclick="logout()">üö™ Sair</button>
      </div>
    </div>
    <div id="ajusteTema" class="card" style="display:none;">
      <h3>üé® Temas</h3>
      <div class="grid">
        <button onclick="setTheme('default')">Modo Padr√£o</button>
        <button onclick="setTheme('white')">Modo Branco</button>
      </div>
      <div class="small" style="margin-top:8px;">
        O modo branco aplica um tema branco com efeito glass moderno e visual leve.
      </div>
    </div>
    <div id="ajusteArquivo" class="card" style="display:none;">
      <h3>üíæ Salvar / Carregar</h3>
      <div class="grid">
        <!-- Exporta o banco atual em um arquivo JSON no novo formato de backup. -->
        <button onclick="exportBackup()">üíæ Salvar Backup (Arquivo)</button>
        <!-- Abre um seletor de arquivo para importar um JSON de backup no formato erp‚Äëbackup. -->
        <button onclick="openImportBackup()">üìÇ Carregar Backup (Arquivo)</button>
        <!-- Mescla um JSON de backup com o banco atual sem sobrescrever. Somente adiciona/atualiza registros. -->
        <button onclick="openImportBackupMerge()">‚ûï Mesclar Arquivo</button>
        <!-- Permite restaurar rapidamente o backup autom√°tico mais recente caso o banco esteja corrompido. -->
        <button onclick="restoreLastBackupUI()">üîÑ Restaurar √öltimo Backup</button>
        <!-- Exporta todas as vendas registradas em formato CSV para an√°lise externa. -->
        <button onclick="exportarCSVVendas()">üìÑ Exportar CSV de Vendas</button>
      </div>
      <!-- O input de arquivo fica dentro dos ajustes -->
      <input id="loadFile" type="file" accept="application/json" style="display:none" />
      <!-- Input para selecionar um arquivo de backup a ser mesclado. Oculto at√© ser invocado pelo bot√£o Mesclar Arquivo. -->
      <input id="mergeFile" type="file" accept="application/json" style="display:none" />
      <!-- Se√ß√£o de sincroniza√ß√£o com servidor via Netlify Functions -->
      <div id="serverSyncSection" style="margin-top:12px;">
        <h4>‚òÅÔ∏è Sincroniza√ß√£o com Servidor (KV)</h4>
        <div class="grid">
          <button onclick="saveToServer()">‚òÅÔ∏è Salvar no servidor</button>
          <button onclick="loadFromServerReplace()">‚¨áÔ∏è Carregar do servidor (Substituir)</button>
          <button onclick="loadFromServerMerge()">‚ûï Carregar do servidor (Mesclar)</button>
          <button onclick="toggleAutoSync()" id="btnAutoSync">üîÅ Auto Sync</button>
        </div>
        <div id="syncStatus" class="small" style="margin-top:6px;">Status: offline</div>
        <div class="small" style="margin-top:6px;">
          Requer token v√°lido de empresa (tenant) configurado. Usa Cloudflare KV como fonte de dados.
        </div>
      </div>
    </div>
    <div id="ajusteExtras" class="card" style="display:none;">
      <h3>üõ† Ferramentas Extras</h3>
      <!-- Barra de navega√ß√£o das ferramentas -->
      <div id="toolsNav" class="grid" style="margin-bottom:10px;">
        <!-- Reordenado para uma navega√ß√£o mais intuitiva das ferramentas -->
        <button onclick="showTool('calc')">Calculadora</button>
        <button onclick="showTool('conv')">Convers√£o de Unidades</button>
        <button onclick="showTool('pw')">Gerar Senha</button>
        <button onclick="showTool('rand')">Sorteio/Aleat√≥rio</button>
        <button onclick="showTool('notes')">Bloco de Notas</button>
        <button onclick="showTool('todo')">Lista de Tarefas</button>
        <button onclick="showTool('bmi')">C√°lculo de IMC</button>
        <button onclick="showTool('agenda')">Agenda</button>
        <button onclick="showTool('devedores')">Devedores</button>
        <button onclick="showTool('despesas')">Despesas</button>
        <button onclick="showTool('ai')">Assistente Virtual</button>
        <button onclick="showTool('diag')">Diagn√≥stico de Dados</button>
        <!-- Adiciona acesso aos or√ßamentos dentro das Ferramentas. Ao clicar, abre o cart√£o de or√ßamentos. -->
        <!-- Renomeado para Hist√≥rico de Or√ßamentos. Mantemos o mesmo id interno para preservar a l√≥gica existente. -->
        <button onclick="showTool('orcamentos')">üìú Hist√≥rico de Or√ßamentos</button>
      </div>

      <!-- Cards de cada ferramenta, vis√≠veis de acordo com a sele√ß√£o -->
      <!-- Calculadora simples -->
      <div class="card toolCard" id="tool_calc" style="display:none;">
        <h4>Calculadora</h4>
        <div class="grid">
          <input id="calc_expr" placeholder="Digite uma express√£o (ex: 2+3*4)" />
          <button onclick="calculateExpression()">Calcular</button>
        </div>
        <div style="margin-top:6px;">
          Resultado: <span id="calc_result">-</span>
        </div>
      </div>

      <!-- Gerador de Senha -->
      <div class="card toolCard" id="tool_pw" style="display:none;">
        <h4>Gerador de Senha</h4>
        <div class="grid">
          <input id="pw_length" type="number" min="4" step="1" value="12" placeholder="Comprimento" />
          <label><input type="checkbox" id="pw_lower" checked /> min√∫sculas</label>
          <label><input type="checkbox" id="pw_upper" checked /> mai√∫sculas</label>
          <label><input type="checkbox" id="pw_num" checked /> n√∫meros</label>
          <label><input type="checkbox" id="pw_sym" /> s√≠mbolos</label>
        </div>
        <br>
        <button onclick="generatePassword()">Gerar Senha</button>
        <div style="margin-top:6px;">
          <input id="pw_result" readonly style="width:100%; padding:6px; border-radius:8px; border:1px solid var(--border); background:var(--panel2); color:var(--text);" />
        </div>
      </div>

      <!-- Conversor de Unidades -->
      <div class="card toolCard" id="tool_conv" style="display:none;">
        <h4>Conversor de Unidades</h4>
        <div class="grid">
          <input id="conv_value" type="number" step="any" placeholder="Valor" />
          <select id="conv_type">
            <option value="c2f">Celsius ‚Üí Fahrenheit</option>
            <option value="f2c">Fahrenheit ‚Üí Celsius</option>
            <option value="km2mi">Km ‚Üí Milhas</option>
            <option value="mi2km">Milhas ‚Üí Km</option>
          </select>
          <button onclick="convertUnit()">Converter</button>
        </div>
        <div style="margin-top:6px;">
          Resultado: <span id="conv_result">-</span>
        </div>
      </div>

      <!-- Notas / Anota√ß√µes -->
      <div class="card toolCard" id="tool_notes" style="display:none;">
        <h4>Anota√ß√µes</h4>
        <div class="grid">
          <input id="note_text" placeholder="Escreva sua anota√ß√£o..." />
          <button onclick="addNote()">Adicionar</button>
        </div>
        <div id="notes_list" style="margin-top:8px;"></div>
      </div>

      <!-- Lista de Tarefas -->
      <div class="card toolCard" id="tool_todo" style="display:none;">
        <h4>Lista de Tarefas</h4>
        <div class="grid">
          <input id="todo_text" placeholder="Digite uma tarefa..." />
          <button onclick="addTodo()">Adicionar</button>
        </div>
        <div id="todo_list" style="margin-top:8px;"></div>
      </div>

      <!-- Gerador de N√∫mero Aleat√≥rio -->
      <div class="card toolCard" id="tool_rand" style="display:none;">
        <h4>Gerador de N√∫mero Aleat√≥rio</h4>
        <div class="grid">
          <input id="rand_min" type="number" step="any" placeholder="M√≠nimo" />
          <input id="rand_max" type="number" step="any" placeholder="M√°ximo" />
          <button onclick="generateRandom()">Gerar</button>
        </div>
        <div style="margin-top:6px;">
          Resultado: <span id="rand_result">-</span>
        </div>
      </div>

      <!-- Calculadora de IMC -->
      <div class="card toolCard" id="tool_bmi" style="display:none;">
        <h4>Calculadora de IMC</h4>
        <div class="grid">
          <input id="bmi_peso" type="number" step="any" placeholder="Peso (kg)" />
          <input id="bmi_altura" type="number" step="any" placeholder="Altura (m)" />
          <button onclick="calculateBMI()">Calcular</button>
        </div>
        <div style="margin-top:6px;">
          IMC: <span id="bmi_result">-</span> <span id="bmi_class"></span>
        </div>
      </div>

      <!-- Assistente IA -->
      <div class="card toolCard" id="tool_ai" style="display:none;">
        <!-- Nome atualizado do assistente -->
        <h4>Assistente Virtual</h4>
        <!-- √Årea de chat do assistente -->
        <div id="assistant_chat" style="height:220px; overflow-y:auto; display:flex; flex-direction:column; gap:4px; background:var(--panel2); padding:6px; border-radius:6px;"></div>
        <!-- Campo de entrada e bot√£o enviar -->
        <div style="margin-top:6px; display:flex; gap:4px;">
          <input id="assistant_input" placeholder="Digite sua mensagem..." style="flex:1; padding:6px; border-radius:6px; border:1px solid var(--border); background:var(--panel2); color:var(--text);" />
          <button onclick="assistantSendMessage()">Enviar</button>
        </div>
      </div>

      <!-- Agenda (Ferramenta) -->
      <div class="card toolCard" id="tool_agenda" style="display:none;">
        <h4>üìÖ Agenda</h4>
        <div class="card">
          <div class="grid">
            <input id="ag_titulo" placeholder="T√≠tulo / Evento" />
            <input id="ag_data" type="text" placeholder="Data/hora (ex: 2026-02-02 15:00)" />
            <input id="ag_desc" placeholder="Descri√ß√£o (opcional)" />
          </div>
          <br>
          <button onclick="addAgendaItem()">Adicionar Evento</button>
        </div>
        <div class="card" style="margin-top:10px;">
          <h5>üìã Pr√≥ximos Eventos</h5>
          <table>
            <thead>
              <tr><th>Data/Hora</th><th>T√≠tulo</th><th>Descri√ß√£o</th><th>Status</th><th>A√ß√µes</th></tr>
            </thead>
            <tbody id="tAgenda"></tbody>
          </table>
        </div>
      </div>

      <!-- Devedores (Ferramenta) -->
      <div class="card toolCard" id="tool_devedores" style="display:none;">
        <h4>üí≥ Devedores / Fiado</h4>
        <div class="card">
          <div class="grid">
            <!-- Campos de entrada para registrar ou editar um devedor. Os IDs s√£o
                 mantidos para reaproveitar valida√ß√µes e persist√™ncia. -->
            <input id="dv_nome" placeholder="Nome do devedor" />
            <input id="dv_valor" placeholder="Valor (R$)" inputmode="decimal" />
            <input id="dv_data" type="text" placeholder="Prazo (ex: 2026-02-10)" />
            <input id="dv_desc" placeholder="Observa√ß√µes (opcional)" />
          </div>
          <br>
          <!-- Bot√µes para adicionar ou salvar edi√ß√£o de um devedor. 'dvBtnAdd' ser√°
               reutilizado como bot√£o de salvar quando um devedor estiver em edi√ß√£o.
               'dvBtnCancel' permite cancelar a edi√ß√£o corrente. Ambos s√£o
               configurados dinamicamente via JavaScript. -->
          <div class="flex">
            <button id="dvBtnAdd" onclick="addDevedor()">Adicionar Devedor</button>
            <button id="dvBtnCancel" class="ghost" style="display:none" onclick="cancelEditDevedor()">Cancelar edi√ß√£o</button>
          </div>
        </div>
        <div class="card" style="margin-top:10px;">
          <h5>üìú Lista de Devedores</h5>
          <table>
            <thead>
              <tr><th>Nome</th><th>Valor</th><th>Prazo</th><th>Status</th><th>Obs</th><th>A√ß√µes</th></tr>
            </thead>
            <tbody id="tDevedores"></tbody>
          </table>
        </div>
      </div>

      <!-- Despesas Mensais (Ferramenta) -->
      <div class="card toolCard" id="tool_despesas" style="display:none;">
        <h4>üí∞ Despesas Mensais</h4>
        <div id="despesasTable"></div>
        <div class="small" style="margin-top:8px;">
          Registre despesas fixas e vari√°veis como aluguel, √°gua, energia ou outras. Clique em ‚ÄúAdicionar Despesa‚Äù para inserir novas linhas.
        </div>
        <div class="flex" style="margin-top:10px; gap:8px; flex-wrap:wrap;">
          <button onclick="addDespesaRow()">‚ûï Adicionar Despesa</button>
          <button onclick="calcularDespesas()">üìä Calcular Rentabilidade</button>
          <button class="ghost" onclick="limparDespesas()">üßπ Limpar Despesas</button>
          <!-- Novo bot√£o para contabilidade completa: balan√ßos e relat√≥rios. -->
          <button onclick="toggleContabilidade()">üìë Contabilidade</button>
        </div>
        <div id="despesasResultado" style="margin-top:10px;"></div>
        <!-- Card de contabilidade: inicializa oculto e √© exibido quando o bot√£o de contabilidade √© pressionado. -->
        <div id="contabilidadeCard" class="card" style="display:none; margin-top:12px;">
          <h4>üìë Contabilidade</h4>
          <div class="small">Selecione um per√≠odo para gerar o balan√ßo:</div>
          <div class="flex" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
            <button onclick="contabPeriodo('dia')">Hoje</button>
            <button onclick="contabPeriodo('mes')">M√™s atual</button>
            <button onclick="contabPeriodo('3meses')">√öltimos 3 meses</button>
            <button onclick="contabPeriodo('6meses')">√öltimos 6 meses</button>
            <button onclick="contabPeriodo('ano')">Ano atual</button>
            <input type="month" id="contabMesSel" onchange="contabPeriodo('mesSel', this.value)" style="min-width:130px;" />
            <input type="number" id="contabAnoSel" placeholder="Ano" onchange="contabPeriodo('anoSel', this.value)" style="width:80px;" />
          </div>
          <div id="contabResult" style="margin-top:12px;"></div>
          <div class="noPrint" style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
            <button onclick="printContabilidade()">üñ® Imprimir</button>
          </div>
        </div>
      </div>

      <!-- Diagn√≥stico de Dados (Ferramenta) -->
      <div class="card toolCard" id="tool_diag" style="display:none;">
        <h4>Diagn√≥stico de Dados</h4>
        <div class="small">
          Verifica a consist√™ncia do banco de dados atual e detecta poss√≠veis problemas como c√≥digos duplicados,
          valores inv√°lidos ou produtos sem informa√ß√µes essenciais.
        </div>
        <br>
        <button onclick="runDiagnostic()">Executar Diagn√≥stico</button>
        <div id="diag_result" style="margin-top:8px;"></div>
      </div>

      <!-- Hist√≥rico de Or√ßamentos (Ferramenta) -->
      <div class="card toolCard" id="tool_orcamentos" style="display:none;">
        <h4>üìú Hist√≥rico de Or√ßamentos</h4>
        <!-- Cont√™iner dedicado √† lista de or√ßamentos na √°rea de ferramentas. Reutiliza a mesma fun√ß√£o
             renderOrcamentos() para popular a tabela, fornecendo a mesma experi√™ncia dos Ajustes. -->
        <div id="orcamentosListTool"></div>
        <div class="small" style="margin-top:8px;">
          Os or√ßamentos salvos aparecem aqui. Voc√™ pode aprovar para transformar em venda (dando baixa
          no estoque), editar ou excluir definitivamente.
        </div>
      </div>

    </div><!-- fim ajusteExtras -->

    <!-- Ajuste de perfil de com√©rcio: define o tipo de neg√≥cio (supermercado, loja ou assist√™ncia) -->
    <div id="ajusteComercio" class="card" style="display:none;">
      <h3>üè™ Perfil de Com√©rcio</h3>
      <div class="grid">
        <button onclick="setCommerceProfile('super')">Supermercado / Mercearia</button>
        <button onclick="setCommerceProfile('store')">Loja Comum</button>
        <button onclick="setCommerceProfile('service')">Assist√™ncia T√©cnica / OS</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Selecione o perfil que melhor representa seu neg√≥cio para ativar fun√ß√µes espec√≠ficas (por exemplo, descontos em mercado ou ordens de servi√ßo em assist√™ncia t√©cnica).
      </div>
    </div><!-- fim ajusteComercio -->
    <!-- Ajuste de Interface: controla modos de layout -->
    <div id="ajusteInterface" class="card" style="display:none;">
      <h3>üñ• Interface</h3>
      <div class="grid">
        <button onclick="setInterfaceMode('standard')">Interface Padr√£o</button>
        <button onclick="setInterfaceMode('simple')">Interface Simples</button>
      </div>
      <div class="small" style="margin-top:8px;">
        A interface simples reorganiza o layout para uma experi√™ncia mais intuitiva e minimalista.
      </div>
    </div><!-- fim ajusteInterface -->

    <!-- Ajuste de Prefer√™ncias: agrupa temas, interface e configura√ß√µes de vendas -->
    <div id="ajustePreferencias" class="card" style="display:none;">
      <h3>‚öôÔ∏è Prefer√™ncias</h3>
      <!-- Se√ß√£o de temas -->
      <h4>üé® Temas</h4>
      <div class="grid">
        <button onclick="setTheme('default')">Modo Padr√£o</button>
        <button onclick="setTheme('white')">Modo Branco</button>
      </div>
      <!-- Se√ß√£o de layout (interface padr√£o ou simples) -->
      <h4 style="margin-top:10px;">üñ• Layout</h4>
      <div class="grid">
        <button onclick="setInterfaceMode('standard')">Padr√£o Completo</button>
        <button onclick="setInterfaceMode('simple')">Modo Simples</button>
        <button onclick="setUIMode('smartphone')">Modo Smartphone</button>
        <!-- Removido bot√£o "Modo Celular" para unificar smartphone/celular -->
      </div>
      <!-- Se√ß√£o de modo de tela (desktop/smartphone/autom√°tico) -->
      <h4 style="margin-top:10px;">üì± Modo de Tela</h4>
      <div class="grid">
        <button onclick="setUIMode('desktop')">For√ßar Desktop</button>
        <button onclick="setUIMode('auto')">Autom√°tico</button>
        <!-- Removido bot√£o "For√ßar Smartphone" para unificar modos -->
        <button onclick="setUIMode('mobile')">For√ßar Celular</button>
      </div>
      <div class="small" style="margin-top:6px;">
        O modo de tela determina se a navega√ß√£o fica na parte superior
        (desktop) ou inferior (smartphone). O modo autom√°tico muda
        automaticamente conforme a largura da tela.
      </div>
      <!-- Acessibilidade -->
      <h4 style="margin-top:10px;">üßì Acessibilidade</h4>
      <div class="grid">
        <button onclick="toggleLargeFont()">Alternar Fonte Grande</button>
      </div>
      <div class="small" style="margin-top:6px;">
        Ative a fonte grande para facilitar a leitura em telas pequenas ou por usu√°rios com baixa vis√£o.
      </div>
      <!-- Se√ß√£o de configura√ß√µes de vendas -->
      <h4 style="margin-top:10px;">‚öôÔ∏è Configura√ß√µes de Vendas</h4>
      <div class="grid">
        <button id="btnToggleScanner" onclick="togglePreference('scannerEnabled')">Desativar Scanner</button>
        <button id="btnToggleOrcamento" onclick="togglePreference('orcamentoEnabled')">Desativar Or√ßamento</button>
        <button id="btnToggleMaoObra" onclick="togglePreference('maoObraEnabled')">Desativar M√£o de Obra</button>
        <!-- Novo: alternar modo Venda R√°pida (quando desativado oculta o modo r√°pido) -->
        <button id="btnToggleQuickSale" onclick="togglePreference('quickSaleEnabled')">Desativar Venda R√°pida</button>
        <!-- Nota Fiscal: PDF e Impressa -->
        <button id="btnToggleNfPDF" onclick="togglePreference('nf_pdf_enabled')">Ativar NF em PDF</button>
        <button id="btnToggleNfPrint" onclick="togglePreference('nf_print_enabled')">Ativar NF Impressa</button>
      </div>
      <div class="small" style="margin-top:8px;">
        As prefer√™ncias acima controlam a exibi√ß√£o de recursos sens√≠veis. Altera√ß√µes s√£o salvas imediatamente e refletem em toda a interface.
      </div>

      <!-- Novo: sele√ß√£o de dispositivos de scanner e impressora -->
      <h4 style="margin-top:10px;">üñ® Dispositivos</h4>
      <div class="grid">
        <label style="display:flex; flex-direction:column;">
          Scanner
          <select id="cfg_scanDevice" onchange="setScanDevice(this.value)">
            <option value="camera">C√¢mera</option>
            <option value="usb">USB / Teclado</option>
          </select>
        </label>
        <label style="display:flex; flex-direction:column;">
          Impressora
          <select id="cfg_printerDevice" onchange="setPrinterDevice(this.value)">
            <option value="default">Padr√£o</option>
            <option value="thermal">T√©rmica (80mm)</option>
          </select>
        </label>
      </div>
      <div class="small" style="margin-top:6px;">
        Selecione o dispositivo que ser√° usado para leitura de c√≥digos (c√¢mera ou USB) e a impressora
        para recibos. A op√ß√£o t√©rmica ajusta a largura do comprovante para bobinas de 80&nbsp;mm.
      </div>
    </div><!-- fim ajustePreferencias -->

    <!-- Ajuste de Despesas Mensais: m√≥dulo original, agora oculto -->
    <div id="ajusteDespesas_old" class="card" style="display:none;">
      <h3>üí∞ Despesas Mensais</h3>
      <div id="despesasTable_old"></div>
      <div class="small" style="margin-top:8px;">
        Registre despesas fixas e vari√°veis como aluguel, √°gua, energia ou outras. Clique em "Adicionar Despesa" para inserir novas linhas.
      </div>
      <div class="flex" style="margin-top:10px; gap:8px; flex-wrap:wrap;">
        <button onclick="addDespesaRow()">‚ûï Adicionar Despesa</button>
        <button onclick="calcularDespesas()">üìä Calcular Rentabilidade</button>
        <button class="ghost" onclick="limparDespesas()">üßπ Limpar Despesas</button>
      </div>
      <div id="despesasResultado_old" style="margin-top:10px;"></div>
    </div><!-- fim ajusteDespesas -->

    <!-- Ajuste Financeiro: configura√ß√µes de margem/markup e arredondamento -->
    <div id="ajusteFinanceiro" class="card" style="display:none;">
      <h3>üí∞ Financeiro</h3>
      <div class="grid">
        <label style="display:flex; flex-direction:column;">
          Modo de Lucro
          <select id="cfg_profitMode" onchange="setProfitMode(this.value)">
            <option value="markup">Markup (sobre custo)</option>
            <option value="margin">Margem (sobre pre√ßo)</option>
          </select>
        </label>
        <label style="display:flex; flex-direction:column;">
          Arredondamento
          <select id="cfg_profitRound" onchange="setProfitRounding(this.value)">
            <option value="none">Sem arredondamento</option>
            <option value="0.99">Final 0,99</option>
            <option value="0.90">Final 0,90</option>
            <option value="integer">Inteiro</option>
          </select>
        </label>
      </div>
      <div class="small" style="margin-top:8px;">
        Configure como os pre√ßos de venda s√£o calculados a partir do custo.
        O modo <b>Markup</b> aplica a porcentagem sobre o custo; o modo <b>Margem</b> calcula sobre o pre√ßo final.
        A regra de arredondamento define o formato desejado dos valores.
      </div>
    </div><!-- fim ajusteFinanceiro -->

    <!-- Ajuste Or√ßamentos: lista e gerencia or√ßamentos salvos -->
    <div id="ajusteOrcamentos" class="card" style="display:none;">
      <!-- Renomeado para refletir o hist√≥rico de or√ßamentos pendentes/aprovados -->
      <h3>üìú Hist√≥rico de Or√ßamentos</h3>
      <div id="orcamentosList"></div>
      <div class="small" style="margin-top:8px;">
        Os or√ßamentos salvos aparecem aqui. Voc√™ pode aprovar para transformar em venda (dando baixa
        no estoque) ou excluir definitivamente.
      </div>
    </div><!-- fim ajusteOrcamentos -->

    <!-- Ajuste Seguran√ßa: configura expira√ß√£o de sess√£o, limite de tentativas e auditoria -->
    <div id="ajusteSeguranca" class="card" style="display:none;">
      <h3>üîí Seguran√ßa</h3>
      <div class="grid">
        <label style="display:flex; flex-direction:column;">
          Expira√ß√£o de Sess√£o (min)
          <input id="input_session_timeout" type="number" min="1" step="1" placeholder="Minutos" />
        </label>
        <button onclick="updateSessionTimeout()">Salvar tempo</button>
        <label style="display:flex; flex-direction:column;">
          Limite de Tentativas de Login
          <input id="input_login_attempts" type="number" min="1" step="1" placeholder="Tentativas" />
        </label>
        <button onclick="updateLoginAttemptLimit()">Salvar limite</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Defina por quantos minutos a sess√£o permanece ativa sem intera√ß√£o e o n√∫mero de tentativas
        de login incorretas antes de bloquear temporariamente o acesso.
      </div>
      <div class="flex" style="margin-top:10px; gap:8px; flex-wrap:wrap;">
        <button onclick="toggleAuditLog()">Ver Log de Auditoria</button>
        <button class="danger" onclick="clearAuditLog()">Limpar Log</button>
      </div>
      <div class="card" id="auditLogCard" style="display:none; margin-top:10px; max-height:300px; overflow-y:auto;">
        <h4>üìë Log de Auditoria</h4>
        <table style="width:100%; font-size:0.9em;">
          <thead><tr><th>Data/Hora</th><th>Usu√°rio</th><th>A√ß√£o</th><th>Detalhes</th></tr></thead>
          <tbody id="auditLogBody"></tbody>
        </table>
      </div>
    </div><!-- fim ajusteSeguranca -->
    </div>
  </section>

  <!-- AGENDA (m√≥dulo original, agora oculto) -->
  <section id="agenda_old">
    <div class="card">
      <h3>üìÖ Agenda</h3>
      <div class="grid">
        <input id="ag_titulo_old" placeholder="T√≠tulo / Evento" />
        <!--
          Alterado para ``type="text"`` para permitir a digita√ß√£o manual da data e
          hora. O valor deve ser informado em um formato aceit√°vel pelo
          JavaScript (por exemplo: "2026-02-02 15:00" ou "02/02/2026 15:00").
          O campo datetime-local causava problemas de usabilidade em alguns
          navegadores e n√£o permitia a digita√ß√£o manual.
        -->
        <input id="ag_data_old" type="text" placeholder="Data/hora (ex: 2026-02-02 15:00)" />
        <input id="ag_desc_old" placeholder="Descri√ß√£o (opcional)" />
      </div>
      <br>
      <button onclick="addAgendaItem()">Adicionar Evento</button>
    </div>
    <div class="card">
      <h3>üìã Pr√≥ximos Eventos</h3>
      <table>
        <thead>
          <tr><th>Data/Hora</th><th>T√≠tulo</th><th>Descri√ß√£o</th><th>Status</th><th>A√ß√µes</th></tr>
        </thead>
        <tbody id="tAgenda_old"></tbody>
      </table>
    </div>
  </section>

  <!-- DEVEDORES (m√≥dulo original, agora oculto) -->
  <section id="devedores_old">
    <div class="card">
      <h3>üí≥ Devedores / Fiado</h3>
      <div class="grid">
        <input id="dv_nome_old" placeholder="Nome do devedor" />
        <input id="dv_valor_old" placeholder="Valor (R$)" inputmode="decimal" />
        <!--
          Alterado para ``type="text"`` permitindo digita√ß√£o manual de datas.
          Informe a data de vencimento em um formato compreens√≠vel pelo
          JavaScript, por exemplo "2026-02-10" ou "10/02/2026". O campo
          ``date`` original n√£o permitia inser√ß√£o manual em alguns
          navegadores.
        -->
        <input id="dv_data_old" type="text" placeholder="Prazo (ex: 2026-02-10)" />
        <input id="dv_desc_old" placeholder="Observa√ß√µes (opcional)" />
      </div>
      <br>
      <button onclick="addDevedor()">Adicionar Devedor</button>
    </div>
    <div class="card">
      <h3>üìú Lista de Devedores</h3>
      <table>
        <thead>
          <tr><th>Nome</th><th>Valor</th><th>Prazo</th><th>Status</th><th>Obs</th><th>A√ß√µes</th></tr>
        </thead>
        <tbody id="tDevedores_old"></tbody>
      </table>
    </div>
  </section>

</section>

<footer id="credits">
  Criador: <b>Lucas Rodrigues de Souza</b> ‚Ä¢ Contato: <b>91993017125</b>
</footer>

<script>
// Habilita o modo estrito do JavaScript em todo este script. Isto ajuda a detectar
// vari√°veis n√£o declaradas e outros erros silenciosos em tempo de execu√ß√£o.
'use strict';

/* =========================
   Helpers gerais + Money FIX
   ========================= */
function $(id){ return document.getElementById(id); }
function s(v){ return String(v ?? "").trim(); }
function isEmpty(v){ return s(v).length === 0; }
function escapeHTML(str){
  return String(str ?? "").replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
  }[m]));
}
function makeId(){ return Date.now() + Math.floor(Math.random()*100000); }
function clampInt(v, def=0){
  v = Number(v);
  if(!Number.isFinite(v)) return def;
  return Math.max(0, Math.floor(v));
}
function pct(val, max){
  if(!max || max <= 0) return 0;
  return Math.max(0, Math.min(100, (val/max)*100));
}

/*
  ========================
  Utilidades de seguran√ßa e convers√£o
  Estas fun√ß√µes encapsulam opera√ß√µes comuns como acesso ao localStorage e
  convers√µes num√©ricas para tornar o c√≥digo mais robusto. Usar estas
  utilidades ajuda a evitar NaN, undefined e exce√ß√µes de quota nos
  navegadores. Elas n√£o alteram o comportamento existente, apenas
  fornecem caminhos seguros para opera√ß√µes que podem falhar.
*/
function safeLocalGet(key, defaultVal=null){
  try{
    const v = localStorage.getItem(key);
    return (v === null || v === undefined) ? defaultVal : v;
  }catch(e){
    console.warn('safeLocalGet error', e);
    return defaultVal;
  }
}
function safeLocalSet(key, value){
  try{
    localStorage.setItem(key, value);
    return true;
  }catch(e){
    console.warn('safeLocalSet error', e);
    return false;
  }
}
function safeLocalRemove(key){
  try{
    localStorage.removeItem(key);
    return true;
  }catch(e){
    console.warn('safeLocalRemove error', e);
    return false;
  }
}
function safeJSONParse(str, defaultVal=null){
  if(!str || typeof str !== 'string') return defaultVal;
  try{
    return JSON.parse(str);
  }catch(e){
    console.warn('safeJSONParse error', e);
    return defaultVal;
  }
}
function toNumber(value, defaultVal=0){
  const n = Number(value);
  return Number.isFinite(n) ? n : defaultVal;
}
function toPositiveInt(value, defaultVal=0){
  const n = toNumber(value, defaultVal);
  const int = Math.floor(n);
  return int >= 0 ? int : defaultVal;
}
function parsePercent(value){
  const v = parseFloat(String(value ?? '').replace(',', '.'));
  return Number.isFinite(v) ? v : 0;
}
function parseBRDateTime(str){
  try{
    const parts = String(str).split(",").map(x=>x.trim());
    const datePart = parts[0];
    const timePart = parts[1] || "00:00:00";
    if(!datePart) return new Date(str);
    const [dd, mm, yyyy] = datePart.split("/").map(Number);
    const [hh, mi, ss] = timePart.split(":" ).map(Number);
    return new Date(yyyy, (mm||1)-1, dd||1, hh||0, mi||0, ss||0);
  }catch(e){ return new Date(str); }
}
function dateKeyLocal(dt){
  const y = dt.getFullYear();
  const m = String(dt.getMonth()+1).padStart(2,"0");
  const d = String(dt.getDate()).padStart(2,"0");
  return `${y}-${m}-${d}`;
}
/*
  ========================
  Formata√ß√£o de datas e valores
  ========================
  Estas utilidades fornecem fun√ß√µes consistentes para formatar datas
  e valores monet√°rios em todo o sistema. Elas centralizam as regras de
  formata√ß√£o e evitam duplica√ß√£o de l√≥gica em m√∫ltiplos pontos.
*/
// Retorna uma string local (pt-BR) para uma data. Se a data n√£o for
// fornecida, usa o instante atual. Em caso de erro, retorna a entrada
// como string ou a data atual como fallback.
function formatDateTime(date) {
  try {
    const d = date instanceof Date ? date : (date ? new Date(date) : new Date());
    return d.toLocaleString('pt-BR');
  } catch(e) {
    try { return new Date().toLocaleString('pt-BR'); } catch(_) { return String(date); }
  }
}
// Conveni√™ncia para obter o timestamp local atual no formato padr√£o.
function nowDateTime() {
  return formatDateTime(new Date());
}
// Converte centavos em uma representa√ß√£o monet√°ria brasileira com prefixo "R$"
// e separadores adequados. Usa a fun√ß√£o existente centsToBR para o formato
// b√°sico, adicionando o s√≠mbolo da moeda para consist√™ncia.
function formatCurrencyBR(cents) {
  return `R$ ${centsToBR(cents)}`;
}
// Remove espa√ßos especiais (como NBSP) e colapsa m√∫ltiplos espa√ßos em um √∫nico.
// √ötil para limpar entradas de usu√°rio antes de processamento.
function sanitizeInputString(str) {
  return String(str ?? '')
    .replace(/\u00a0/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

/* =========================
   MONEY: sempre em centavos
   ========================= */
function parseMoneyToCents(input){
  let t = s(input);
  if(t === "") return 0;
  t = t.replace(/\s+/g,"");
  if(t.includes(",")){
    t = t.replace(/\./g,"").replace(",", ".");
  }
  t = t.replace(/[^0-9.\-]/g,"");
  if(t === "" || t === "-" || t === "." || t === "-.") return 0;
  const num = Number(t);
  if(!Number.isFinite(num)) return 0;
  return Math.round(num * 100);
}
function centsToBR(cents){
  const v = Number(cents);
  if(!Number.isFinite(v)) return "0,00";
  const abs = Math.abs(v);
  const reais = Math.floor(abs/100);
  const cent = abs % 100;
  const reaisStr = String(reais).replace(/\B(?=(\d{3})+(?!\d))/g, ".");
  const out = `${reaisStr},${String(cent).padStart(2,"0")}`;
  return v < 0 ? `-${out}` : out;
}
function addCents(a,b){
  a = Number(a); b = Number(b);
  if(!Number.isFinite(a)) a = 0;
  if(!Number.isFinite(b)) b = 0;
  return a + b;
}
function mulCents(unitCents, qty){
  unitCents = Number(unitCents); qty = Number(qty);
  if(!Number.isFinite(unitCents)) unitCents = 0;
  if(!Number.isFinite(qty)) qty = 0;
  return Math.round(unitCents * qty);
}
function moneyOf(obj, centsField, floatField){
  if(obj && Number.isFinite(Number(obj[centsField]))) return Number(obj[centsField]);
  if(obj && Number.isFinite(Number(obj[floatField]))) return Math.round(Number(obj[floatField]) * 100);
  return 0;
}

/*
  ========================
  Busca, ordena√ß√£o, filtros e pagina√ß√£o do estoque
  Estas vari√°veis e fun√ß√µes implementam uma busca avan√ßada com m√∫ltiplos
  termos (ignorando acentos), filtros r√°pidos, ordena√ß√£o clic√°vel nas
  colunas e pagina√ß√£o para grandes listas.  A UI utiliza os bot√µes
  definidos em estoqueFilters e atualiza a tabela via render().
*/

// Armazena os termos de busca atuais no estoque.  √â atualizado pelo
// updateEstoqueSearch() sempre que o usu√°rio digitar na caixa de busca.
let estoqueSearchTerms = [];
// Quantidade de itens por p√°gina no estoque.  Pode ser ajustado para
// controlar a performance em listas grandes.
const ESTOQUE_PAGE_SIZE = 50;
// P√°gina atualmente exibida.  Inicia em 1.
let estoquePage = 1;
// Coluna pela qual o estoque est√° sendo ordenado (ex.: 'cod', 'nome').
// Ordena√ß√£o inicial: ordena alfabeticamente por nome em vez do c√≥digo.
let estoqueSortField = 'nome';
// Dire√ß√£o da ordena√ß√£o: 1 para ascendente, -1 para descendente.
let estoqueSortDir = 1;
// Estado dos filtros r√°pidos.  Cada chave corresponde a um bot√£o de filtro.
let estoqueFilters = {
  belowMin: false, // somente itens com quantidade <= m√≠nimo
  negProfit: false, // somente itens com lucro negativo (pre√ßo < custo)
  noPrice: false, // somente itens sem pre√ßo definido
  noCost: false   // somente itens sem custo definido
};

// Remove acentos e normaliza para min√∫sculas.  Utilizado na busca.
function removeAccents(str){
  return String(str ?? '').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
}

// Atualiza os termos de busca do estoque.  Divide a entrada em palavras e
// remove acentos para permitir buscas como "cafe 500g".
function updateEstoqueSearch(){
  const raw = String($("estoqueSearch")?.value || '').trim();
  const tokens = removeAccents(raw).split(/\s+/).filter(Boolean);
  estoqueSearchTerms = tokens;
}

// Alterna o valor de um filtro r√°pido.  Atualiza a classe 'active' no
// bot√£o correspondente para indicar visualmente o estado.  Ap√≥s a
// altera√ß√£o, renderiza a tabela.
function toggleEstoqueFilter(name){
  if(!estoqueFilters.hasOwnProperty(name)) return;
  estoqueFilters[name] = !estoqueFilters[name];
  const btn = $("f_"+name);
  if(btn){
    if(estoqueFilters[name]) btn.classList.add('active');
    else btn.classList.remove('active');
  }
  render(true);
}

// Altera a coluna de ordena√ß√£o do estoque.  Se a mesma coluna for
// selecionada consecutivamente, inverte a dire√ß√£o (asc/desc).  Depois
// chama render() para atualizar a exibi√ß√£o.
function sortEstoque(field){
  if(estoqueSortField === field){
    estoqueSortDir = -estoqueSortDir;
  }else{
    estoqueSortField = field;
    estoqueSortDir = 1;
  }
  render(true);
}

// Define a ordena√ß√£o do estoque com base em op√ß√µes predefinidas.
// "nome" ordena alfabeticamente de A a Z; "added" ordena pela data de adi√ß√£o (mais recentes primeiro).
function setEstoqueOrder(order){
  if(order === 'nome' || order === 'alfabetica'){
    estoqueSortField = 'nome';
    estoqueSortDir = 1;
  } else if(order === 'added'){
    estoqueSortField = 'added';
    // Mostra os itens mais novos primeiro ao ordenar por data de adi√ß√£o
    estoqueSortDir = -1;
  }
  render(true);
}

// Define a p√°gina atual do estoque.  Ignora valores inv√°lidos ou fora do
// intervalo.  Ap√≥s atualizar, chama render() para atualizar a tabela.
function setEstoquePage(p){
  const page = Number(p);
  if(!Number.isFinite(page) || page < 1) return;
  estoquePage = page;
  render(true);
}

// Constr√≥i a barra de pagina√ß√£o com bot√µes de navega√ß√£o.  Recebe o
// n√∫mero total de p√°ginas e injeta HTML no elemento #estoquePagination.
function buildEstoquePagination(totalPages){
  const wrap = $("estoquePagination");
  if(!wrap) return;
  // Limitar a quantidade de bot√µes mostrados para no m√°ximo 5 p√°ginas ao
  // redor da p√°gina atual, para n√£o poluir a interface.
  let html = '';
  const prevDisabled = estoquePage <= 1 ? 'disabled' : '';
  const nextDisabled = estoquePage >= totalPages ? 'disabled' : '';
  // Bot√£o anterior
  html += `<button class="ghost" ${prevDisabled} onclick="setEstoquePage(${Math.max(1, estoquePage-1)})">‚óÄ</button>`;
  // Determinar o intervalo de p√°ginas a serem exibidas
  let start = Math.max(1, estoquePage - 2);
  let end   = Math.min(totalPages, start + 4);
  // Ajustar in√≠cio se estiver perto do fim
  if(end - start < 4) start = Math.max(1, end - 4);
  for(let i = start; i <= end; i++){
    const active = i === estoquePage ? 'active' : '';
    html += `<button class="ghost ${active}" onclick="setEstoquePage(${i})">${i}</button>`;
  }
  // Bot√£o pr√≥ximo
  html += `<button class="ghost" ${nextDisabled} onclick="setEstoquePage(${Math.min(totalPages, estoquePage+1)})">‚ñ∂</button>`;
  wrap.innerHTML = html;
}

// Destaca ocorr√™ncias dos termos de busca dentro de uma string usando
// <mark>.  Escapa HTML para evitar injection.
function highlightMatches(text){
  let out = escapeHTML(String(text ?? ''));
  estoqueSearchTerms.forEach(term => {
    if(!term) return;
    try{
      const regex = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      out = out.replace(regex, match => `<mark>${escapeHTML(match)}</mark>`);
    }catch(e){ /* ignore invalid regex */ }
  });
  return out;
}

/* ========== Toast ========== */
function toast(msg, type="ok"){
  const wrap = $("toastWrap");
  if(!wrap) return alert(msg);
  const t = document.createElement("div");
  t.className = `toast ${type}`;
  const ico = type==="ok" ? "‚úÖ" : type==="warn" ? "‚ö†Ô∏è" : "‚ùå";
  t.innerHTML = `<div class="ico">${ico}</div><div class="msg">${escapeHTML(msg)}</div>`;
  wrap.appendChild(t);

  const kill = ()=>{
    t.style.opacity="0";
    t.style.transform="translateY(8px)";
    setTimeout(()=>{ try{ wrap.removeChild(t); }catch(e){} }, 340);
  };

  setTimeout(()=> requestAnimationFrame(kill), 2400);
}

/* =========================
   DB (localStorage)
   ========================= */
// Objeto de banco de dados padr√£o. Todos os campos s√£o inicializados explicitamente para
// garantir que a normaliza√ß√£o n√£o falhe quando o localStorage estiver vazio ou
// conter dados inesperados. Adicionamos a cole√ß√£o "despesas" para o m√≥dulo
// de despesas mensais, permitindo sua persist√™ncia junto aos demais dados.
let db={
  usuarios:[{user:"admin",pass:"123",role:"admin", owner:"admin", ativo:true, criadoEm:nowDateTime()}],
  empresa:{ nome:"", cnpj:"", contato:"" },
  estoque:[],
  vendas:[],
  caixa:[],
  caixaAberto:false,
  /* Novas cole√ß√µes para a agenda, lista de devedores (fiados) e notas nas ferramentas extras */
  agenda:[],
  devedores:[],
  notes:[],
  /* lista de tarefas para o bloco "Lista de Tarefas" nas ferramentas extras */
  todos:[],
  /* despesas mensais armazenadas em centavos (nome, valor_c) */
  despesas:[],
  // Logs de auditoria: lista de a√ß√µes sens√≠veis realizadas no sistema
  audit:[],
  _meta:{ moneyMode:"cents", schema:2 }
};

// Persiste o banco no localStorage. Envolvemos em try/catch para capturar
// exce√ß√µes como quota excedida ou storage desabilitado. Caso ocorra
// falha, exibimos um alerta ao usu√°rio e registramos no console para
// depura√ß√£o. O sistema continua operando com o dado em mem√≥ria, mas
// recomendamos ao usu√°rio salvar um backup para n√£o perder altera√ß√µes.
function save(){
  try{
    // Verificar se outro contexto atualizou o banco (controle de vers√µes entre abas)
    try{
      // usa leitura segura do localStorage para evitar exce√ß√µes
      const remoteStr = safeLocalGet("ERP_LUKAS_LOGIN_OK", null);
      if(remoteStr){
        try{
          const remoteObj = JSON.parse(remoteStr);
          const remoteSavedAt = remoteObj && remoteObj._meta && remoteObj._meta.savedAt;
          if(remoteSavedAt && window.lastLoadedSavedAt && remoteSavedAt !== window.lastLoadedSavedAt){
            toast("Os dados foram modificados em outra aba. Recarregue a p√°gina para obter a vers√£o mais recente.", "warn");
            return;
          }
        }catch(_ex){}
      }
    }catch(_){/* ignore */}
    // Atualiza o timestamp de salvamento no metadata, facilitando o controle
    if(!db._meta) db._meta = {};
    db._meta.savedAt = new Date().toISOString();
    const json = JSON.stringify(db);
    // usa grava√ß√£o segura no localStorage; em caso de falha lan√ßa exce√ß√£o para ser capturada
    if(!safeLocalSet("ERP_LUKAS_LOGIN_OK", json)){
      throw new Error('safeLocalSet failed');
    }
    // Atualiza o controle local com o timestamp salvo
    window.lastLoadedSavedAt = db._meta.savedAt;
    // Registrar um backup autom√°tico mantendo somente os mais recentes
    try{
      storeBackup();
    }catch(_){ /* backup falhou, mas n√£o impede o salvamento */ }
  }catch(e){
    console.error("Falha ao salvar no localStorage", e);
    // Evitar m√∫ltiplos toasts em cadeia se save() for chamado em loops
    try{ toast("Erro ao salvar dados no dispositivo. Considere baixar um backup em Salvar/Carregar.", "bad"); }catch(_e){}
  }

  // --- Sincroniza√ß√£o na nuvem (opt‚Äëin) ---
  try{
    if (window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableCloudSync && window.Update && Update.integrations && Update.integrations.serverSync) {
      const token = window.UPDATE_FLAGS.cloudToken || (db && db._meta && db._meta.cloudToken);
      if (token) {
        // Salva o banco atual no servidor, ignorando erros de rede silenciosamente
        Update.integrations.serverSync.saveCurrentToServer({ token }).catch(() => {});
      }
    }
  }catch(_syncErr){ /* ignore cloud sync errors */ }
}

// Armazena um backup autom√°tico do estado atual do banco de dados no
// localStorage. Mant√©m apenas os 20 backups mais recentes para evitar
// exceder a cota de armazenamento. Cada backup √© identificado por um
// carimbo de data/hora ISO.
function storeBackup(){
  try{
    // Leitura segura do localStorage. Se nada for encontrado, usamos array vazio.
    const backupsStr = safeLocalGet('ERP_LUKAS_BACKUPS', '[]');
    let backups = [];
    if(backupsStr){
      try{ backups = JSON.parse(backupsStr); }catch(e){ backups = []; }
    }
    const dataStr = JSON.stringify(db);
    const ts = new Date().toISOString();
    backups.push({ ts: ts, data: dataStr });
    if(backups.length > 20) backups = backups.slice(-20);
    safeLocalSet('ERP_LUKAS_BACKUPS', JSON.stringify(backups));
  }catch(e){
    console.warn('Falha ao armazenar backup autom√°tico', e);
  }
}

// Tenta restaurar o banco a partir do backup mais recente.  Retorna
// true se o backup foi restaurado com sucesso.  Caso contr√°rio,
// retorna false e n√£o altera o banco atual.
function restoreLatestBackup(){
  try{
    // Leitura segura do localStorage; retorna false se nada for encontrado
    const backupsStr = safeLocalGet('ERP_LUKAS_BACKUPS', null);
    if(!backupsStr) return false;
    const backups = JSON.parse(backupsStr);
    if(!Array.isArray(backups) || backups.length === 0) return false;
    const last = backups[backups.length - 1];
    if(!last || !last.data) return false;
    const obj = JSON.parse(last.data);
    db = normalizeDB(obj);
    // Ap√≥s restaurar, re-renderizar a interface para refletir o estado atual.
    try {
      if (typeof render === 'function') render(true);
    } catch (_e) {}
    return true;
  }catch(e){
    console.warn('Falha ao restaurar backup autom√°tico', e);
    return false;
  }
}

// Valida o banco de dados retornando uma lista de avisos.  N√£o
// corrige automaticamente os problemas, apenas informa.  Caso o
// array retornado esteja vazio, o banco est√° consistente.
function validateDB(d){
  const issues = [];
  if(!d || typeof d !== 'object') return ['Banco inv√°lido'];
  // Verificar estoque
  if(!Array.isArray(d.estoque)) issues.push('Estoque inv√°lido');
  else {
    const seen = new Set();
    d.estoque.forEach(p => {
      const cod = s(p.cod);
      if(isEmpty(cod)) issues.push('Produto sem c√≥digo');
      else if(seen.has(cod)) issues.push('C√≥digo duplicado: ' + cod);
      else seen.add(cod);
      if(isEmpty(p.nome)) issues.push(`Produto ${cod || '?'} sem nome`);
      // Quantidade deve ser num√©rica e n√£o negativa
      const qtdNum = Number(p.qtd);
      if(!Number.isFinite(qtdNum)) {
        issues.push(`Qtd inv√°lida em ${cod || '?'}`);
      } else if(qtdNum < 0) {
        issues.push(`Qtd negativa em ${cod || '?'}`);
      }
      // Pre√ßo de custo e pre√ßo de venda n√£o devem ser negativos
      const custo = Number(p.custo_c ?? p.custo ?? 0);
      const preco = Number(p.preco_c ?? p.preco ?? 0);
      if(Number.isFinite(custo) && custo < 0) issues.push(`Custo negativo em ${cod || '?'}`);
      if(Number.isFinite(preco) && preco < 0) issues.push(`Pre√ßo negativo em ${cod || '?'}`);
    });
  }
  return issues;
}
function load(){
  // Carrega os dados do localStorage envolvendo o acesso em try/catch.
  // Muitos navegadores podem bloquear o localStorage ou lan√ßar exce√ß√µes se
  // o usu√°rio estiver em modo privado ou se a quota estiver cheia. Ao
  // capturar a exce√ß√£o impedimos que a aplica√ß√£o quebre e permitimos ao
  // usu√°rio continuar operando com o banco em mem√≥ria. Caso algum dado
  // v√°lido seja encontrado, tentamos parse√°-lo.  Se o JSON estiver
  // corrompido, tentamos recuperar o √∫ltimo backup autom√°tico.
  let dataStr = null;
  try{
    dataStr = safeLocalGet("ERP_LUKAS_LOGIN_OK", null);
  }catch(err){
    console.warn("Erro ao acessar localStorage ao carregar dados:", err);
    dataStr = null;
  }
  if(dataStr){
    let parsed = null;
    try{
      parsed = JSON.parse(dataStr);
    }catch(err){
      console.error("Falha ao parsear JSON salvo no localStorage:", err);
      // Tentar restaurar backup quando o JSON est√° corrompido
      const ok = restoreLatestBackup();
      if(ok){
        save();
        try{ toast("Dados corrompidos recuperados do √∫ltimo backup.", "warn"); }catch(_e){}
        return;
      }
    }
    if(parsed){
      // Verificar problemas simples no banco.  Se houver problemas graves,
      // registramos no console mas ainda prosseguimos com a normaliza√ß√£o.
      const issues = validateDB(parsed);
      if(issues.length){
        console.warn("Avisos de consist√™ncia detectados ao carregar o banco:", issues);
      }
      db = parsed;
    // Ao carregar o banco, sincronizamos as configura√ß√µes de lucro e arredondamento com o metadata
    try{
      const meta = db && db._meta;
      if(meta){
        if(meta.profitMode === 'margin' || meta.profitMode === 'markup'){
          profitMode = meta.profitMode;
        }
        if(['none','0.99','0.90','integer'].includes(meta.profitRound)){
          profitRound = meta.profitRound;
        }
      }
    }catch(_e){}
    // Registrar o timestamp carregado para controle de vers√µes entre abas
    try{
      if(db && db._meta && db._meta.savedAt){
        window.lastLoadedSavedAt = db._meta.savedAt;
      }
    }catch(_e){}
    }
  }
}
load();

// ========== Permiss√µes e Auditoria ==========
// Defini√ß√µes de permiss√µes e utilidades de auditoria devem ser declaradas antes de
// normalizar o banco de dados, pois a normaliza√ß√£o atribui permiss√µes aos usu√°rios.
const DEFAULT_PERMISSIONS = {
  admin: {
    editCost: true,
    editPrice: true,
    deleteProduct: true,
    cancelSale: true,
    closeBox: true,
    exportImportBackup: true,
    manageUsers: true
  },
  operador: {
    editCost: false,
    editPrice: false,
    deleteProduct: false,
    cancelSale: false,
    closeBox: false,
    exportImportBackup: false,
    manageUsers: false
  },
  caixa: {
    editCost: false,
    editPrice: false,
    deleteProduct: false,
    cancelSale: false,
    closeBox: true,
    exportImportBackup: false,
    manageUsers: false
  },
  consulta: {
    editCost: false,
    editPrice: false,
    deleteProduct: false,
    cancelSale: false,
    closeBox: false,
    exportImportBackup: false,
    manageUsers: false
  }
};
// Assegura que um usu√°rio tenha um objeto de permiss√µes completo. Se `perms` for
// fornecido, mescla com os valores padr√£o do papel; caso contr√°rio usa o padr√£o.
function ensureUserPerms(role, perms) {
  const def = DEFAULT_PERMISSIONS[role] || {};
  const out = {};
  Object.keys(def).forEach(k => {
    out[k] = (perms && typeof perms[k] === 'boolean') ? perms[k] : def[k];
  });
  return out;
}
// Verifica se o usu√°rio atual possui uma permiss√£o espec√≠fica.
function hasPerm(action) {
  try {
    if (!currentUser) return false;
    const perms = currentUser.perms || {};
    return !!perms[action];
  } catch (e) {
    return false;
  }
}
// Adiciona uma entrada ao log de auditoria. Cada registro inclui o usu√°rio,
// a a√ß√£o, detalhes e um timestamp leg√≠vel.
function addAudit(action, details) {
  try {
    const entry = {
      user: currentUser && currentUser.user ? currentUser.user : 'sistema',
      action: String(action || ''),
      details: String(details || ''),
      time: nowDateTime()
    };
    if (!Array.isArray(db.audit)) db.audit = [];
    db.audit.push(entry);
    // Limita o tamanho do log para no m√°ximo 1000 entradas para evitar uso excessivo
    if (db.audit.length > 1000) db.audit = db.audit.slice(-1000);
    save();
  } catch (e) {
    console.warn('Falha ao registrar auditoria', e);
  }
}

/* =========================
   Migra√ß√£o / saneamento (centavos)
   ========================= */
function normalizeDB(d){
  if(!d || typeof d !== "object") d = {};

  d._meta = d._meta && typeof d._meta==="object" ? d._meta : {};
  if(!d._meta.schema) d._meta.schema = 1;
  // --- Novos campos no metadado ---
  // Definir dispositivo de scanner e impressora padr√£o caso n√£o existam.
  // O scanner pode ser "camera" (leitor via c√¢mera) ou "usb" (leitor tipo teclado).
  // A impressora pode ser "default" ou "thermal" para recibos em bobina.
  if(typeof d._meta.scanDevice === 'undefined') d._meta.scanDevice = 'camera';
  if(typeof d._meta.printerDevice === 'undefined') d._meta.printerDevice = 'default';

  d.usuarios = Array.isArray(d.usuarios) ? d.usuarios : [{user:"admin",pass:"123",role:"admin"}];
  d.empresa  = d.empresa && typeof d.empresa==="object" ? d.empresa : {nome:"",cnpj:"",contato:""};
  d.estoque  = Array.isArray(d.estoque) ? d.estoque : [];
  d.vendas   = Array.isArray(d.vendas) ? d.vendas : [];
  d.caixa    = Array.isArray(d.caixa) ? d.caixa : [];
  d.caixaAberto = !!d.caixaAberto;
  // --- Or√ßamentos ---
  // Garante que a lista de or√ßamentos exista. Cada or√ßamento cont√©m informa√ß√µes
  // sobre cliente, itens, datas e estado (pendente/aprovado).
  d.orcamentos = Array.isArray(d.orcamentos) ? d.orcamentos : [];
  /* garantir que agenda, devedores, notas e tarefas sejam arrays */
  d.agenda   = Array.isArray(d.agenda) ? d.agenda : [];
  d.devedores= Array.isArray(d.devedores) ? d.devedores : [];
  d.notes    = Array.isArray(d.notes) ? d.notes : [];
  d.todos    = Array.isArray(d.todos) ? d.todos : [];

  // Logs de auditoria
  d.audit    = Array.isArray(d.audit) ? d.audit : [];

  d.empresa.nome = s(d.empresa.nome);
  d.empresa.cnpj = s(d.empresa.cnpj);
  d.empresa.contato = s(d.empresa.contato);
  // Campos adicionais de empresa adicionados: endere√ßo, celular e e-mail.
  d.empresa.endereco = s(d.empresa.endereco);
  d.empresa.celular = s(d.empresa.celular);
  d.empresa.email = s(d.empresa.email);

  d.usuarios = d.usuarios.map(u=>{
    const nu = {...u};
    nu.user = s(nu.user);
    nu.pass = s(nu.pass);
    // Mapear pap√©is antigos para os novos pap√©is suportados
    let r = s(nu.role).toLowerCase();
    if(!r || r === 'funcionario') r = 'consulta';
    else if(r === 'gerente') r = 'operador';
    else if(!['admin','operador','caixa','consulta'].includes(r)) r = 'consulta';
    nu.role = r;
    nu.owner = s(nu.owner) || "admin";
    if(typeof nu.ativo !== "boolean") nu.ativo = true;
    nu.criadoEm = s(nu.criadoEm) || nowDateTime();
    // Garante que cada usu√°rio tenha um conjunto de permiss√µes completo
    nu.perms = ensureUserPerms(nu.role, u.perms);
    return nu;
  });

  d.estoque = d.estoque.map(p=>{
    const np = {...p};
    np.cod = s(np.cod);
    np.nome = s(np.nome);
    np.qtd = Number.isFinite(Number(np.qtd)) ? Math.max(0, Math.floor(Number(np.qtd))) : 0;
    np.min = Number.isFinite(Number(np.min)) ? Math.max(0, Math.floor(Number(np.min))) : 0;
    np.custo_c = moneyOf(np, "custo_c", "custo");
    np.preco_c = moneyOf(np, "preco_c", "preco");
    // Garantir que custo e pre√ßo n√£o sejam negativos. Caso valores
    // negativos sejam importados por engano (ex.: erro de digita√ß√£o
    // ou corrup√ß√£o), normalizamos para zero. Isso preserva a
    // consist√™ncia sem alterar o comportamento de produtos v√°lidos.
    if (!Number.isFinite(np.custo_c) || np.custo_c < 0) np.custo_c = 0;
    if (!Number.isFinite(np.preco_c) || np.preco_c < 0) np.preco_c = 0;
    return np;
  });

  d.vendas = d.vendas.map(v=>{
    const nv = {...v};
    nv.id = Number.isFinite(Number(nv.id)) ? Number(nv.id) : makeId();
    nv.data = s(nv.data) || nowDateTime();
    nv.cod = s(nv.cod);
    nv.nome = s(nv.nome);
    nv.qtd = Number.isFinite(Number(nv.qtd)) ? Math.max(0, Math.floor(Number(nv.qtd))) : 0;
    nv.pag = s(nv.pag) || "dinheiro";
    nv.cancelada = !!nv.cancelada;
    nv.groupId = s(nv.groupId);
    nv.servico_c = moneyOf(nv, "servico_c", "servico");
    nv.total_c   = moneyOf(nv, "total_c", "total");
    nv.lucro_c   = moneyOf(nv, "lucro_c", "lucro");
    if(!Number.isFinite(nv.servico_c)) nv.servico_c = 0;
    if(!Number.isFinite(nv.total_c)) nv.total_c = 0;
    if(!Number.isFinite(nv.lucro_c)) nv.lucro_c = 0;
    return nv;
  });

  d.caixa = d.caixa.map(m=>{
    const nm = { ...m };
    nm.data = s(nm.data) || nowDateTime();
    nm.desc = s(nm.desc);
    nm.tipo = s(nm.tipo) || "entrada";
    nm.pag = s(nm.pag) || "dinheiro";
    nm.categoria = s(nm.categoria);
    nm.obs = s(nm.obs);
    nm.groupId = s(nm.groupId);
    nm.vendaId = nm.vendaId ?? nm.vendaID;
    nm.valor_c = moneyOf(nm, "valor_c", "valor");
    if(!Number.isFinite(nm.valor_c)) nm.valor_c = 0;
    // Garantir consist√™ncia do sinal: entradas positivas, sa√≠das negativas
    if(nm.tipo === "saida" && nm.valor_c > 0) nm.valor_c = -Math.abs(nm.valor_c);
    if(nm.tipo === "entrada" && nm.valor_c < 0) nm.valor_c = Math.abs(nm.valor_c);
    // Normalizar ID (string) e respons√°vel
    if(typeof nm.id === 'undefined' || nm.id === null || nm.id === ''){
      nm.id = makeId();
    }
    nm.id = String(nm.id);
    nm.responsavel = s(nm.responsavel);
    return nm;
  });

  /* saneamento da agenda */
  d.agenda = d.agenda.map(ev=>{
    const nev = {...ev};
    nev.id = Number.isFinite(Number(nev.id)) ? Number(nev.id) : makeId();
    nev.titulo = s(nev.titulo);
    nev.desc = s(nev.desc);
    // armazenamos datas em formato ISO ou string leg√≠vel
    nev.data = s(nev.data);
    return nev;
  });

  /* saneamento dos devedores */
  d.devedores = d.devedores.map(dv=>{
    const nd = {...dv};
    nd.id = Number.isFinite(Number(nd.id)) ? Number(nd.id) : makeId();
    nd.nome = s(nd.nome);
    nd.valor_c = moneyOf(nd,"valor_c","valor");
    if(!Number.isFinite(nd.valor_c)) nd.valor_c = 0;
    nd.data = s(nd.data);
    nd.desc = s(nd.desc);
    nd.pago = !!nd.pago;
    nd.pagoEm = s(nd.pagoEm);
    return nd;
  });

  /* saneamento de notas */
  d.notes = d.notes.map(note=>{
    const nn = {...note};
    nn.id = Number.isFinite(Number(nn.id)) ? Number(nn.id) : makeId();
    nn.text = s(nn.text);
    return nn;
  });

  /* saneamento de tarefas */
  d.todos = d.todos.map(todo=>{
    const nt = {...todo};
    nt.id = Number.isFinite(Number(nt.id)) ? Number(nt.id) : makeId();
    nt.text = s(nt.text);
    nt.done = !!nt.done;
    return nt;
  });

  // saneamento das despesas mensais
  // Cada despesa deve possuir um nome (string) e valor em centavos (valor_c).
  // Caso o valor venha em reais (campo "valor"), convertemos utilizando moneyOf().
  d.despesas = Array.isArray(d.despesas) ? d.despesas.map(item => {
    const di = {...item};
    di.nome = s(di.nome);
    di.valor_c = moneyOf(di, 'valor_c', 'valor');
    if(!Number.isFinite(di.valor_c)) di.valor_c = 0;
    // garante que cada despesa tenha um tipo definido (fixa ou variavel)
    // se nenhuma informa√ß√£o for fornecida, assume como fixa
    const t = s(di.tipo).toLowerCase();
    di.tipo = (t === 'variavel' || t === 'fixa') ? t : 'fixa';
    return di;
  }) : [];

  d._meta.moneyMode = "cents";
  d._meta.schema = Math.max(2, Number(d._meta.schema)||2);
  d._meta.savedAt = s(d._meta.savedAt) || new Date().toISOString();
  // Configura√ß√µes padr√£o de lucro e arredondamento, se ainda n√£o definidas. Usamos 'markup' e 'none' como padr√µes.
  if(!d._meta.profitMode || (d._meta.profitMode !== 'markup' && d._meta.profitMode !== 'margin')){
    d._meta.profitMode = 'markup';
  }
  if(!['none','0.99','0.90','integer'].includes(d._meta.profitRound)){
    d._meta.profitRound = 'none';
  }
  // Prefer√™ncias padr√£o: scanner, or√ßamento e m√£o de obra habilitados
  if(typeof d._meta.scannerEnabled === 'undefined') d._meta.scannerEnabled = true;
  if(typeof d._meta.orcamentoEnabled === 'undefined') d._meta.orcamentoEnabled = true;
  if(typeof d._meta.maoObraEnabled === 'undefined') d._meta.maoObraEnabled = true;
  return d;
}

db = normalizeDB(db);
save();

let currentUser = null;

//=== Alert tracking (agenda e devedores) ===
// Conjuntos para armazenar quais itens de agenda ou devedores j√° geraram
// alerta recentemente. Isso evita toasts duplicados em cada intervalo de
// verifica√ß√£o (setInterval). Cada ID √© removido quando o evento sai da
// janela de alerta para permitir novos avisos futuros.
const agendaAlertNotified = new Set();
const devedorAlertNotified = new Set();

// Atalhos globais de teclado para melhorar a produtividade.  Permite
// focar a busca de estoque pressionando '/', e limpar com ESC.
document.addEventListener('keydown', (e) => {
  // Ignorar se o foco estiver em um campo de entrada ou textarea que n√£o
  // seja a pr√≥pria busca de estoque, para n√£o interferir em digita√ß√£o
  const active = document.activeElement;
  const tag = active && active.tagName;
  if(tag && ['INPUT','TEXTAREA'].includes(tag) && active.id !== 'estoqueSearch') return;
  // Atalho '/' foca a busca do estoque
  if(e.key === '/' && !e.ctrlKey && !e.altKey && !e.metaKey){
    const el = $("estoqueSearch");
    if(el){
      e.preventDefault();
      el.focus();
      try{ el.select(); }catch(_e){}
    }
    return;
  }
  // ESC limpa a busca e remove o foco
  if(e.key === 'Escape'){
    const el = $("estoqueSearch");
    if(el && document.activeElement === el){
      clearEstoqueSearch();
      el.blur();
    }
  }
});

// Armazena a √∫ltima se√ß√£o visitada dentro do sistema (para voltar ao sair do scanner)
let lastSection = 'dashboard';
// Controla a exibi√ß√£o da porcentagem de lucro na tabela de estoque. Quando true, exibe "(xx,xx%)" ao lado do valor de lucro.
let showLucroPct = false;

// Modo de c√°lculo da porcentagem de lucro: 'markup' para markup sobre o custo ou 'margin' para margem sobre o pre√ßo.
// Estes valores s√£o persistidos em db._meta para que sobrevivam a recarregamentos.
let profitMode = 'markup';
// Forma de arredondar o pre√ßo calculado: 'none' (sem arredondamento), '0.99' (terminar em 0,99),
// '0.90' (terminar em 0,90) ou 'integer' (valor inteiro). Tamb√©m √© persistido em db._meta.
let profitRound = 'none';
/* ========== Permiss√µes e Auditoria ========== */
// As defini√ß√µes de permiss√µes e auditoria foram movidas para antes da
// fun√ß√£o de normaliza√ß√£o do banco de dados, garantindo que estejam
// dispon√≠veis quando ``normalizeDB`` for executada. Este espa√ßo √©
// mantido apenas para refer√™ncia e n√£o cont√©m c√≥digo execut√°vel.
// Vari√°veis para edi√ß√£o de usu√°rios e controle de sess√£o
let editingUserIndex = null;
let lastActivity = Date.now();
// Sess√£o expira ap√≥s um per√≠odo de inatividade. O valor padr√£o √© lido do localStorage.
let sessionTimeoutMin = 30;
function applySessionTimeoutFromStorage(){
  try{
    const v = parseInt(safeLocalGet('erp_session_timeout_min', '') || '', 10);
    if(Number.isFinite(v) && v > 0){
      sessionTimeoutMin = v;
    }
  }catch(e){}
}
function setSessionTimeout(mins){
  mins = parseInt(mins, 10);
  if(!Number.isFinite(mins) || mins <= 0) return;
  sessionTimeoutMin = mins;
  try{ safeLocalSet('erp_session_timeout_min', String(mins)); }catch(e){}
  toast('Tempo de sess√£o atualizado!', 'ok');
}
function startSessionWatcher(){
  // Checar a cada minuto se a sess√£o expirou
  setInterval(()=>{
    try{
      if(!currentUser) return;
      const diffMin = (Date.now() - lastActivity) / 60000;
      if(diffMin >= sessionTimeoutMin){
        toast('Sess√£o expirada por inatividade.', 'warn');
        logout();
      }
    }catch(_){}
  }, 60000);
}
// Atualiza lastActivity em eventos de intera√ß√£o do usu√°rio
['click','keydown','mousemove','touchstart'].forEach(evt=>{
  document.addEventListener(evt, ()=>{ lastActivity = Date.now(); }, true);
});
// Inicializa configura√ß√µes de sess√£o no carregamento
applySessionTimeoutFromStorage();
startSessionWatcher();

// ========== Configura√ß√µes de Tentativas de Login e Acessibilidade ==========
// N√∫mero m√°ximo de tentativas de login antes de bloquear temporariamente.
// O valor padr√£o √© 5, podendo ser alterado via Ajustes > Seguran√ßa.
let loginAttemptLimit = 5;

// Carrega o limite de tentativas salvo no localStorage. Se um valor v√°lido
// existir em ``erp_login_attempt_limit``, substitui o padr√£o.
function applyLoginAttemptLimitFromStorage(){
  try{
    const v = parseInt(safeLocalGet('erp_login_attempt_limit','') || '', 10);
    if(Number.isFinite(v) && v > 0){
      loginAttemptLimit = v;
    }
  }catch(e){}
}

// Atualiza o limite de tentativas e persiste no localStorage.
function setLoginAttemptLimit(val){
  val = parseInt(val,10);
  if(!Number.isFinite(val) || val <= 0) return;
  loginAttemptLimit = val;
  try{ safeLocalSet('erp_login_attempt_limit', String(val)); }catch(e){}
  toast('Limite de tentativas atualizado!', 'ok');
}

// Aplica a prefer√™ncia de fonte grande a partir do localStorage.  Se
// ``erp_large_font`` estiver definido como ``"1"``, adiciona a classe
// ``large-font`` ao ``body``.
function applyLargeFontFromStorage(){
  try{
    const v = safeLocalGet('erp_large_font','0');
    if(v === '1'){
      document.body.classList.add('large-font');
    }
  }catch(e){}
}

// Alterna o modo de fonte grande.  Adiciona ou remove a classe
// ``large-font`` do ``body`` e grava a prefer√™ncia no localStorage.
function toggleLargeFont(){
  const b = document.body;
  b.classList.toggle('large-font');
  try{
    safeLocalSet('erp_large_font', b.classList.contains('large-font') ? '1' : '0');
  }catch(e){}
}

// Atualiza o tempo de sess√£o a partir do campo de entrada da tela de Seguran√ßa.
// O valor √© passado para ``setSessionTimeout``. Se o campo n√£o existir ou
// estiver vazio, nada acontece.
function updateSessionTimeout(){
  const inp = document.getElementById('input_session_timeout');
  if(!inp) return;
  const val = parseInt(inp.value, 10);
  if(!Number.isFinite(val) || val <= 0){
    toast('Informe um valor de minutos v√°lido.', 'warn');
    return;
  }
  setSessionTimeout(val);
}

// Atualiza o limite de tentativas de login a partir do campo de entrada da
// tela de Seguran√ßa. Usa ``setLoginAttemptLimit`` para persistir o valor.
function updateLoginAttemptLimit(){
  const inp = document.getElementById('input_login_attempts');
  if(!inp) return;
  const val = parseInt(inp.value, 10);
  if(!Number.isFinite(val) || val <= 0){
    toast('Informe um limite de tentativas v√°lido.', 'warn');
    return;
  }
  setLoginAttemptLimit(val);
}

// Gera a tabela do log de auditoria dentro da div ``auditLogBody``.
function renderAuditLog(){
  const container = document.getElementById('auditLogBody');
  if(!container) return;
  container.innerHTML = '';
  (db.audit || []).forEach(entry => {
    const tr = document.createElement('tr');
    const tdTime = document.createElement('td');
    tdTime.textContent = entry.time || '';
    const tdUser = document.createElement('td');
    tdUser.textContent = entry.user || '';
    const tdAction = document.createElement('td');
    tdAction.textContent = entry.action || '';
    const tdDetails = document.createElement('td');
    tdDetails.textContent = entry.details || '';
    tr.appendChild(tdTime);
    tr.appendChild(tdUser);
    tr.appendChild(tdAction);
    tr.appendChild(tdDetails);
    container.appendChild(tr);
  });
}

// Alterna a visualiza√ß√£o do log de auditoria. Ao abrir, chama
// ``renderAuditLog`` para preencher a tabela.
function toggleAuditLog(){
  const card = document.getElementById('auditLogCard');
  if(!card) return;
  if(card.style.display === 'none' || card.style.display === ''){
    renderAuditLog();
    card.style.display = 'block';
  }else{
    card.style.display = 'none';
  }
}

// Limpa todos os registros do log de auditoria ap√≥s confirma√ß√£o do usu√°rio.
function clearAuditLog(){
  if(!confirm('Tem certeza que deseja limpar todos os registros de auditoria?')) return;
  db.audit = [];
  save();
  renderAuditLog();
  toast('Log de auditoria limpo!', 'ok');
}

// Executa um diagn√≥stico b√°sico no banco de dados usando a fun√ß√£o
// ``validateDB``. Exibe os avisos retornados em uma lista ou informa
// que nenhum problema foi encontrado. √ötil para manuten√ß√£o preventiva.
function runDiagnostic(){
  try{
    const outDiv = document.getElementById('diag_result');
    if(!outDiv) return;
    const issues = validateDB(db);
    if(!issues || issues.length === 0){
      outDiv.innerHTML = '<span style="color:' + getComputedStyle(document.documentElement).getPropertyValue('--ok') + '">Nenhum problema encontrado.</span>';
    }else{
      const ul = document.createElement('ul');
      ul.style.margin = '0';
      ul.style.paddingLeft = '18px';
      issues.forEach(msg => {
        const li = document.createElement('li');
        li.textContent = msg;
        ul.appendChild(li);
      });
      outDiv.innerHTML = '';
      outDiv.appendChild(ul);
    }
  }catch(e){
    console.warn('runDiagnostic error', e);
    toast('Falha ao executar diagn√≥stico.', 'bad');
  }
}

// Inicializar limites de login e prefer√™ncia de fonte ao carregar.
applyLoginAttemptLimitFromStorage();
applyLargeFontFromStorage();

/* ========== Restri√ß√µes por perfil ========== */
function limparRestricoesVisuais(){
  document.querySelectorAll("nav button").forEach(btn => btn.style.display = "");
  const secUsuarios = $("usuarios");
  const secPerfil = $("perfil");
  if(secUsuarios) secUsuarios.style.display = "";
  if(secPerfil) secPerfil.style.display = "";
}
function aplicarRestricoesPorPerfil(){
  if(!currentUser) return;
  // Oculta se√ß√µes e bot√µes sens√≠veis conforme permiss√µes. Usu√°rios sem permiss√£o de
  // gerenciar usu√°rios n√£o devem ver a tela de usu√°rios.
  document.querySelectorAll("nav button").forEach(btn=>{
    const txt = (btn.textContent || "").toLowerCase();
    if(txt.includes("usu√°rios")){
      btn.style.display = hasPerm('manageUsers') ? "" : "none";
    }
  });
  // Al√©m do menu principal, oculta a op√ß√£o "Usu√°rios" dentro do menu de Ajustes.
  const cfgBtn = document.getElementById('btnCfg_usuarios');
  if(cfgBtn){
    cfgBtn.style.display = hasPerm('manageUsers') ? '' : 'none';
  }
  const secUsuarios = $("usuarios");
  if(secUsuarios){
    secUsuarios.style.display = hasPerm('manageUsers') ? "" : "none";
  }
  const active = document.querySelector("#systemSection section.active");
  if(active && active.id === "usuarios" && !hasPerm('manageUsers')){
    show("dashboard");
  }
}

/* ========== Login / Navega√ß√£o ========== */
function doLogin(){
  const u = s($("l_user")?.value);
  const p = s($("l_pass")?.value);
  const t = s($("l_token")?.value);
  if(isEmpty(u) || isEmpty(p)){
    toast("Preencha usu√°rio e senha.", "warn");
    return;
  }
  // Verificar bloqueio por m√∫ltiplas tentativas falhas
  // utiliza acesso seguro ao armazenamento para o contador de bloqueio
  const lockedUntil = Number(safeLocalGet('erp_login_locked_until', 0) || 0);
  const now = Date.now();
  if(now < lockedUntil){
    const remaining = Math.ceil((lockedUntil - now) / 1000);
    toast(`Muitas tentativas falhas. Aguarde ${remaining}s e tente novamente.`, 'bad');
    return;
  }
  const usr = (db.usuarios || []).find(x => s(x.user) === u && s(x.pass) === p);
  if(!usr){
    // Incrementar contador de tentativas
    let attempts = Number(safeLocalGet('erp_login_attempts', 0) || 0);
    attempts++;
    if(attempts >= loginAttemptLimit){
      // Bloqueia o login por 30 segundos ap√≥s exceder o limite configurado.
      safeLocalSet('erp_login_locked_until', String(now + 30000));
      safeLocalSet('erp_login_attempts', '0');
      toast('Muitas tentativas falhas. Login bloqueado por 30s.', 'bad');
      return;
    }
    safeLocalSet('erp_login_attempts', String(attempts));
    toast('Usu√°rio ou senha inv√°lidos.', 'bad');
    return;
  }
  // Login bem-sucedido: limpar contadores de falha
  safeLocalRemove('erp_login_attempts');
  safeLocalRemove('erp_login_locked_until');
  currentUser = usr;
  // Se um token opcional foi fornecido, validar e aplicar no contexto de cloud sync.
  if(t){
    // Validar formato do token (somente letras, n√∫meros, h√≠fen ou sublinhado)
    const okToken = /^[A-Za-z0-9_-]+$/.test(t);
    if(!okToken){
      toast("Token inv√°lido.", "bad");
      return;
    }
    try{
      // Configurar sinalizadores de sincroniza√ß√£o em nuvem
      window.UPDATE_FLAGS = window.UPDATE_FLAGS || {};
      window.UPDATE_FLAGS.enableCloudSync = true;
      window.UPDATE_FLAGS.cloudToken = t;
      // Persistir o token no metadata do banco para sincroniza√ß√£o futura
      if(window.db){
        window.db._meta = window.db._meta || {};
        window.db._meta.cloudToken = t;
      }
    }catch(_e){}
    // Se o m√≥dulo tenant-auth exportou as fun√ß√µes, sobrescreve os bot√µes do servidor
    if(typeof window.overrideServerButtons === 'function'){
      try{ window.overrideServerButtons(t); }catch(_e){}
    }
  }
  $("loginSection").style.display = "none";
  $("systemSection").style.display = "block";
  aplicarRestricoesPorPerfil();
  show("dashboard");
  render(true);
  toast("Login efetuado com sucesso!", "ok");
}
function logout(){
  currentUser = null;
  limparRestricoesVisuais();
  $("systemSection").style.display = "none";
  $("loginSection").style.display = "block";
  toast("Voc√™ saiu do sistema.", "warn");
}
function show(id){
  // Registrar a se√ß√£o como √∫ltima visitada (exceto quando abrindo o scanner)
  if(id && id !== 'scanner'){
    lastSection = id;
  }
  // Alternar entre o sistema e o m√≥dulo de scanner/PDV
  const system = $("systemSection");
  const scannerSection = $("scanner");
  if(id === 'scanner'){
    // Ocultar o sistema e mostrar o m√≥dulo scanner
    if(system) system.style.display = 'none';
    if(scannerSection) scannerSection.style.display = 'block';
    // Ajustar campos conforme perfil e atualizar bot√£o
    try{
      if(typeof scanRenderProfile === 'function') scanRenderProfile();
      if(typeof updateScanButton === 'function') updateScanButton();
    }catch(e){}
    return;
  }
  // Caso contr√°rio, mostrar o sistema e ocultar o scanner
  if(system) system.style.display = 'block';
  if(scannerSection) scannerSection.style.display = 'none';
  // Atualizar a se√ß√£o ativa interna
  document.querySelectorAll("#systemSection section").forEach(sec=>sec.classList.remove("active"));
  const el = $(id);
  if(el){
    el.classList.add("active");
    // Ap√≥s ativar uma se√ß√£o, role a p√°gina para o topo para melhorar a
    // usabilidade, especialmente em dispositivos m√≥veis. Tenta usar scroll
    // suave e recai para scroll instant√¢neo caso n√£o esteja dispon√≠vel.
    try{
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }catch(e){
      window.scrollTo(0,0);
    }

    // Sincronizar sele√ß√£o da barra inferior no modo smartphone.  A cada
    // mudan√ßa de se√ß√£o, remova o destaque "active" de todos os bot√µes
    // do bottomNav e aplique no bot√£o correspondente ao id atual.
    const bottom = document.getElementById('bottomNav');
    if(bottom){
      bottom.querySelectorAll('button').forEach(btn => {
        btn.classList.remove('active');
        const attr = btn.getAttribute('onclick') || '';
        if(attr.includes(`show('${id}')`)){
          btn.classList.add('active');
        }
      });
    }

    // Quando a se√ß√£o de vendas √© ativada, focar automaticamente no campo de busca/c√≥digo
    // correspondente ao modo atual (rapida ou completa). Isso agiliza a opera√ß√£o do vendedor.
    if(id === 'vendas'){
      setTimeout(() => {
        try {
          if (typeof salesMode !== 'undefined' && salesMode === 'rapida') {
            const vb = document.getElementById('v_busca');
            if (vb) vb.focus();
          } else {
            const cb = document.getElementById('c_busca');
            if (cb) cb.focus();
          }
        } catch(_e){}
      }, 50);
    }
  }else{
    const dash = $("dashboard");
    if(dash) {
      dash.classList.add("active");
      try{ window.scrollTo({ top: 0, behavior:'smooth' }); }catch(e){ window.scrollTo(0,0); }
    }
  }
  aplicarRestricoesPorPerfil();
}

/* ========== Usu√°rios ========== */
function hasUser(user){
  user = s(user);
  return (db.usuarios || []).some(u => s(u.user).toLowerCase() === user.toLowerCase());
}
function addUser(){
  if(!currentUser || !hasPerm('manageUsers')){ toast("Somente admin.", "bad"); return; }
  // Sanitizar entradas antes de uso para evitar espa√ßos estranhos
  const user = sanitizeInputString(s($("u_user")?.value));
  const pass = sanitizeInputString(s($("u_pass")?.value));
  const role = sanitizeInputString(s($("u_role")?.value));
  if(isEmpty(user) || isEmpty(pass) || isEmpty(role)){ toast("Preencha usu√°rio, senha e perfil.", "warn"); return; }
  if(hasUser(user)){ toast("Esse usu√°rio j√° existe.", "bad"); return; }

  const perms = ensureUserPerms(role, null);
  db.usuarios.push({ user, pass, role, owner:s(currentUser.user)||"admin", ativo:true, criadoEm: nowDateTime(), perms });
  save(); render(true);
  // Registrar auditoria de cria√ß√£o de usu√°rio
  addAudit('createUser', 'Criou usu√°rio ' + user);
  if($("u_user")) $("u_user").value = "";
  if($("u_pass")) $("u_pass").value = "";
  toast('Usu√°rio criado!', 'ok');
}

// ==== Fun√ß√µes de gerenciamento de usu√°rios ====
function editUser(username){
  if(!hasPerm('manageUsers')){ toast('Sem permiss√£o.', 'bad'); return; }
  const idx = (db.usuarios || []).findIndex(u => s(u.user) === s(username));
  if(idx < 0){ toast('Usu√°rio n√£o encontrado.', 'bad'); return; }
  editingUserIndex = idx;
  const usr = db.usuarios[idx];
  const card = $('editUserCard');
  if(card) card.style.display = 'block';
  if($('edit_username')) $('edit_username').value = usr.user;
  if($('edit_role')) $('edit_role').value = usr.role;
  if($('edit_active')) $('edit_active').checked = !!usr.ativo;
  const perms = ensureUserPerms(usr.role, usr.perms);
  Object.keys(DEFAULT_PERMISSIONS.admin).forEach(k=>{
    const cb = $('perm_' + k);
    if(cb){ cb.checked = !!perms[k]; }
  });
}

function saveUserEdit(){
  if(editingUserIndex === null){ return; }
  const usr = db.usuarios[editingUserIndex];
  const rSel = $('edit_role') ? $('edit_role').value : usr.role;
  usr.role = rSel;
  usr.ativo = $('edit_active') ? !!$('edit_active').checked : true;
  const perms = {};
  Object.keys(DEFAULT_PERMISSIONS.admin).forEach(k=>{
    const cb = $('perm_' + k);
    perms[k] = cb ? !!cb.checked : DEFAULT_PERMISSIONS[usr.role][k];
  });
  usr.perms = ensureUserPerms(usr.role, perms);
  save();
  addAudit('editUser', 'Editou usu√°rio ' + usr.user);
  editingUserIndex = null;
  if($('editUserCard')) $('editUserCard').style.display = 'none';
  render(true);
  toast('Usu√°rio atualizado!', 'ok');
}

function cancelUserEdit(){
  editingUserIndex = null;
  const card = $('editUserCard');
  if(card) card.style.display = 'none';
}

function toggleUserActive(username){
  if(!hasPerm('manageUsers')){ toast('Sem permiss√£o.', 'bad'); return; }
  const u = (db.usuarios || []).find(x => s(x.user) === s(username));
  if(!u){ toast('Usu√°rio n√£o encontrado.', 'bad'); return; }
  u.ativo = !u.ativo;
  save();
  addAudit('toggleUser', (u.ativo ? 'Ativou' : 'Desativou') + ' usu√°rio ' + u.user);
  render(true);
}

function resetUserPass(username){
  if(!hasPerm('manageUsers')){ toast('Sem permiss√£o.', 'bad'); return; }
  const u = (db.usuarios || []).find(x => s(x.user) === s(username));
  if(!u){ toast('Usu√°rio n√£o encontrado.', 'bad'); return; }
  const newPass = prompt('Digite a nova senha para ' + u.user, '');
  if(newPass === null) return;
  const trimmed = sanitizeInputString(newPass);
  if(trimmed.length === 0){ toast('Senha n√£o alterada.', 'warn'); return; }
  u.pass = trimmed;
  save();
  addAudit('resetUserPass', 'Resetou senha de ' + u.user);
  toast('Senha redefinida!', 'ok');
}

/* ========== Estoque (Edi√ß√£o) ========== */
let estoqueEditMode = false;
let estoqueEditOldCod = "";

function setEstoqueModeUI(){
  const info = $("estoqueModeInfo");
  const btnCancelar = $("btnCancelarEdicao");
  const btnSalvar = $("btnSalvarProduto");
  if(estoqueEditMode){
    if(info) info.innerHTML = `<span class="badge">MODO EDI√á√ÉO</span> Editando produto: <b>${escapeHTML(estoqueEditOldCod)}</b>`;
    if(btnCancelar) btnCancelar.style.display = "inline-block";
    if(btnSalvar) btnSalvar.textContent = "Salvar Altera√ß√µes";
  }else{
    // Em modo normal, n√£o exibe mensagem fixa; a interface permanece limpa
    if(info) info.textContent = "";
    if(btnCancelar) btnCancelar.style.display = "none";
    if(btnSalvar) btnSalvar.textContent = "Salvar Produto";
  }
}
function startEditProduto(cod){
  // Verificar permiss√£o para excluir produto
  if(!hasPerm('deleteProduct')){
    toast('Sem permiss√£o para apagar produtos.', 'bad');
    return;
  }
  cod = s(cod);
  const p = (db.estoque || []).find(x => s(x.cod) === cod);
  if(!p){ toast("Produto n√£o encontrado.", "bad"); return; }

  estoqueEditMode = true;
  estoqueEditOldCod = cod;

  $("e_cod").value = p.cod;
  $("e_nome").value = p.nome;
  $("e_qtd").value = p.qtd;
  $("e_min").value = p.min;
  $("e_custo").value = centsToBR(p.custo_c);
  $("e_preco").value = centsToBR(p.preco_c);
  // Preenche o campo de porcentagem de lucro com o valor salvo ou calcula com base no custo e pre√ßo
  if($("e_lucro")){
    if(typeof p.lucro_p !== "undefined"){
      $("e_lucro").value = String(p.lucro_p);
    }else{
      // calcula a porcentagem de lucro com base no custo e pre√ßo
      if(p.custo_c > 0){
        const pct = ((p.preco_c - p.custo_c) / p.custo_c) * 100;
        $("e_lucro").value = pct.toFixed(2);
      }else{
        $("e_lucro").value = "";
      }
    }
  }

  setEstoqueModeUI();
  toast("Modo edi√ß√£o ativado.", "ok");
  $("e_cod")?.focus();
}
function cancelEditProduto(skipToast = false){
  // Sai do modo de edi√ß√£o de estoque. Quando skipToast √© true, n√£o exibe
  // a notifica√ß√£o de edi√ß√£o cancelada (utilizado ap√≥s salvar altera√ß√µes).
  estoqueEditMode = false;
  estoqueEditOldCod = "";
  ["e_cod","e_nome","e_qtd","e_min","e_custo","e_preco"].forEach(id => {
    if($(id)) $(id).value = "";
  });
  setEstoqueModeUI();
  if(!skipToast) toast("Edi√ß√£o cancelada.", "warn");
}

// Calcula o pre√ßo de venda com base no custo e na porcentagem de lucro informada no campo #e_lucro.
// Quando e_custo ou e_lucro s√£o alterados, este m√©todo atualiza o campo #e_preco.
function calcPrecoFromLucro(){
  const inpCusto = $("e_custo");
  const inpLucro = $("e_lucro");
  const inpPreco = $("e_preco");
  if(!inpCusto || !inpLucro || !inpPreco) return;
  const custo_c = parseMoneyToCents(inpCusto.value);
  // aceitar v√≠rgulas ou pontos no valor de lucro
  const lucro_raw = parseFloat(String(inpLucro.value).replace(",", "."));
  if(!Number.isFinite(lucro_raw) || lucro_raw < 0) return;
  // Apenas calcula se o custo for v√°lido
  if(custo_c >= 0){
    let preco_c = 0;
    if(profitMode === 'margin'){
      // margem: lucro em rela√ß√£o ao pre√ßo. Evitar divis√£o por zero se margem >= 100%
      const margin = lucro_raw / 100;
      if(margin >= 1){
        preco_c = custo_c;
      }else{
        preco_c = Math.round(custo_c / (1 - margin));
      }
    }else{
      // markup: lucro sobre o custo
      preco_c = Math.round(custo_c * (1 + (lucro_raw/100)));
    }
    // Aplicar arredondamento conforme configurado
    preco_c = applyProfitRounding(preco_c);
    inpPreco.value = centsToBR(preco_c);
  }
}

// Calcula a porcentagem de lucro com base nos campos de custo e pre√ßo.
// Quando o campo #e_preco √© alterado manualmente, atualiza o campo #e_lucro.
function calcLucroFromPreco(){
  const inpCusto = $("e_custo");
  const inpLucro = $("e_lucro");
  const inpPreco = $("e_preco");
  if(!inpCusto || !inpLucro || !inpPreco) return;
  const custo_c = parseMoneyToCents(inpCusto.value);
  const preco_c = parseMoneyToCents(inpPreco.value);
  if(custo_c <= 0 || preco_c <= 0) return;
  let lucroPct = 0;
  if(profitMode === 'margin'){
    // margem: lucro / pre√ßo
    lucroPct = ((preco_c - custo_c) / preco_c) * 100;
  }else{
    // markup: lucro / custo
    lucroPct = ((preco_c - custo_c) / custo_c) * 100;
  }
  // Define com duas casas decimais
  inpLucro.value = lucroPct.toFixed(2);
}

// Alterna a flag de exibi√ß√£o da porcentagem de lucro na tabela de estoque.
// Atualiza o texto do bot√£o e renderiza novamente a tabela.
function toggleLucroPct(){
  showLucroPct = !showLucroPct;
  const btn = $("btnToggleLucroPct");
  if(btn){
    btn.textContent = showLucroPct ? "Desativar visualiza√ß√£o de %" : "Ativar visualiza√ß√£o de %";
  }
  render(true);
}
// Define o modo de c√°lculo de lucro (markup ou margem) e persiste no metadata.
function setProfitMode(val){
  const newMode = (val === 'margin') ? 'margin' : 'markup';
  if(profitMode !== newMode){
    profitMode = newMode;
    if(!db._meta) db._meta = {};
    db._meta.profitMode = profitMode;
    // Atualiza o UI e recalcula o pre√ßo caso esteja editando/produto preenchido
    // Recalcula o pre√ßo a partir do custo e porcentagem atual, respeitando o modo de lucro
    calcPrecoFromLucro();
    render(true);
    toast(`Modo de lucro: ${profitMode === 'margin' ? 'Margem (pre√ßo)' : 'Markup (custo)'}`, 'ok');
  }
}

// Define a forma de arredondamento do pre√ßo e persiste no metadata.
function setProfitRounding(val){
  const allowed = ['none','0.99','0.90','integer'];
  if(!allowed.includes(val)) val = 'none';
  if(profitRound !== val){
    profitRound = val;
    if(!db._meta) db._meta = {};
    db._meta.profitRound = profitRound;
    // Recalcula o pre√ßo atual com a nova regra de arredondamento
    calcPrecoFromLucro();
    render(true);
    toast(`Arredondamento: ${
      profitRound === 'none' ? 'Sem' : profitRound === 'integer' ? 'Inteiro' : profitRound === '0.99' ? 'Final 0,99' : 'Final 0,90'
    }`, 'ok');
  }
}

// Aplica a regra de arredondamento configurada ao pre√ßo em centavos. Retorna
// um valor em centavos ajustado conforme a op√ß√£o selecionada. N√£o altera
// valores negativos ou zero.
function applyProfitRounding(price_c){
  let p_c = Math.max(0, Math.round(Number(price_c) || 0));
  if(p_c === 0) return p_c;
  if(profitRound === 'none'){
    return p_c;
  }
  const p = p_c / 100; // valor em reais
  let newP = p;
  if(profitRound === '0.99'){
    newP = Math.floor(p) + 0.99;
  }else if(profitRound === '0.90'){
    newP = Math.floor(p) + 0.90;
  }else if(profitRound === 'integer'){
    newP = Math.round(p);
  }
  return Math.round(newP * 100);
}
// Limpa o campo de busca do estoque e re-renderiza a tabela
function clearEstoqueSearch(){
  const inp = $("estoqueSearch");
  if(inp) inp.value = "";
  // Atualiza lista de termos e renderiza novamente
  updateEstoqueSearch();
  render(true);
}
function deleteProduto(cod){
  cod = s(cod);
  const p = (db.estoque || []).find(x => s(x.cod) === cod);
  if(!p){ toast("Produto n√£o encontrado.", "bad"); return; }
  if(!confirm(`Apagar o produto "${p.nome}" (${p.cod}) do estoque?`)) return;

  db.estoque = (db.estoque || []).filter(x => s(x.cod) !== cod);
  save(); render(true);
  // Registrar auditoria de exclus√£o de produto
  addAudit('deleteProduct', 'Apagou produto ' + cod);
  toast("Produto apagado.", "warn");
  if(estoqueEditMode && estoqueEditOldCod === cod) cancelEditProduto();
}
function addProduto(){
  // Permiss√µes: somente usu√°rios com permiss√£o de editar custo/pre√ßo podem adicionar/editar produtos
  if(!hasPerm('editCost') && !hasPerm('editPrice')){
    toast('Voc√™ n√£o tem permiss√£o para gerenciar estoque.', 'bad');
    return;
  }
  const cod = sanitizeInputString(s($("e_cod")?.value));
  const nome = sanitizeInputString(s($("e_nome")?.value));

  let qtd = clampInt($("e_qtd")?.value, 0);
  let min = clampInt($("e_min")?.value, 0);

  const custo_c = parseMoneyToCents($("e_custo")?.value);
  let preco_c = parseMoneyToCents($("e_preco")?.value);
  // captura a porcentagem de lucro informada, se existir
  let lucro_p = 0;
  if($("e_lucro")){
    const val = parseFloat(String($("e_lucro").value).replace(",", "."));
    lucro_p = Number.isFinite(val) ? val : 0;
  }
  // se o pre√ßo n√£o foi fornecido mas h√° custo e porcentagem, calcula o pre√ßo automaticamente
  if((!preco_c || preco_c <= 0) && custo_c >= 0 && lucro_p > 0){
    preco_c = Math.round(custo_c * (1 + (lucro_p/100)));
  }

  if(isEmpty(cod) || isEmpty(nome)){ toast("Preencha c√≥digo e nome do produto.", "warn"); return; }
  if(custo_c < 0 || preco_c < 0){ toast("Custo/Pre√ßo inv√°lido.", "warn"); return; }

  if(estoqueEditMode){
    const oldCod = estoqueEditOldCod;
    const idxOld = (db.estoque || []).findIndex(x => s(x.cod) === oldCod);
    if(idxOld < 0){ toast("Produto original n√£o encontrado.", "bad"); estoqueEditMode=false; setEstoqueModeUI(); return; }

    const existsOther = (db.estoque || []).some(x => s(x.cod).toLowerCase() === cod.toLowerCase() && s(x.cod) !== oldCod);
    if(existsOther){ toast("J√° existe outro produto com esse c√≥digo.", "bad"); return; }

    // Preserve a data de adi√ß√£o original (added) ou define se estiver ausente
    const existingAdded = (db.estoque[idxOld] && db.estoque[idxOld].added) ? db.estoque[idxOld].added : Date.now();
    db.estoque[idxOld] = { cod, nome, qtd, min, custo_c, preco_c, lucro_p, added: existingAdded };
    save(); render(true);
    // Registrar auditoria de edi√ß√£o de produto
    addAudit('editProduct', 'Editou produto ' + cod);
    toast("Produto editado com sucesso!", "ok");
    // Cancelar o modo de edi√ß√£o silenciosamente para n√£o mostrar toast duplicado
    cancelEditProduto(true);
    return;
  }

  if(qtd <= 0){ toast("Quantidade deve ser maior que 0 para repor/cadastrar.", "warn"); return; }

  const i = (db.estoque || []).findIndex(x => s(x.cod).toLowerCase() === cod.toLowerCase());
  if(i >= 0){
    const o = db.estoque[i];
    const qtdOld = clampInt(o.qtd, 0);
    const tq = qtdOld + qtd;

    const numer = (o.custo_c * qtdOld) + (custo_c * qtd);
    o.custo_c = tq > 0 ? Math.round(numer / tq) : custo_c;

    o.qtd = tq;
    o.preco_c = preco_c;
    o.lucro_p = lucro_p;
    o.nome = nome;
    o.min = min;

    // Certifique-se de que itens antigos possuam campo 'added' para permitir ordena√ß√£o por data de adi√ß√£o
    if(!('added' in o) || !o.added){
      o.added = Date.now();
    }
  } else {
    // Quando cadastrando um item novo no estoque, armazenamos o timestamp de adi√ß√£o
    db.estoque.push({ cod, nome, qtd, min, custo_c, preco_c, lucro_p, added: Date.now() });
  }

  save(); render(true);
  // Registrar auditoria de cria√ß√£o ou atualiza√ß√£o de produto
  addAudit('saveProduct', 'Salvou/Atualizou produto ' + cod);
  ["e_cod","e_nome","e_qtd","e_min","e_custo","e_preco","e_lucro"].forEach(id=>{ if($(id)) $(id).value=""; });
  toast("Produto salvo/atualizado!", "ok");
}

/* ========== Vendas / Caixa ========== */
function registrarVenda(){
  if(!db.caixaAberto){ toast("Abra o caixa primeiro.", "warn"); return; }

  const cod = s($("v_prod")?.value);
  const qtd = clampInt($("v_qtd")?.value, 0);
  const pag = s($("v_pag")?.value);
  // Considera o custo de servi√ßo apenas se a prefer√™ncia estiver habilitada
  let servico_c = 0;
  try{
    servico_c = (db._meta && db._meta.maoObraEnabled) ? parseMoneyToCents($("v_servico")?.value) : 0;
  }catch(_e){ servico_c = 0; }

  if(isEmpty(cod)){ toast("Selecione um produto.", "warn"); return; }
  if(qtd <= 0){ toast("Quantidade deve ser maior que 0.", "warn"); return; }

  const p = (db.estoque || []).find(x => s(x.cod) === cod);
  if(!p){ toast("Produto n√£o encontrado.", "bad"); return; }
  // Se n√£o houver estoque suficiente, solicitar confirma√ß√£o ao usu√°rio antes de continuar.
  if(clampInt(p.qtd,0) < qtd){
    if(!confirm("Estoque insuficiente. Deseja continuar a venda mesmo assim?")) return;
  }

  // Produto sem pre√ßo definido? Solicitar confirma√ß√£o
  if(p.preco_c <= 0){
    if(!confirm("Este produto est√° sem pre√ßo definido. Deseja continuar a venda mesmo assim?")) return;
  }

  // Descontos
  const descItemPct = Math.max(0, parseFloat(String($("v_desc_item")?.value).replace(',', '.')) || 0);
  const descTotalPct = Math.max(0, parseFloat(String($("v_desc_total")?.value).replace(',', '.')) || 0);
  // Aplica desconto por item ao pre√ßo unit√°rio
  let unitPrice_c = p.preco_c;
  if(descItemPct > 0){
    unitPrice_c = Math.round(unitPrice_c * (1 - (descItemPct/100)));
  }
  // Calcula total bruto (com servi√ßo) antes do desconto total
  let total_c = addCents(mulCents(unitPrice_c, qtd), servico_c);
  if(descTotalPct > 0){
    total_c = Math.round(total_c * (1 - (descTotalPct/100)));
  }

  // Calcula lucro (receita menos custo). O custo total √© custo unit√°rio * qtd.
  const custoTotal_c = mulCents(p.custo_c, qtd);
  let lucro_c = total_c - custoTotal_c;

  // No modo de venda r√°pida n√£o h√° pagamento dividido (segundo pagamento),
  // portanto a l√≥gica de split foi removida. Todas as vendas r√°pidas s√£o
  // registradas com um √∫nico m√©todo de pagamento (pag). Qualquer campo de
  // segundo pagamento presente no DOM √© ignorado.

  // Verifica pagamento e troco.
  let recebido_c = parseMoneyToCents($("v_recebido")?.value);
  let troco_c = 0;
  if(pag === "dinheiro"){
    // Se pagamento em dinheiro, precisa receber pelo menos o total
    if(recebido_c < total_c){
      toast("Recebido insuficiente para fechar a venda.", "bad");
      return;
    }
    troco_c = recebido_c - total_c;
  }else{
    // Para outras formas de pagamento, ignoramos valor recebido
    recebido_c = total_c;
    troco_c = 0;
  }

  // Atualiza estoque: subtrai apenas a quantidade vendida do estoque.
  // Isso garante que o estoque seja diminu√≠do de acordo com a quantidade
  // vendida, mantendo a matem√°tica correta de invent√°rio. Caso o estoque
  // seja insuficiente, a valida√ß√£o anterior j√° ter√° impedido a venda.
  // Utilizamos clampInt para prevenir valores negativos.
  p.qtd = clampInt(p.qtd, 0) - qtd;

  const groupId = "VENDA-" + Date.now();
  const agora = nowDateTime();

  // Registrar venda (incluindo descontos). Como n√£o h√° split na venda r√°pida,
  // n√£o adicionamos propriedades pag2 ou pag2_val_c.
  const vendaObj = {
    id: makeId(),
    data: agora,
    cod: p.cod,
    nome: p.nome,
    qtd,
    servico_c,
    total_c,
    pag,
    lucro_c,
    descItem_p: descItemPct,
    descTotal_p: descTotalPct,
    cancelada:false,
    groupId
  };
  db.vendas.push(vendaObj);

  // Registrar movimento no caixa. Como n√£o h√° split, registramos um √∫nico
  // lan√ßamento no caixa com o valor total da venda.
  db.caixa.push({
    id: makeId(),
    data: agora,
    desc: "Venda",
    valor_c: total_c,
    tipo: "entrada",
    pag,
    groupId,
    categoria: "venda",
    responsavel: currentUser && currentUser.user ? currentUser.user : "sistema"
  });

  save(); render(true);
  // limpa campos da venda r√°pida
  if($("v_qtd")) $("v_qtd").value = "";
  if($("v_servico")) $("v_servico").value = "";
  if($("v_recebido")) $("v_recebido").value = "";
  if($("v_troco")) $("v_troco").value = "";
  if($("v_desc_item")) $("v_desc_item").value = "";
  if($("v_desc_total")) $("v_desc_total").value = "";
  // Gera recibo e nota fiscal se prefer√™ncias estiverem habilitadas
  try{
    const prodSel = p;
    const saleReceipt = {
      receiptId: 'REC-' + Date.now(),
      date: agora,
      payment: pag,
      items: [{ cod: p.cod, nome: p.nome, qtd, preco_c: p.preco_c, total_c }],
      subtotal_c: p.preco_c * qtd,
      service_c: servico_c,
      total_c: total_c,
      received_c: (pag === 'dinheiro' ? parseMoneyToCents($("v_recebido")?.value) : total_c),
      change_c: (pag === 'dinheiro' ? (typeof troco_c !== 'undefined' ? troco_c : 0) : 0),
      groupId
    };
    lastReceipt = saleReceipt;
    maybeEmitNotaFiscal(saleReceipt);
  }catch(_err){}
  toast("Venda registrada!", "ok");
}

function cancelarVenda(id){
  // Permiss√£o: somente usu√°rios autorizados podem cancelar vendas
  if(!hasPerm('cancelSale')){
    toast('Sem permiss√£o para cancelar vendas.', 'bad');
    return;
  }
  const v = (db.vendas || []).find(x => Number(x.id) === Number(id));
  if(!v){ toast("Venda n√£o encontrada.", "bad"); return; }
  if(v.cancelada){ toast("Essa venda j√° foi cancelada.", "warn"); return; }
  if(!confirm("Cancelar esta venda? Isso vai devolver estoque e estornar no caixa.")) return;

  const p = (db.estoque || []).find(x => s(x.cod) === s(v.cod));
  if(p) p.qtd = clampInt(p.qtd,0) + clampInt(v.qtd,0);

  const total_c = moneyOf(v, "total_c", "total");

  db.caixa.push({
    id: makeId(),
    data: nowDateTime(),
    desc: "Estorno venda: " + v.nome,
    valor_c: -Math.abs(total_c),
    tipo: "saida",
    pag: v.pag || "dinheiro",
    vendaId: v.id,
    groupId: v.groupId || "",
    categoria: "estorno",
    responsavel: currentUser && currentUser.user ? currentUser.user : "sistema"
  });

  v.cancelada = true;
  v.canceladaEm = nowDateTime();

  save(); render(true);
  // Registrar auditoria de cancelamento de venda
  addAudit('cancelSale', 'Cancelou venda ' + id);
  toast("Venda cancelada e estornada no caixa.", "warn");
}

function abrirCaixa(){
  if(db.caixaAberto){ toast("Caixa j√° est√° aberto.", "warn"); return; }
  const v_c = parseMoneyToCents($("cx_abertura")?.value);
  if(v_c < 0){ toast("Valor inicial inv√°lido.", "warn"); return; }

  db.caixaAberto = true;
  // Registrar abertura com ID √∫nico, categoria e respons√°vel para hist√≥rico
  db.caixa.push({
    id: makeId(),
    data: nowDateTime(),
    desc: "Abertura",
    valor_c: v_c,
    tipo: "entrada",
    pag: "dinheiro",
    categoria: "abertura",
    responsavel: currentUser && currentUser.user ? currentUser.user : "sistema"
  });

  save(); render(true);
  toast("Caixa aberto!", "ok");
}
function movimentoManual(){
  if(!db.caixaAberto){ toast("Abra o caixa primeiro.", "warn"); return; }

  const tipo = s($("cx_tipo")?.value);
  const cat  = s($("cx_categoria")?.value);
  const pag  = s($("cx_pag")?.value);
  const valor_c_raw = parseMoneyToCents($("cx_valor")?.value);
  const obs = s($("cx_obs")?.value);

  if(valor_c_raw <= 0){ toast("Valor inv√°lido (use maior que 0).", "warn"); return; }

  const valor_c = (tipo === "saida") ? -Math.abs(valor_c_raw) : Math.abs(valor_c_raw);

  db.caixa.push({
    id: makeId(),
    data: nowDateTime(),
    desc: `Movimento: ${cat}${obs ? " - " + obs : ""}`,
    valor_c,
    tipo,
    pag,
    categoria: cat,
    obs,
    responsavel: currentUser && currentUser.user ? currentUser.user : "sistema"
  });

  save(); render(true);
  toast("Movimento lan√ßado.", "ok");

  if($("cx_valor")) $("cx_valor").value = "";
  if($("cx_obs")) $("cx_obs").value = "";
}
function fecharCaixa(){
  if(!db.caixaAberto){ toast("Caixa n√£o est√° aberto.", "warn"); return; }
  if(!hasPerm('closeBox')){ toast('Sem permiss√£o para fechar caixa.', 'bad'); return; }

  const esperado_c = (db.caixa || []).reduce((sum,x)=> addCents(sum, moneyOf(x,"valor_c","valor")), 0);
  const contado_c = parseMoneyToCents($("cx_fechamento")?.value);
  if(contado_c < 0){ toast("Valor contado inv√°lido.", "warn"); return; }

  const dif_c = contado_c - esperado_c;

  const porPag = {dinheiro:0, pix:0, debito:0, credito:0};
  (db.caixa || []).forEach(m=>{
    const pg = s(m.pag);
    const v_c = moneyOf(m,"valor_c","valor");
    if(Object.prototype.hasOwnProperty.call(porPag, pg)) porPag[pg] += v_c;
  });

  if($("cx_relatorio")){
    const expStr  = centsToBR(esperado_c);
    const contStr = centsToBR(contado_c);
    const difAbsStr = centsToBR(Math.abs(dif_c));
    let report = '';
    report += '<div><b>Resumo do Caixa</b></div>';
    report += '<div>Valor esperado (lan√ßamentos): R$ ' + expStr + '</div>';
    report += '<div>Valor contado (no caixa): R$ ' + contStr + '</div>';
    report += '<div>Diferen√ßa: <b class="' + (dif_c>=0?'ok':'bad') + '">R$ ' + difAbsStr + '</b> ' + (dif_c>=0 ? '(sobrando)' : '(faltando)') + '</div>';
    report += '<br><div><b>Totais por forma de pagamento (entradas l√≠quidas):</b></div>';
    report += '<div>Dinheiro: R$ ' + centsToBR(porPag.dinheiro) + '</div>';
    report += '<div>Pix: R$ ' + centsToBR(porPag.pix) + '</div>';
    report += '<div>D√©bito: R$ ' + centsToBR(porPag.debito) + '</div>';
    report += '<div>Cr√©dito: R$ ' + centsToBR(porPag.credito) + '</div>';
    report += '<div class="small" style="margin-top:6px;">O valor esperado corresponde √† soma das entradas e sa√≠das registradas no caixa. A diferen√ßa indica se houve sobra ou falta em rela√ß√£o ao valor contado.</div>';
    $("cx_relatorio").innerHTML = report;
  }

  db.caixaAberto = false;
  save(); render(true);
  // Registrar auditoria de fechamento de caixa
  addAudit('closeBox', 'Fechou caixa');
  toast("Caixa fechado.", "warn");
}

/* ========== Modo de Venda (UI) ========== */
// O modo de venda padr√£o foi alterado para "completa" para privilegiar o carrinho.
let salesMode = "completa";
function swapAnim(el){
  if(!el) return;
  el.classList.remove("fadeSwap");
  void el.offsetWidth;
  el.classList.add("fadeSwap");
}
function setSalesMode(mode){
  salesMode = (mode === "completa") ? "completa" : "rapida";

  const q = $("saleQuickWrap");
  const c = $("saleCartWrap");
  const b1 = $("btnModeRapida");
  const b2 = $("btnModeCompleta");

  if(q) q.style.display = (salesMode === "rapida") ? "block" : "none";
  if(c) c.style.display = (salesMode === "completa") ? "block" : "none";

  if(b1) b1.classList.toggle("active", salesMode === "rapida");
  if(b2) b2.classList.toggle("active", salesMode === "completa");

  swapAnim(salesMode === "rapida" ? q : c);

  filtrarProdutosVenda();
  filtrarProdutosCarrinho();
  renderCarrinho(true);

  // Ap√≥s alterar o modo de venda, focar automaticamente no campo de busca apropriado.  Essa
  // melhoria de navega√ß√£o permite que o vendedor digite ou escaneie o c√≥digo do produto
  // imediatamente sem precisar clicar manualmente no input.  O atraso via setTimeout
  // garante que o elemento exista e esteja vis√≠vel ap√≥s as anima√ß√µes de troca.
  setTimeout(() => {
    try {
      if (salesMode === 'rapida') {
        const vb = document.getElementById('v_busca');
        if (vb) vb.focus();
      } else {
        const cb = document.getElementById('c_busca');
        if (cb) cb.focus();
      }
    } catch(_e){}
  }, 50);
}

/* ========== Filtro produtos (Venda 1 item) ========== */
function filtrarProdutosVenda(){
  const v_busca = $("v_busca");
  const v_prod  = $("v_prod");
  const v_hint  = $("v_hint");
  if(!v_prod) return;

  const q = s(v_busca?.value).toLowerCase();
  const items = (db.estoque || []).filter(p=>{
    const cod = s(p.cod).toLowerCase();
    const nome = s(p.nome).toLowerCase();
    return q === "" || cod.includes(q) || nome.includes(q);
  });

  v_prod.innerHTML = items.length
    ? items.map(p => `<option value="${escapeHTML(p.cod)}">${escapeHTML(p.nome)} (${escapeHTML(p.cod)}) - Estoque: ${p.qtd}</option>`).join("")
    : `<option value="">(Nenhum produto encontrado)</option>`;

  if(v_hint) v_hint.textContent = q === "" ? "" : `${items.length} encontrado(s).`;
}

/* ========== Calcula troco para venda r√°pida ==========
   Esta fun√ß√£o calcula o troco da venda r√°pida com base no produto selecionado,
   quantidade, valor do servi√ßo, forma de pagamento e valor recebido. Se o
   pagamento for em dinheiro, calcula a diferen√ßa entre o recebido e o total.
   Atualiza o campo de troco e a dica conforme necess√°rio. */
function calcQuickTroco(){
  const cod = s($("v_prod")?.value);
  const qtd = clampInt($("v_qtd")?.value, 0);
  // Considera servi√ßo apenas se a prefer√™ncia estiver habilitada
  let servico_c = 0;
  try{
    servico_c = (db._meta && db._meta.maoObraEnabled) ? parseMoneyToCents($("v_servico")?.value) : 0;
  }catch(_e){ servico_c = 0; }
  const pag = s($("v_pag")?.value);
  const produto = (db.estoque || []).find(p => s(p.cod) === cod);

  // Calcula total com base em pre√ßo unit√°rio, quantidade, servi√ßo e descontos
  let total_c = 0;
  if(produto && qtd > 0){
    let priceUnit = produto.preco_c;
    // desconto por item (%)
    const descItemPct = Math.max(0, parseFloat(String($("v_desc_item")?.value).replace(',', '.')) || 0);
    const descItemFactor = (descItemPct > 0) ? (1 - (descItemPct/100)) : 1;
    priceUnit = Math.round(priceUnit * descItemFactor);
    total_c = mulCents(priceUnit, qtd);
  }
  total_c = addCents(total_c, servico_c);
  // desconto total (%)
  const descTotalPct = Math.max(0, parseFloat(String($("v_desc_total")?.value).replace(',', '.')) || 0);
  if(descTotalPct > 0){
    total_c = Math.round(total_c * (1 - (descTotalPct/100)));
  }

  const recebidoInput = $("v_recebido");
  const trocoInput = $("v_troco");
  const hint = $("v_hint");
  // No modo de venda r√°pida n√£o h√° pagamento dividido (segundo pagamento),
  // portanto removemos a l√≥gica de split e sempre calculamos o troco com
  // base no pagamento principal (v_pag). Caso campos de pagamento
  // adicionais apare√ßam no futuro, eles devem ser ignorados aqui.

  // Sem split: calcular troco conforme forma de pagamento
  if(pag === "dinheiro"){
    const recebido_c = parseMoneyToCents(recebidoInput?.value);
    let troco_c = recebido_c - total_c;
    if(trocoInput) trocoInput.value = "R$ " + centsToBR(Math.max(0, troco_c));
    if(hint){
      if(total_c <= 0){
        hint.textContent = "";
      }else if(!Number.isFinite(recebido_c) || recebido_c <= 0){
        hint.textContent = `Total: R$ ${centsToBR(total_c)} ‚Äì informe o recebido para calcular o troco.`;
      }else if(recebido_c < total_c){
        const falta_c = total_c - recebido_c;
        hint.textContent = `Total: R$ ${centsToBR(total_c)} ‚Äì recebido insuficiente: falta R$ ${centsToBR(falta_c)}`;
      }else{
        hint.textContent = `Total: R$ ${centsToBR(total_c)} ‚Äì troco: R$ ${centsToBR(troco_c)}`;
      }
    }
  }else{
    // Pagamento n√£o-dinheiro: limpamos valores de troco e recebido
    if(recebidoInput){
      recebidoInput.value = "";
    }
    if(trocoInput) trocoInput.value = "";
    if(hint){
      hint.textContent = total_c > 0 ? `Total: R$ ${centsToBR(total_c)} ‚Äì pagamento ${pag || 'indefinido'} (sem troco)` : "";
    }
  }
}

/* ========== Carrinho (multi itens) ========== */
let carrinho = [];
// Controle da ordem do hist√≥rico de vendas. Quando verdadeiro (padr√£o),
// as vendas mais recentes aparecem primeiro; quando falso, o mais antigo aparece primeiro.
let vendasOrderDesc = true;
let lastReceipt = null;

function pulseCart(){
  const card = $("cartCard");
  if(!card) return;
  card.classList.remove("cartPulse");
  void card.offsetWidth;
  card.classList.add("cartPulse");
}

function filtrarProdutosCarrinho(){
  const b = $("c_busca");
  const sel = $("c_prod");
  if(!sel) return;

  const q = s(b?.value).toLowerCase();
  const items = (db.estoque || []).filter(p=>{
    const cod = s(p.cod).toLowerCase();
    const nome = s(p.nome).toLowerCase();
    return q === "" || cod.includes(q) || nome.includes(q);
  });

  sel.innerHTML = items.length
    ? items.map(p => `<option value="${escapeHTML(p.cod)}">${escapeHTML(p.nome)} (${escapeHTML(p.cod)}) - R$ ${centsToBR(p.preco_c)} - Estoque: ${p.qtd}</option>`).join("")
    : `<option value="">(Nenhum produto encontrado)</option>`;
}

function addToCart(){
  const cod = s($("c_prod")?.value);
  const qtd = clampInt($("c_qtd")?.value, 0);
  if(isEmpty(cod)){ toast("Selecione um produto.", "warn"); return; }
  if(qtd <= 0){ toast("Quantidade deve ser maior que 0.", "warn"); return; }

  const p = (db.estoque || []).find(x => s(x.cod) === cod);
  if(!p){ toast("Produto n√£o encontrado.", "bad"); return; }
  if(clampInt(p.qtd,0) < qtd){ toast("Estoque insuficiente para essa quantidade.", "bad"); return; }

  const idx = carrinho.findIndex(i => s(i.cod) === cod);
  if(idx >= 0){
    carrinho[idx].qtd += qtd;
  }else{
    carrinho.push({
      cod: p.cod,
      nome: p.nome,
      qtd,
      preco_c: p.preco_c,
      custo_c: p.custo_c,
      total_c: 0
    });
  }

  if($("c_qtd")) $("c_qtd").value = "1";
  renderCarrinho(true);
  pulseCart();
  toast("Adicionado ao carrinho.", "ok");
}

function removeCartItem(i){
  carrinho.splice(i,1);
  renderCarrinho(true);
  pulseCart();
  toast("Item removido do carrinho.", "warn");
}
function limparCarrinho(){
  if(carrinho.length === 0){ toast("Carrinho j√° est√° vazio.", "warn"); return; }
  if(!confirm("Limpar carrinho?")) return;
  carrinho = [];
  renderCarrinho(true);
  pulseCart();
  toast("Carrinho limpo.", "warn");
}

/* ‚úÖ FIX PRINCIPAL: calcCarrinho agora calcula o troco corretamente, incluindo valores negativos
   e remove retornos duplicados. */
function calcCarrinho(){
  // subtotal sempre baseado nos itens (sem depender de it.total_c)
  let subtotal_c = 0;

  for (const it of carrinho){
    const qtd = Math.max(0, Math.floor(Number(it.qtd) || 0));
    const preco_c = Math.max(0, Math.round(Number(it.preco_c) || 0));
    const totalItem_c = preco_c * qtd;

    it.qtd = qtd;
    it.preco_c = preco_c;
    it.total_c = totalItem_c;

    subtotal_c += totalItem_c;
  }

  // Servi√ßo/m√£o de obra somente quando habilitado nas prefer√™ncias
  let servico_c = 0;
  try{
    servico_c = (db._meta && db._meta.maoObraEnabled) ? Math.max(0, parseMoneyToCents($("c_servico")?.value)) : 0;
  }catch(_e){ servico_c = 0; }
  const total_c = subtotal_c + servico_c;

  const pag = String($("c_pag")?.value || "dinheiro");
  let recebido_c = Math.max(0, parseMoneyToCents($("c_recebido")?.value));

  // troco s√≥ para dinheiro
  let troco_c = 0;
  if (pag === "dinheiro"){
    troco_c = recebido_c - total_c;
  } else {
    recebido_c = total_c;
    troco_c = 0;
  }

  return { subtotal_c, servico_c, total_c, pag, recebido_c, troco_c };
}

function renderCarrinho(withFlash=false){
  const tbody = $("tCart");
  const { subtotal_c, servico_c, total_c, pag } = calcCarrinho();
  if(!tbody) return;
  // Reconstru√ß√£o eficiente usando DocumentFragment. Limpa o corpo antes de preencher.
  tbody.innerHTML = '';
  if(carrinho.length === 0){
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 6;
    td.className = 'small';
    td.textContent = 'Carrinho vazio.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  } else {
    const frag = document.createDocumentFragment();
    carrinho.forEach((it, idx) => {
      const tr = document.createElement('tr');
      if(withFlash) tr.classList.add('flash');
      // #
      const tdIndex = document.createElement('td');
      tdIndex.textContent = String(idx+1);
      tr.appendChild(tdIndex);
      // nome + cod
      const tdNome = document.createElement('td');
      tdNome.className = 'rowleft';
      tdNome.innerHTML = `${escapeHTML(it.nome)} <span class="small">(${escapeHTML(it.cod)})</span>`;
      tr.appendChild(tdNome);
      // qtd
      const tdQtd = document.createElement('td');
      tdQtd.textContent = String(it.qtd);
      tr.appendChild(tdQtd);
      // pre√ßo
      const tdPreco = document.createElement('td');
      tdPreco.textContent = 'R$ ' + centsToBR(it.preco_c);
      tr.appendChild(tdPreco);
      // total
      const tdTotal = document.createElement('td');
      tdTotal.textContent = 'R$ ' + centsToBR(it.total_c);
      tr.appendChild(tdTotal);
      // remover
      const tdBtn = document.createElement('td');
      const btnRem = document.createElement('button');
      btnRem.className = 'danger';
      btnRem.textContent = 'Remover';
      btnRem.onclick = function(){ removeCartItem(idx); };
      tdBtn.appendChild(btnRem);
      tr.appendChild(tdBtn);
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
  }
  // Atualiza totais
  const itensEl = $("c_itens");
  if(itensEl) itensEl.textContent = String(carrinho.reduce((a,b)=> a + (Number(b.qtd)||0),0));
  const subEl = $("c_sub");
  if(subEl) subEl.textContent = centsToBR(subtotal_c);
  const srvEl = $("c_srv");
  if(srvEl) srvEl.textContent = centsToBR(servico_c);
  const totalEl = $("c_total");
  if(totalEl) totalEl.textContent = centsToBR(total_c);
  // c√°lculo de troco
  const recebidoInput = $("c_recebido");
  const hint = $("c_hint");
  let trocoString = '0,00';
  if(pag === 'dinheiro'){
    const rec_c = parseMoneyToCents(recebidoInput?.value);
    const diff = rec_c - total_c;
    if(rec_c <= 0){
      trocoString = centsToBR(0);
      if(hint) hint.textContent = 'Digite o valor recebido para calcular o troco.';
    }else if(diff < 0){
      trocoString = centsToBR(0);
      if(hint) hint.textContent = 'Recebido insuficiente: falta R$ ' + centsToBR(-diff);
    }else{
      trocoString = centsToBR(diff);
      if(hint) hint.textContent = 'Troco: R$ ' + centsToBR(diff);
    }
  }else{
    if(recebidoInput){ recebidoInput.value = ''; }
    trocoString = centsToBR(0);
    if(hint) hint.textContent = 'Pagamento n√£o-dinheiro: troco n√£o se aplica.';
  }
  const trocoView = $("c_troco_view");
  if(trocoView) trocoView.textContent = trocoString;
  const trocoEl = $("c_troco");
  if(trocoEl) trocoEl.value = 'R$ ' + trocoString;
  const btn = $("btnPrintReceipt");
  if(btn) btn.style.display = lastReceipt ? 'inline-block' : 'none';
}

function finalizarCarrinho(){
  if(!db.caixaAberto){ toast("Abra o caixa primeiro.", "warn"); return; }
  if(carrinho.length === 0){ toast("Carrinho vazio.", "warn"); return; }

  const { subtotal_c, servico_c, total_c, pag, recebido_c, troco_c } = calcCarrinho();

  if(pag === "dinheiro" && recebido_c < total_c){
    toast("Recebido insuficiente para fechar a venda.", "bad");
    return;
  }

  for(const it of carrinho){
    const p = (db.estoque || []).find(x => s(x.cod) === s(it.cod));
    if(!p){ toast(`Produto sumiu do estoque: ${it.nome}`, "bad"); return; }
    if(clampInt(p.qtd,0) < it.qtd){
      toast(`Estoque insuficiente: ${it.nome}`, "bad");
      return;
    }
  }

  const groupId = "VENDA-" + Date.now();
  const agora = nowDateTime();

  carrinho.forEach((it, idx)=>{
    const p = (db.estoque || []).find(x => s(x.cod) === s(it.cod));
    // Atualiza estoque: subtrai a quantidade vendida do carrinho do estoque.
    // Anteriormente zerava o estoque, mas para a l√≥gica correta de invent√°rio
    // devemos apenas diminuir a quantidade vendida. Usamos clampInt para
    // prevenir valores negativos caso o estoque esteja zerado.
    p.qtd = clampInt(p.qtd, 0) - it.qtd;

    const totalItem_c = it.total_c;
    const lucroItem_c = mulCents((it.preco_c - it.custo_c), it.qtd);

    const serv_c = (idx === 0) ? servico_c : 0;
    const totalLinha_c = addCents(totalItem_c, serv_c);
    const lucroLinha_c = addCents(lucroItem_c, serv_c);

    db.vendas.push({
      id: makeId(),
      data: agora,
      cod: it.cod,
      nome: it.nome,
      qtd: it.qtd,
      servico_c: serv_c,
      total_c: totalLinha_c,
      pag,
      lucro_c: lucroLinha_c,
      cancelada:false,
      groupId
    });
  });

  db.caixa.push({
    data: agora,
    desc: "Venda (Carrinho)",
    valor_c: total_c,
    tipo: "entrada",
    pag,
    groupId
  });

  save(); render(true);

  lastReceipt = {
    receiptId: "REC-" + Date.now(),
    date: agora,
    payment: pag,
    items: carrinho.map(it => ({
      cod: it.cod, nome: it.nome, qtd: it.qtd,
      preco_c: it.preco_c,
      total_c: it.total_c
    })),
    subtotal_c, service_c: servico_c, total_c,
    received_c: (pag === "dinheiro" ? recebido_c : total_c),
    change_c: (pag === "dinheiro" ? troco_c : 0),
    groupId
  };

  carrinho = [];
  if($("c_servico")) $("c_servico").value = "";
  if($("c_recebido")) $("c_recebido").value = "";
  renderCarrinho(true);
  pulseCart();
  const btn = $("btnPrintReceipt");
  if(btn) btn.style.display = "inline-block";
  // Emite nota fiscal conforme prefer√™ncias do usu√°rio
  try{ maybeEmitNotaFiscal(lastReceipt); }catch(_e){}
  toast("Venda do carrinho conclu√≠da!", "ok");
  // Toca som de venda conclu√≠da
  try{ if(typeof saleSound === 'function') saleSound(); }catch(_e){}
}

/* ========== Nota Fiscal / Comprovante ========== */

/**
 * Dispara a emiss√£o de nota fiscal (comprovante) com base nas prefer√™ncias.
 * Se NF em PDF ou impressa estiver ativada nas prefer√™ncias, gera um HTML
 * tempor√°rio via buildReceiptHTML() e abre em uma nova janela para imprimir.
 * A impress√£o √© disparada automaticamente; se o pop‚Äëup for bloqueado,
 * um arquivo HTML √© baixado como fallback. O recurso utiliza a API
 * nativa de impress√£o do navegador, permitindo salvar em PDF ou enviar
 * para uma impressora USB/virtual conforme disponibilidade do usu√°rio.
 *
 * @param {Object} r Objeto de recibo no formato aceito por buildReceiptHTML
 */
function maybeEmitNotaFiscal(r){
  try{
    const meta = (db && db._meta) ? db._meta : {};
    const wantPDF = !!meta.nf_pdf_enabled;
    const wantPrint = !!meta.nf_print_enabled;
    if(!wantPDF && !wantPrint) return;
    const html = buildReceiptHTML(r);
    const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const w = window.open(url, '_blank');
    if(!w){
      // Se o pop‚Äëup for bloqueado, faz download do comprovante em HTML
      const a = document.createElement('a');
      a.href = url;
      a.download = `${r.receiptId}.html`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 12000);
      if(typeof toast === 'function') toast('Pop‚Äëup bloqueado; baixe e imprima o comprovante manualmente.', 'warn');
      return;
    }
    // Ao carregar a nova janela, solicita impress√£o automaticamente
    w.addEventListener('load', () => {
      try{ w.print(); }catch(_e){}
    });
    setTimeout(()=>URL.revokeObjectURL(url), 12000);
  }catch(e){
    console.warn('Falha ao emitir nota fiscal:', e);
  }
}

/* ========== Comprovante ========== */
function buildReceiptHTML(r) {
  // Inclui campos adicionais e logotipo na empresa; garante que logo seja definido.
  const emp = db.empresa || { nome:"", cnpj:"", contato:"", endereco:"", celular:"", email:"", logo:"" };
  // Monta o bloco HTML da empresa para o recibo, incluindo logotipo e detalhes.
  const empBlock = (function(){
    try{
      let info = '<div class="box" style="display:flex; gap:10px; align-items:flex-start;">';
      if(emp.logo){
        info += '<img src="' + emp.logo + '" alt="Logo" style="max-height:60px; max-width:60px;">';
      }
      info += '<div>';
      info += '<b>' + escapeHTML(emp.nome || 'Empresa') + '</b><br>';
      info += 'CNPJ: ' + escapeHTML(emp.cnpj || '-') + '<br>';
      info += 'Contato: ' + escapeHTML(emp.contato || '-') + '<br>';
      // Sempre exibe o endere√ßo com r√≥tulo quando informado
      if(emp.endereco) info += 'Endere√ßo: ' + escapeHTML(emp.endereco) + '<br>';
      if(emp.celular) info += 'Celular: ' + escapeHTML(emp.celular) + '<br>';
      if(emp.email) info += 'Email: ' + escapeHTML(emp.email);
      info += '</div></div>';
      return info;
    }catch(__err){
      return '<div class="box"><b>' + escapeHTML(emp.nome || 'Empresa') + '</b></div>';
    }
  })();

  // Ajuste de estilo para impressoras t√©rmicas. Quando o usu√°rio seleciona o
  // dispositivo de impressora "thermal" nas prefer√™ncias, definimos regras
  // adicionais para a impress√£o: largura fixa de 80mm e margem zero. Caso
  // contr√°rio, extraCss permanece vazio e n√£o interfere no layout.
  const isThermal = (db && db._meta && db._meta.printerDevice === 'thermal');
  const extraCss = isThermal ? '@media print { @page { size: 80mm auto; margin: 0; } body { width: 80mm; margin:0; } }' : '';

  const rows = (r.items || []).map((it, i) => `
    <tr>
      <td style="padding:8px;border:1px solid #222;text-align:center;">${i+1}</td>
      <td style="padding:8px;border:1px solid #222;">${escapeHTML(it.nome)} (${escapeHTML(it.cod)})</td>
      <td style="padding:8px;border:1px solid #222;text-align:center;">${it.qtd}</td>
      <td style="padding:8px;border:1px solid #222;text-align:right;">R$ ${centsToBR(it.preco_c)}</td>
      <td style="padding:8px;border:1px solid #222;text-align:right;">R$ ${centsToBR(it.total_c)}</td>
    </tr>
  `).join("");

  return `<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Comprovante ${escapeHTML(r.receiptId)}</title>
<style>
  body{font-family:Arial, sans-serif; margin:24px; color:#111;}
  .top{display:flex; justify-content:space-between; gap:20px; flex-wrap:wrap;}
  .box{border:1px solid #222; padding:12px; border-radius:10px;}
  h1{margin:0; font-size:18px;}
  .muted{color:#444; font-size:12px;}
  table{width:100%; border-collapse:collapse; margin-top:12px; font-size:13px;}
  .right{text-align:right;}
  hr{border:0;border-top:1px solid #222; margin:10px 0;}
  .noPrint{margin-top:14px; display:flex; gap:10px; flex-wrap:wrap;}
  @media print { .noPrint{display:none} }
  ${extraCss}
</style>
</head>
<body>
  <div class="top">
    <div>
      <h1>Comprovante de Venda</h1>
      <div class="muted"><b>${escapeHTML(r.receiptId)}</b></div>
      <div class="muted">Data/Hora: ${escapeHTML(r.date)}</div>
      ${r.groupId ? `<div class="muted">Grupo: ${escapeHTML(r.groupId)}</div>` : ""}
    </div>
      ${empBlock}
  </div>

      <!-- O bloco de or√ßamentos n√£o deve ser inclu√≠do no comprovante. A vers√£o de ferramentas
           ficar√° fora deste template. -->

  <table>
    <thead>
      <tr>
        <th style="padding:8px;border:1px solid #222;">#</th>
        <th style="padding:8px;border:1px solid #222;text-align:left;">Item</th>
        <th style="padding:8px;border:1px solid #222;">Qtd</th>
        <th style="padding:8px;border:1px solid #222;" class="right">Unit</th>
        <th style="padding:8px;border:1px solid #222;" class="right">Total</th>
      </tr>
    </thead>
    <tbody>
      ${rows || `<tr><td colspan="5" style="padding:10px;border:1px solid #222;text-align:center;">(sem itens)</td></tr>`}
    </tbody>
  </table>

  <div class="box" style="margin-top:12px;">
    <div><b>Subtotal:</b> R$ ${centsToBR(r.subtotal_c)}</div>
    <div><b>Servi√ßo:</b> R$ ${centsToBR(r.service_c)}</div>
    <hr>
    <div style="font-size:16px;"><b>Total:</b> R$ ${centsToBR(r.total_c)}</div>
    <div style="margin-top:6px;"><b>Pagamento:</b> ${escapeHTML(r.payment)}</div>
    <div><b>Recebido:</b> R$ ${centsToBR(r.received_c)}</div>
    <div><b>Troco:</b> R$ ${centsToBR(r.change_c)}</div>
  </div>

  <div class="muted" style="margin-top:10px;">
    Obrigado pela prefer√™ncia.
  </div>

  <div class="noPrint">
    <button onclick="window.print()">Imprimir / Salvar PDF</button>
    <button onclick="window.close()">Fechar</button>
  </div>
</body>
</html>`;
}
function imprimirUltimoComprovante(){
  if(!lastReceipt){ toast("Nenhum comprovante dispon√≠vel.", "warn"); return; }
  const html = buildReceiptHTML(lastReceipt);
  const blob = new Blob([html], { type: "text/html;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  const w = window.open(url, "_blank");
  if(!w){
    const a = document.createElement("a");
    a.href = url;
    a.download = `${lastReceipt.receiptId}.html`;
    a.click();
    toast("Pop-up bloqueado. Baixei o comprovante em HTML (abra e imprima como PDF).", "warn");
    setTimeout(()=>URL.revokeObjectURL(url), 12000);
    return;
  }

  toast("Comprovante aberto! Clique em imprimir/salvar PDF.", "ok");
  setTimeout(()=>URL.revokeObjectURL(url), 12000);
}

//
// imprime uma tabela resumida com os itens do estoque.
// A tabela inclui c√≥digo, nome e valor de venda formatado. O documento
// √© aberto em uma nova janela e pode ser impresso ou salvo em PDF
// pelo pr√≥prio navegador. Se o pop-up for bloqueado, o arquivo HTML
// √© baixado automaticamente. Em caso de erro, uma notifica√ß√£o
// apropriada √© exibida.
function imprimirRelacao(){
  try{
    const items = Array.isArray(db.estoque) ? db.estoque : [];
    let html = '<!DOCTYPE html><html><head><meta charset="utf-8">';
    html += '<title>Rela√ß√£o de Estoque</title>';
    html += '<style>body{font-family:Arial,sans-serif;padding:20px;}';
    html += 'table{width:100%;border-collapse:collapse;margin-top:10px;}';
    html += 'th,td{border:1px solid #000;padding:4px;text-align:left;}';
    html += 'th{background:#f0f0f0;}</style>';
    html += '</head><body>';
    html += '<h2>Rela√ß√£o de Estoque</h2>';
    html += '<table><thead><tr><th>C√≥digo</th><th>Nome</th><th>Valor</th></tr></thead><tbody>';
    for(const it of items){
      const cod  = it && it.cod ? String(it.cod) : '';
      const nome = it && it.nome ? String(it.nome) : '';
      const val  = typeof formatCurrencyBR === 'function' ? formatCurrencyBR(Number(it.preco_c)||0) : String(it.preco_c || 0);
      html += `<tr><td>${cod}</td><td>${nome}</td><td>${val}</td></tr>`;
    }
    html += '</tbody></table>';
    html += '<div class="noPrint" style="margin-top:10px;"><button onclick="window.print()">Imprimir</button><button onclick="window.close()">Fechar</button></div>';
    html += '</body></html>';
    const blob = new Blob([html], { type:'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const w   = window.open(url, '_blank');
    if(!w){
      const a = document.createElement('a');
      a.href = url;
      a.download = 'relacao-estoque.html';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 12000);
      if(typeof toast === 'function') toast('Pop-up bloqueado. Baixei a rela√ß√£o em HTML.', 'warn');
      return;
    }
    setTimeout(()=>URL.revokeObjectURL(url), 12000);
  }catch(e){
    console.warn('imprimirRelacao error', e);
    if(typeof toast === 'function') toast('Erro ao imprimir rela√ß√£o.', 'bad');
  }
}

/* ========== Perfil ========== */
function salvarPerfil(){
  db.empresa.nome = s($("p_nome")?.value);
  db.empresa.cnpj = s($("p_cnpj")?.value);
  db.empresa.contato = s($("p_contato")?.value);
  // Novos campos de perfil: endere√ßo, celular e e‚Äëmail
  db.empresa.endereco = s($("p_endereco")?.value);
  db.empresa.celular = s($("p_celular")?.value);
  db.empresa.email = s($("p_email")?.value);
  const fileInput = $("p_logo");
  // Se o usu√°rio selecionou um novo logotipo, leia o arquivo como DataURL
  if(fileInput && fileInput.files && fileInput.files[0]){
    const reader = new FileReader();
    reader.onload = function(e){
      db.empresa.logo = e.target.result;
      save(); renderPerfilView();
      toast("Perfil salvo!", "ok");
      // limpar sele√ß√£o de arquivo ap√≥s salvar
      try{ fileInput.value = ""; }catch(err){}
    };
    reader.readAsDataURL(fileInput.files[0]);
    return;
  }
  // Caso contr√°rio, apenas salve e atualize a visualiza√ß√£o
  save(); renderPerfilView();
  toast("Perfil salvo!", "ok");
}
function renderPerfilView(){
  const pv = $("p_view");
  if(pv){
    pv.innerHTML = `
      <b>Empresa:</b> ${escapeHTML(db.empresa?.nome || "-")}<br>
      <b>CNPJ:</b> ${escapeHTML(db.empresa?.cnpj || "-")}<br>
      <b>Contato:</b> ${escapeHTML(db.empresa?.contato || "-")}<br>
      <b>Endere√ßo:</b> ${escapeHTML(db.empresa?.endereco || "-")}<br>
      <b>Celular:</b> ${escapeHTML(db.empresa?.celular || "-")}<br>
      <b>E-mail:</b> ${escapeHTML(db.empresa?.email || "-")}
    `;
  }
  if($("p_nome")) $("p_nome").value = db.empresa?.nome || "";
  if($("p_cnpj")) $("p_cnpj").value = db.empresa?.cnpj || "";
  if($("p_contato")) $("p_contato").value = db.empresa?.contato || "";
  if($("p_endereco")) $("p_endereco").value = db.empresa?.endereco || "";
  if($("p_celular")) $("p_celular").value = db.empresa?.celular || "";
  if($("p_email")) $("p_email").value = db.empresa?.email || "";
  // atualizar visualiza√ß√£o do logotipo salvo
  const preview = $("p_logo_preview");
  if(preview){
    if(db.empresa?.logo){
      preview.src = db.empresa.logo;
      preview.style.display = "block";
    }else{
      preview.src = "";
      preview.style.display = "none";
    }
  }
}

/* ========== Gr√°ficos ========== */
function renderGraficos(){
  const g_top_qtd = $("g_top_qtd");
  const g_top_fat = $("g_top_fat");
  const g_top_luc = $("g_top_luc");
  const g_acabando = $("g_acabando");
  const g_fat_dia = $("g_fat_dia");
  if(!g_top_qtd || !g_top_fat || !g_top_luc || !g_acabando || !g_fat_dia) return;

  const vendasOk = (db.vendas || []).filter(v => !v.cancelada);
  const agg = new Map();

  vendasOk.forEach(v=>{
    const key = s(v.nome);
    if(!agg.has(key)) agg.set(key, {nome:key, qtd:0, fat_c:0, lucro_c:0});
    const a = agg.get(key);
    a.qtd += clampInt(v.qtd,0);
    a.fat_c += moneyOf(v,"total_c","total");
    a.lucro_c += moneyOf(v,"lucro_c","lucro");
  });

  const arr = Array.from(agg.values());

  const topQtd = [...arr].sort((a,b)=>b.qtd-a.qtd).slice(0,10);
  const maxQtd = topQtd.length ? topQtd[0].qtd : 0;
  g_top_qtd.innerHTML = topQtd.length ? topQtd.map((x,i)=>(
    `<tr>
      <td>${i+1}</td>
      <td class="rowleft">${escapeHTML(x.nome)}</td>
      <td>${x.qtd}</td>
      <td><div class="barwrap"><div class="bar" style="width:${pct(x.qtd,maxQtd).toFixed(1)}%"></div></div></td>
    </tr>`
  )).join("") : `<tr><td colspan="4" class="small">Sem vendas ainda.</td></tr>`;

  const topFat = [...arr].sort((a,b)=>b.fat_c-a.fat_c).slice(0,10);
  const maxFat = topFat.length ? topFat[0].fat_c : 0;
  g_top_fat.innerHTML = topFat.length ? topFat.map((x,i)=>(
    `<tr>
      <td>${i+1}</td>
      <td class="rowleft">${escapeHTML(x.nome)}</td>
      <td>R$ ${centsToBR(x.fat_c)}</td>
      <td><div class="barwrap"><div class="bar" style="width:${pct(x.fat_c,maxFat).toFixed(1)}%"></div></div></td>
    </tr>`
  )).join("") : `<tr><td colspan="4" class="small">Sem vendas ainda.</td></tr>`;

  const topLuc = [...arr].sort((a,b)=>b.lucro_c-a.lucro_c).slice(0,10);
  const maxLuc = topLuc.length ? topLuc[0].lucro_c : 0;
  g_top_luc.innerHTML = topLuc.length ? topLuc.map((x,i)=>(
    `<tr>
      <td>${i+1}</td>
      <td class="rowleft">${escapeHTML(x.nome)}</td>
      <td>R$ ${centsToBR(x.lucro_c)}</td>
      <td><div class="barwrap"><div class="bar" style="width:${pct(x.lucro_c,maxLuc).toFixed(1)}%"></div></div></td>
    </tr>`
  )).join("") : `<tr><td colspan="4" class="small">Sem vendas ainda.</td></tr>`;

  const acabando = (db.estoque || [])
    .map(p=>({ cod: s(p.cod), nome: s(p.nome), qtd: clampInt(p.qtd,0), min: clampInt(p.min,0) }))
    .filter(p=>p.qtd <= p.min)
    .sort((a,b)=>(a.qtd-b.qtd) || a.nome.localeCompare(b.nome));

  g_acabando.innerHTML = acabando.length ? acabando.map(p=>(
    `<tr><td>${escapeHTML(p.cod)}</td><td class="rowleft">${escapeHTML(p.nome)}</td><td class="bad">${p.qtd}</td><td>${p.min}</td></tr>`
  )).join("") : `<tr><td colspan="4" class="small">Nenhum produto abaixo do m√≠nimo üéâ</td></tr>`;

  const now = new Date();
  const start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 29);
  const byDay = {};
  vendasOk.forEach(v=>{
    const dt = parseBRDateTime(v.data);
    if(dt >= start){
      const key = dateKeyLocal(dt);
      byDay[key] = (byDay[key] || 0) + moneyOf(v,"total_c","total");
    }
  });

  const rowsDay = [];
  for(let i=0;i<30;i++){
    const d = new Date(start.getFullYear(), start.getMonth(), start.getDate()+i);
    const key = dateKeyLocal(d);
    const label = String(d.getDate()).padStart(2,"0") + "/" + String(d.getMonth()+1).padStart(2,"0");
    rowsDay.push({label, total_c: byDay[key] || 0});
  }
  const maxDay = rowsDay.reduce((m,r)=>Math.max(m,r.total_c), 0);

  g_fat_dia.innerHTML = rowsDay.map(r=>(
    `<tr>
      <td>${r.label}</td>
      <td>R$ ${centsToBR(r.total_c)}</td>
      <td><div class="barwrap"><div class="bar" style="width:${pct(r.total_c,maxDay).toFixed(1)}%"></div></div></td>
    </tr>`
  )).join("");
}

/* ========== Or√ßamento (mantido) ========== */
let orc = { itens: [] };

function abrirOrcamentoUI(){
  // Se o or√ßamento estiver desativado nas prefer√™ncias, n√£o abra a UI
  try{
    if(!(db._meta && db._meta.orcamentoEnabled)){
      toast("Or√ßamento desativado nas prefer√™ncias.", "warn");
      return;
    }
  }catch(_e){}
  const card = $("orcCard");
  if(card) card.style.display = "block";
  renderOrcProdutos();
  renderOrc();
  $("o_busca")?.focus();
  toast("Or√ßamento aberto.", "ok");
}
function fecharOrcamentoUI(){
  const card = $("orcCard");
  if(card) card.style.display = "none";
  toast("Or√ßamento fechado.", "warn");
}
function renderOrcProdutos(){
  const sel = $("o_prod");
  if(!sel) return;
  const q = s($("o_busca")?.value).toLowerCase();
  const items = (db.estoque || []).filter(p=>{
    const cod = s(p.cod).toLowerCase();
    const nome = s(p.nome).toLowerCase();
    return q === "" || cod.includes(q) || nome.includes(q);
  });
  sel.innerHTML = items.length
    ? items.map(p => `<option value="${escapeHTML(p.cod)}">${escapeHTML(p.nome)} (${escapeHTML(p.cod)}) - R$ ${centsToBR(p.preco_c)}</option>`).join("")
    : `<option value="">(Nenhum produto encontrado)</option>`;
}
function addItemOrc(){
  const cod = s($("o_prod")?.value);
  const qtd = clampInt($("o_qtd")?.value, 0);
  if(isEmpty(cod)){ toast("Selecione um produto para or√ßar.", "warn"); return; }
  if(qtd <= 0){ toast("Quantidade deve ser maior que 0.", "warn"); return; }

  const p = (db.estoque || []).find(x => s(x.cod) === cod);
  if(!p){ toast("Produto n√£o encontrado no estoque.", "bad"); return; }

  const preco_c = p.preco_c;
  const nome = s(p.nome);

  const idx = orc.itens.findIndex(i => s(i.cod) === cod);
  if(idx >= 0){
    orc.itens[idx].qtd += qtd;
    orc.itens[idx].total_c = mulCents(orc.itens[idx].preco_c, orc.itens[idx].qtd);
  } else {
    orc.itens.push({ cod, nome, qtd, preco_c, total_c: mulCents(preco_c, qtd) });
  }

  if($("o_qtd")) $("o_qtd").value = "";
  renderOrc(true);
  toast("Item adicionado no or√ßamento.", "ok");
}
function removerItemOrc(i){
  orc.itens.splice(i,1);
  renderOrc(true);
  toast("Item removido.", "warn");
}
function limparOrc(){
  if(!confirm("Limpar or√ßamento atual?")) return;
  orc.itens = [];
  if($("o_servico")) $("o_servico").value = "";
  if($("o_obs")) $("o_obs").value = "";
  if($("o_cliente")) $("o_cliente").value = "";
  if($("o_contato")) $("o_contato").value = "";
  if($("o_validade")) $("o_validade").value = "";
  renderOrc(true);
  toast("Or√ßamento limpo.", "warn");
}
function renderOrc(withFlash=false){
  const tbody = $("tOrcItens");
  if(!tbody) return;
  let subtotal_c = 0;
  // Limpa e reconstr√≥i o corpo usando fragmento para evitar reflows repetitivos
  tbody.innerHTML = '';
  if(orc.itens.length === 0){
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 6;
    td.className = 'small';
    td.textContent = 'Nenhum item adicionado.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  } else {
    const frag = document.createDocumentFragment();
    orc.itens.forEach((it, idx) => {
      it.total_c = mulCents(Number(it.preco_c)||0, Number(it.qtd)||0);
      subtotal_c += it.total_c;
      const tr = document.createElement('tr');
      if(withFlash) tr.classList.add('flash');
      // #
      const tdIndex = document.createElement('td');
      tdIndex.textContent = String(idx+1);
      tr.appendChild(tdIndex);
      // nome e cod
      const tdNome = document.createElement('td');
      tdNome.className = 'rowleft';
      tdNome.innerHTML = `${escapeHTML(it.nome)} <span class="small">(${escapeHTML(it.cod)})</span>`;
      tr.appendChild(tdNome);
      // qtd
      const tdQtd = document.createElement('td');
      tdQtd.textContent = String(it.qtd);
      tr.appendChild(tdQtd);
      // pre√ßo
      const tdPreco = document.createElement('td');
      tdPreco.textContent = 'R$ ' + centsToBR(it.preco_c);
      tr.appendChild(tdPreco);
      // total
      const tdTot = document.createElement('td');
      tdTot.textContent = 'R$ ' + centsToBR(it.total_c);
      tr.appendChild(tdTot);
      // remover
      const tdRem = document.createElement('td');
      const btnRem = document.createElement('button');
      btnRem.className = 'danger';
      btnRem.textContent = 'Remover';
      btnRem.onclick = function(){ removerItemOrc(idx); };
      tdRem.appendChild(btnRem);
      tr.appendChild(tdRem);
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
  }
  // M√£o de obra apenas se habilitada nas prefer√™ncias
  let mao_c = 0;
  try{
    mao_c = (db._meta && db._meta.maoObraEnabled) ? Math.max(0, parseMoneyToCents($("o_servico")?.value)) : 0;
  }catch(_e){ mao_c = 0; }
  const total_c = addCents(subtotal_c, mao_c);
  const itensEl = $("o_itens");
  if(itensEl) itensEl.textContent = String(orc.itens.reduce((a,b) => a + b.qtd, 0));
  const subEl = $("o_sub");
  if(subEl) subEl.textContent = centsToBR(subtotal_c);
  const maoEl = $("o_mao");
  if(maoEl) maoEl.textContent = centsToBR(mao_c);
  const totalEl = $("o_total");
  if(totalEl) totalEl.textContent = centsToBR(total_c);
}

/* ========== PDF Or√ßamento (mantido) ========== */
function gerarOrcamentoPDF(){
  try{
    // Permite gera√ß√£o de or√ßamento apenas com m√£o de obra quando n√£o h√° itens. Caso
    // nenhum item seja adicionado e a m√£o de obra seja zero ou n√£o esteja habilitada,
    // exibe aviso e cancela a gera√ß√£o.
    let _maoTmp = 0;
    try{
      _maoTmp = (db._meta && db._meta.maoObraEnabled) ? Math.max(0, parseMoneyToCents($("o_servico")?.value)) : 0;
    }catch(_e){ _maoTmp = 0; }
    if(orc.itens.length === 0 && _maoTmp <= 0){
      toast("Adicione pelo menos 1 item ou m√£o de obra ao or√ßamento.", "warn");
      return;
    }

    const empNome = s(db.empresa?.nome) || "Empresa n√£o configurada";
    const empCnpj = s(db.empresa?.cnpj) || "-";
    const empContato = s(db.empresa?.contato) || "-";
    const empEndereco = s(db.empresa?.endereco) || "";
    const empCelular = s(db.empresa?.celular) || "";
    const empEmail = s(db.empresa?.email) || "";
    // Define uma marca de logotipo em base64 para uso no PDF (ou vazio se n√£o houver)
    const empLogo = db.empresa && db.empresa.logo ? `<img src="${db.empresa.logo}" alt="Logo" style="max-height:60px; margin-right:10px;">` : "";

    const cliente = s($("o_cliente")?.value);
    const contatoCli = s($("o_contato")?.value);
    const obs = s($("o_obs")?.value);

    let validade = Number($("o_validade")?.value);
    if(!Number.isFinite(validade) || validade <= 0) validade = 7;

    // M√£o de obra apenas quando preferida; caso contr√°rio, zero
    let mao_c = 0;
    try{
      mao_c = (db._meta && db._meta.maoObraEnabled) ? Math.max(0, parseMoneyToCents($("o_servico")?.value)) : 0;
    }catch(_e){ mao_c = 0; }
    const subtotal_c = orc.itens.reduce((sum,it)=> sum + mulCents(Number(it.preco_c)||0, Number(it.qtd)||0), 0);
    const total_c = addCents(subtotal_c, mao_c);

    // Define o n√∫mero do or√ßamento. Se estivermos editando um or√ßamento existente,
    // reutiliza o mesmo n√∫mero; caso contr√°rio, gera um novo com timestamp.
    let numero = "ORC-" + Date.now();
    if(editingOrcId){
      try{
        const lista = Array.isArray(db.orcamentos) ? db.orcamentos : [];
        const found = lista.find(o => String(o.id) === String(editingOrcId));
        if(found && found.numero) numero = String(found.numero);
      }catch(_ignore){}
    }
    const dataAgora = new Date();
    const dataStr = dataAgora.toLocaleString();
    const validadeStr = new Date(dataAgora.getTime() + validade*24*60*60*1000).toLocaleDateString();

    // Armazena o or√ßamento no banco local para permitir aprova√ß√£o posterior. Cada
    // or√ßamento salva informa√ß√µes essenciais como n√∫mero, data, cliente, lista de itens,
    // valores e status inicial 'pendente'. Um identificador √∫nico (id) √© gerado com
    // makeId() para refer√™ncia futura. Ap√≥s adicionar, chama save() para persistir.
    try{
      // Monta objeto do or√ßamento para salvar/atualizar. Usa id existente se
      // estivermos editando, caso contr√°rio gera um novo id. Ao editar,
      // preserva data de cria√ß√£o, status e timestamps relevantes do or√ßamento
      const orcObj = {
        id: editingOrcId ? editingOrcId : makeId(),
        numero: numero,
        data: dataStr,
        createdAt: editingOrcId ? (function(){
          const idx = Array.isArray(db.orcamentos) ? db.orcamentos.findIndex(o => String(o.id) === String(editingOrcId)) : -1;
          return idx >= 0 ? db.orcamentos[idx].createdAt : (typeof dataAgora.toISOString === 'function' ? dataAgora.toISOString() : dataStr);
        })() : (typeof dataAgora.toISOString === 'function' ? dataAgora.toISOString() : dataStr),
        cliente: cliente,
        contato: contatoCli,
        obs: obs,
        validade: validade,
        itens: orc.itens.map(function(it){ return {
          cod: it.cod,
          nome: it.nome,
          qtd: Number(it.qtd),
          preco_c: Number(it.preco_c),
          total_c: mulCents(Number(it.preco_c), Number(it.qtd))
        }; }),
        subtotal_c: subtotal_c,
        mao_c: mao_c,
        total_c: total_c,
        status: 'pendente'
      };
      if(!Array.isArray(db.orcamentos)) db.orcamentos = [];
      if(editingOrcId){
        // Atualiza or√ßamento existente
        const idx = db.orcamentos.findIndex(o => String(o.id) === String(editingOrcId));
        if(idx >= 0){
          // Mant√©m status e data de aprova√ß√£o, se existirem
          orcObj.status = db.orcamentos[idx].status || 'pendente';
          if(db.orcamentos[idx].approvedAt) orcObj.approvedAt = db.orcamentos[idx].approvedAt;
          db.orcamentos[idx] = orcObj;
        } else {
          db.orcamentos.push(orcObj);
        }
      } else {
        db.orcamentos.push(orcObj);
      }
      save();
      // Atualiza lista de or√ßamentos caso a se√ß√£o esteja aberta
      if(typeof renderOrcamentos === 'function'){
        try{ renderOrcamentos(); }catch(__){ }
      }
      // Limpa estado de edi√ß√£o ap√≥s salvar
      editingOrcId = null;
    }catch(__err){ console.warn('erro ao salvar or√ßamento', __err); }

    // Monta as linhas da tabela de itens para o PDF. Al√©m dos itens do
    // or√ßamento, adiciona uma linha extra para a m√£o de obra quando existir.
    const rowsPdfArr = [];
    orc.itens.forEach(function(it, idx){
      rowsPdfArr.push(
        `<tr>
          <td style="padding:8px;border:1px solid #222;text-align:center;">${idx+1}</td>
          <td style="padding:8px;border:1px solid #222;">${escapeHTML(it.nome)} (${escapeHTML(it.cod)})</td>
          <td style="padding:8px;border:1px solid #222;text-align:center;">${it.qtd}</td>
          <td style="padding:8px;border:1px solid #222;text-align:right;">R$ ${centsToBR(it.preco_c)}</td>
          <td style="padding:8px;border:1px solid #222;text-align:right;">R$ ${centsToBR(mulCents(it.preco_c,it.qtd))}</td>
        </tr>`
      );
    });
    if(mao_c > 0){
      const idx = orc.itens.length + 1;
      rowsPdfArr.push(
        `<tr>
          <td style="padding:8px;border:1px solid #222;text-align:center;">${idx}</td>
          <td style="padding:8px;border:1px solid #222;">M√£o de obra</td>
          <td style="padding:8px;border:1px solid #222;text-align:center;">1</td>
          <td style="padding:8px;border:1px solid #222;text-align:right;">R$ ${centsToBR(mao_c)}</td>
          <td style="padding:8px;border:1px solid #222;text-align:right;">R$ ${centsToBR(mao_c)}</td>
        </tr>`
      );
    }
    const rowsPdf = rowsPdfArr.join("");

    const html = `<!doctype html>
<html lang="pt-br"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>${numero}</title>
<style>
  body{font-family:Arial, sans-serif; margin:28px; color:#111;}
  .top{display:flex; justify-content:space-between; gap:20px; align-items:flex-start; flex-wrap:wrap;}
  h1{margin:0; font-size:20px;}
  .box{border:1px solid #222; padding:12px; border-radius:10px;}
  table{width:100%; border-collapse:collapse; margin-top:14px; font-size:13px;}
  .right{text-align:right}
  .muted{color:#444; font-size:12px}
  .totais{margin-top:14px; display:flex; justify-content:flex-end;}
  .totais .box{min-width:280px}
  .linha{margin-top:26px; display:flex; gap:18px; flex-wrap:wrap;}
  .assin{flex:1; min-width:240px; text-align:center;}
  .assin .traco{border-top:1px solid #222; margin-top:42px;}
  .noPrint{margin-top:18px;}
  @media print{ .noPrint{display:none} }
</style></head>
<body>
    <div class="top">
      <div>
        <h1>Or√ßamento</h1>
        <div class="muted"><b>${numero}</b></div>
        <div class="muted">Data/Hora: ${escapeHTML(dataStr)}</div>
        <div class="muted">Validade: ${validade} dia(s) ‚Ä¢ at√© ${escapeHTML(validadeStr)}</div>
      </div>
      <!-- Bloco da empresa: exibe logotipo (se houver) e dados do neg√≥cio lado a lado -->
      <div class="box" style="display:flex; align-items:flex-start; gap:10px;">
        ${empLogo}
        <div>
          <b>${escapeHTML(empNome)}</b><br>
          CNPJ: ${escapeHTML(empCnpj)}<br>
          Contato: ${escapeHTML(empContato)}${empEndereco ? '<br>' + escapeHTML(empEndereco) : ''}${empCelular ? '<br>Celular: ' + escapeHTML(empCelular) : ''}${empEmail ? '<br>Email: ' + escapeHTML(empEmail) : ''}
        </div>
      </div>
    </div>

  <div class="box" style="margin-top:14px;">
    <b>Cliente:</b> ${cliente ? escapeHTML(cliente) : "-"}<br>
    <b>Contato:</b> ${contatoCli ? escapeHTML(contatoCli) : "-"}<br>
    ${obs ? `<div style="margin-top:8px;"><b>Observa√ß√µes:</b> ${escapeHTML(obs)}</div>` : ""}
  </div>

  <table>
    <thead>
      <tr>
        <th style="padding:8px;border:1px solid #222;">#</th>
        <th style="padding:8px;border:1px solid #222; text-align:left;">Descri√ß√£o</th>
        <th style="padding:8px;border:1px solid #222;">Qtd</th>
        <th style="padding:8px;border:1px solid #222;" class="right">Valor</th>
        <th style="padding:8px;border:1px solid #222;" class="right">Total</th>
      </tr>
    </thead>
    <tbody>${rowsPdf}</tbody>
  </table>

  <div class="totais">
    <div class="box">
      <div><b>Qtd itens:</b> ${orc.itens.reduce((a,b)=>a + b.qtd, 0)}</div>
      <div><b>Subtotal:</b> R$ ${centsToBR(subtotal_c)}</div>
      <div><b>M√£o de obra:</b> R$ ${centsToBR(mao_c)}</div>
      <hr>
      <div style="font-size:16px;"><b>Total:</b> R$ ${centsToBR(total_c)}</div>
    </div>
  </div>

  <div class="linha">
    <div class="assin"><div class="traco"></div><div class="muted">Assinatura do Cliente</div></div>
    <div class="assin"><div class="traco"></div><div class="muted">Assinatura da Empresa</div></div>
  </div>

  <div class="noPrint">
    <button onclick="window.print()">Imprimir / Salvar PDF</button>
    <button onclick="window.close()">Fechar</button>
  </div>
</body></html>`;

    const blob = new Blob([html], { type: "text/html;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const w = window.open(url, "_blank");
    if(!w){
      const a = document.createElement("a");
      a.href = url;
      a.download = `${numero}.html`;
      a.click();
      toast("Pop-up bloqueado. Baixei o or√ßamento em HTML (abra e imprima como PDF).", "warn");
      setTimeout(()=>URL.revokeObjectURL(url), 12000);
      return;
    }

    toast("Or√ßamento aberto! Clique em 'Imprimir / Salvar PDF'.", "ok");
    setTimeout(()=>URL.revokeObjectURL(url), 12000);

  }catch(e){
    console.error(e);
    toast("Falha ao gerar or√ßamento. Veja o console (F12).", "bad");
  }
}

/* ========== Save/Load (Arquivo) ========== */
const DB_SCHEMA_VERSION = 2;

function saveToFile(){
  // Verificar permiss√£o antes de exportar
  if(currentUser && !hasPerm('exportImportBackup')){
    toast('Sem permiss√£o para exportar backups.', 'bad');
    return;
  }
  try{
    const data = normalizeDB(JSON.parse(JSON.stringify(db)));
    data._meta.schema = DB_SCHEMA_VERSION;
    data._meta.savedAt = new Date().toISOString();
    data._meta.moneyMode = "cents";

    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], {type:"application/json"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;

    const dt = new Date();
    const y = dt.getFullYear();
    const m = String(dt.getMonth()+1).padStart(2,"0");
    const d = String(dt.getDate()).padStart(2,"0");
    const hh = String(dt.getHours()).padStart(2,"0");
    const mm = String(dt.getMinutes()).padStart(2,"0");

    a.download = `erp_save_${y}-${m}-${d}_${hh}-${mm}.json`;
    a.click();

    toast("Save gerado! Arquivo baixado.", "ok");
    setTimeout(()=>URL.revokeObjectURL(url), 8000);
  }catch(e){
    console.error(e);
    toast("Falha ao gerar o save.", "bad");
  }
}
function openLoad(){
  // Verificar permiss√£o antes de importar
  if(currentUser && !hasPerm('exportImportBackup')){
    toast('Sem permiss√£o para importar backups.', 'bad');
    return;
  }
  const inp = $("loadFile");
  if(!inp){ toast("Input de arquivo n√£o encontrado (#loadFile).", "bad"); return; }
  inp.value = "";
  inp.click();
}
function loadFromObject(obj){
  try{
    // Validar o objeto antes de carreg√°‚Äëlo
    const issues = validateDB(obj);
    let proceed = true;
    if(issues && issues.length){
      proceed = confirm(`Alguns problemas foram detectados no arquivo importado:\n${issues.join('\n')}\nDeseja continuar e tentar corrigir automaticamente?`);
    }
    if(!proceed) return;
    // Normaliza e corrige campos faltantes
    db = normalizeDB(obj);
    // Sincronizar configura√ß√µes de lucro/arredondamento do metadata importado
    try{
      const meta = db && db._meta;
      if(meta){
        if(meta.profitMode === 'margin' || meta.profitMode === 'markup') profitMode = meta.profitMode;
        if(['none','0.99','0.90','integer'].includes(meta.profitRound)) profitRound = meta.profitRound;
      }
    }catch(_e){}
    save();

    // Ap√≥s carregar o banco, verificar se o usu√°rio atual ainda existe
    if(currentUser){
      const ok = (db.usuarios||[]).some(u => s(u.user)===s(currentUser.user) && s(u.pass)===s(currentUser.pass));
      if(!ok){
        currentUser = null;
        $("systemSection").style.display="none";
        $("loginSection").style.display="block";
        toast("Backup importado. Fa√ßa login novamente.", "warn");
        render(true);
        return;
      }
    }

    render(true);
    toast("Backup importado com sucesso!", "ok");
  }catch(e){
    console.error(e);
    toast("Falha ao carregar backup.", "bad");
  }
}

// Restaura o banco de dados a partir do backup autom√°tico mais recente. Ao finalizar,
// o banco √© salvo novamente e a interface √© renderizada. Caso n√£o exista
// backup dispon√≠vel, mostra uma mensagem ao usu√°rio.
function restoreLastBackupUI(){
  // Verificar permiss√£o antes de restaurar backup
  if(currentUser && !hasPerm('exportImportBackup')){
    toast('Sem permiss√£o para restaurar backups.', 'bad');
    return;
  }
  const ok = restoreLatestBackup();
  if(ok){
    save();
    // Sincronizar configura√ß√µes de lucro a partir do metadata restaurado
    try{
      const meta = db && db._meta;
      if(meta){
        if(meta.profitMode === 'margin' || meta.profitMode === 'markup') profitMode = meta.profitMode;
        if(['none','0.99','0.90','integer'].includes(meta.profitRound)) profitRound = meta.profitRound;
      }
    }catch(_e){}
    render(true);
    toast("Backup restaurado com sucesso.", "ok");
  }else{
    toast("Nenhum backup autom√°tico dispon√≠vel para restaurar.", "bad");
  }
}

// Exporta as vendas registradas para um arquivo CSV. O arquivo conter√°
// colunas para identificador, data, c√≥digo do produto, nome, quantidade,
// valor de servi√ßo, total da venda, formas de pagamento, descontos,
// lucro obtido, flag de cancelamento e identificador de grupo. Os valores
// monet√°rios s√£o convertidos para o formato brasileiro (ex.: 12,34). O
// arquivo gerado √© baixado automaticamente no navegador.
function exportarCSVVendas(){
  // Verificar permiss√£o antes de exportar relat√≥rios
  if(currentUser && !hasPerm('exportImportBackup')){
    toast('Sem permiss√£o para exportar CSV.', 'bad');
    return;
  }
  try{
    const header = [
      'id','data','cod','nome','qtd','servico','total','pag','pag2','pag2_val','descItem_p','descTotal_p','lucro','cancelada','groupId'
    ];
    const rows = [];
    rows.push(header.join(';'));
    (db.vendas || []).forEach(v => {
      const id = v.id || '';
      const dt = v.data || '';
      const cod = v.cod || '';
      const nome = v.nome || '';
      const qtd = Number(v.qtd) || 0;
      const servico = centsToBR(Number(v.servico_c || 0));
      const total = centsToBR(Number(v.total_c || 0));
      const pag = v.pag || '';
      const pag2 = v.pag2 || '';
      const pag2Val = v.pag2_val_c ? centsToBR(Number(v.pag2_val_c)) : '';
      const descItem = typeof v.descItem_p !== 'undefined' ? v.descItem_p : '';
      const descTotal = typeof v.descTotal_p !== 'undefined' ? v.descTotal_p : '';
      const lucro = centsToBR(Number(v.lucro_c || 0));
      const cancelada = v.cancelada ? 'sim' : 'n√£o';
      const groupId = v.groupId || '';
      rows.push([
        id, dt, cod, nome, qtd, servico, total, pag, pag2, pag2Val,
        descItem, descTotal, lucro, cancelada, groupId
      ].map(String).join(';'));
    });
    const csv = rows.join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const now = new Date();
    const y = now.getFullYear();
    const m = String(now.getMonth()+1).padStart(2,'0');
    const d = String(now.getDate()).padStart(2,'0');
    const hh = String(now.getHours()).padStart(2,'0');
    const mm = String(now.getMinutes()).padStart(2,'0');
    a.download = `vendas_${y}-${m}-${d}_${hh}${mm}.csv`;
    a.click();
    // revogar URL ap√≥s algum tempo para liberar mem√≥ria
    setTimeout(() => URL.revokeObjectURL(url), 10000);
    toast('CSV de vendas exportado.', 'ok');
  } catch(e){
    console.error(e);
    toast('Falha ao exportar CSV.', 'bad');
  }
}
(function(){
  const inp = $("loadFile");
  if(!inp) return;
  inp.addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    // Leitura e parse segura do arquivo
    let text;
    try{
      text = await file.text();
    }catch(err){
      console.error(err);
      toast('Falha ao ler o arquivo selecionado.', 'bad');
      return;
    }
    let obj;
    try{
      obj = JSON.parse(text);
    }catch(err){
      console.error(err);
      toast('Arquivo inv√°lido ou corrompido (JSON).', 'bad');
      return;
    }
    // Verifica se a funcionalidade de ServerSync est√° ativa
    const canMerge = window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableServerSync && window.Update && Update.integrations && Update.integrations.serverSync;
    if(canMerge){
      const replace = confirm('Clique OK para SUBSTITUIR os dados atuais ou Cancelar para MESCLAR (somar/complementar) o estoque.');
      if(replace){
        loadFromObject(obj);
        return;
      }
      try{
        const cur = Update.storage.db_core.get();
        const { db: mergedDB, report } = Update.integrations.serverSync.mergeImportedFile(cur, obj, { prefer: 'current', sumStockQty: true });
        // Aplicar a fus√£o utilizando a rotina padr√£o de importa√ß√£o para normaliza√ß√£o e persist√™ncia
        loadFromObject(mergedDB);
        toast('Backup mesclado com sucesso! Detalhes no console.', 'ok');
        console.log('Relat√≥rio de merge import:', report);
      }catch(err2){
        console.error(err2);
        toast('Falha ao mesclar o backup importado.', 'bad');
      }
    } else {
      // Comportamento legado: somente substituir
      if(!confirm('Carregar este save vai substituir os dados atuais. Deseja continuar?')) return;
      loadFromObject(obj);
    }
  });
})();

// ESC fecha o PDV/Scanner (modal scannerOverlay)
document.addEventListener('keydown', function(e){
  if(e.key !== 'Escape') return;
  const overlay = document.getElementById('scannerOverlay');
  if(overlay && overlay.style.display !== 'none'){
    try{ closeScanOverlay(); }catch(_){}
  }
});

/* ========== Render ========== */
function flashTableRows(tbodyId){
  const tb = $(tbodyId);
  if(!tb) return;
  const rows = tb.querySelectorAll("tr");
  rows.forEach(r=>{
    r.classList.remove("flash");
    void r.offsetWidth;
    r.classList.add("flash");
  });
}

function render(withFlash=false){
  setEstoqueModeUI();

  const tEstoque = $("tEstoque");
  const tAlertas = $("tAlertas");
  const d_alertInfo = $("d_alertInfo");
  let alertas = [];

  // =========================
  // ESTOQUE (tabela principal)
  // =========================
  if(tEstoque){
    // Construir lista de alertas de estoque baixo a partir da lista completa (n√£o filtrada)
    const fullList = (db.estoque || []);
    alertas = [];
    fullList.forEach(p => {
      const min = clampInt(p.min,0);
      const qtd = clampInt(p.qtd,0);
      if(qtd <= min) alertas.push(p);
    });

    // Aplicar filtros de busca, filtros r√°pidos e ordena√ß√£o na lista
    let list = fullList.filter(p => {
      // Busca: cada termo deve aparecer no c√≥digo ou nome (ignorando acentos)
      const codNorm  = removeAccents(p.cod || "");
      const nomeNorm = removeAccents(p.nome || "");
      for(const term of estoqueSearchTerms){
        if(!term) continue;
        if(!codNorm.includes(term) && !nomeNorm.includes(term)) return false;
      }
      // Filtro abaixo do m√≠nimo
      if(estoqueFilters.belowMin){
        const qtd = clampInt(p.qtd,0);
        const min = clampInt(p.min,0);
        if(qtd > min) return false;
      }
      // Filtro lucro negativo
      if(estoqueFilters.negProfit){
        if((p.preco_c - p.custo_c) >= 0) return false;
      }
      // Filtro sem pre√ßo
      if(estoqueFilters.noPrice){
        if(p.preco_c > 0) return false;
      }
      // Filtro sem custo
      if(estoqueFilters.noCost){
        if(p.custo_c > 0) return false;
      }
      return true;
    });

    // Ordena√ß√£o
    list.sort((a,b) => {
      let va, vb;
      switch(estoqueSortField){
        case 'cod':
          va = String(a.cod || '').toLowerCase(); vb = String(b.cod || '').toLowerCase();
          break;
        case 'nome':
          va = String(a.nome || '').toLowerCase(); vb = String(b.nome || '').toLowerCase();
          break;
        case 'qtd':
          va = clampInt(a.qtd,0); vb = clampInt(b.qtd,0);
          break;
        case 'min':
          va = clampInt(a.min,0); vb = clampInt(b.min,0);
          break;
        case 'custo':
          va = a.custo_c || 0; vb = b.custo_c || 0;
          break;
        case 'preco':
          va = a.preco_c || 0; vb = b.preco_c || 0;
          break;
        case 'lucro':
          va = (a.preco_c - a.custo_c); vb = (b.preco_c - b.custo_c);
          break;
        case 'added':
          // ordena pela data de adi√ß√£o; se o valor estiver ausente, assume 0
          va = a.added || 0; vb = b.added || 0;
          break;
        default:
          va = 0; vb = 0;
      }
      if(va < vb) return -1 * estoqueSortDir;
      if(va > vb) return 1 * estoqueSortDir;
      return 0;
    });

    // Pagina√ß√£o
    const totalPages = Math.max(1, Math.ceil(list.length / ESTOQUE_PAGE_SIZE));
    if(estoquePage > totalPages) estoquePage = totalPages;
    const startIndex = (estoquePage - 1) * ESTOQUE_PAGE_SIZE;
    const pageList = list.slice(startIndex, startIndex + ESTOQUE_PAGE_SIZE);
    buildEstoquePagination(totalPages);

    // Construir o corpo da tabela
    const frag = document.createDocumentFragment();
    pageList.forEach(p => {
      const tr = document.createElement('tr');
      if(withFlash) tr.classList.add('flash');
      const min = clampInt(p.min, 0);
      const qtd = clampInt(p.qtd, 0);
      // Determina o status do estoque
      const isLow = qtd <= min;
      const statusSpan = document.createElement('span');
      statusSpan.className = isLow ? 'bad' : 'ok';
      statusSpan.textContent = isLow ? 'BAIXO' : 'OK';
      const lucroUnit_c = p.preco_c - p.custo_c;
      // calcula a porcentagem de lucro (markup) com base no custo e pre√ßo atuais
      let lucroPct = 0;
      if(typeof p.lucro_p !== "undefined" && p.lucro_p !== null){
        lucroPct = Number(p.lucro_p);
      }else{
        if(p.custo_c > 0){
          lucroPct = ((p.preco_c - p.custo_c) / p.custo_c) * 100;
        }
      }
      // Criar c√©lulas com destaque nas buscas
      const tdCod  = document.createElement('td');
      tdCod.innerHTML = highlightMatches(p.cod);
      const tdNome = document.createElement('td');
      tdNome.className = 'rowleft';
      tdNome.innerHTML = highlightMatches(p.nome);
      const tdQtd  = document.createElement('td');
      tdQtd.textContent = qtd;
      const tdMin  = document.createElement('td');
      tdMin.textContent = min;
      const tdStatus = document.createElement('td');
      tdStatus.appendChild(statusSpan);
      const tdCusto = document.createElement('td');
      tdCusto.textContent = `R$ ${centsToBR(p.custo_c)}`;
      const tdPreco = document.createElement('td');
      tdPreco.textContent = `R$ ${centsToBR(p.preco_c)}`;
      const tdLucro = document.createElement('td');
      // Define a classe de acordo com o sinal do lucro unit√°rio (positivo ou negativo)
      tdLucro.className = lucroUnit_c >= 0 ? 'ok' : 'bad';
      // Constr√≥i a string de porcentagem de lucro somente quando a visualiza√ß√£o de % estiver ativa.
      const pctStr = showLucroPct ? ` (${Number.isFinite(lucroPct) ? lucroPct.toFixed(2) : '0'}%)` : '';
      // Calcula o lucro total e o custo total do estoque atual (unit√°rio √ó quantidade)
      const lucroTot_c = lucroUnit_c * qtd;
      const custoTot_c = p.custo_c * qtd;
      // Se a visualiza√ß√£o de % estiver habilitada, exibe tamb√©m o lucro total e o custo total em uma linha menor.
      if(showLucroPct){
        tdLucro.innerHTML =
          `R$ ${centsToBR(lucroUnit_c)}${pctStr}` +
          `<br><small>Lucro: R$ ${centsToBR(lucroTot_c)} | Custo: R$ ${centsToBR(custoTot_c)}</small>`;
      }else{
        // Caso contr√°rio, mant√©m apenas o lucro unit√°rio.
        tdLucro.textContent = `R$ ${centsToBR(lucroUnit_c)}`;
      }
      const tdAcoes = document.createElement('td');
      const btnEdit = document.createElement('button');
      btnEdit.className = 'ghost';
      btnEdit.textContent = 'Editar';
      btnEdit.onclick = () => startEditProduto(p.cod);
      const btnDel = document.createElement('button');
      btnDel.className = 'danger';
      btnDel.textContent = 'Apagar';
      btnDel.onclick = () => deleteProduto(p.cod);
      tdAcoes.appendChild(btnEdit);
      tdAcoes.appendChild(btnDel);
      tr.appendChild(tdCod);
      tr.appendChild(tdNome);
      tr.appendChild(tdQtd);
      tr.appendChild(tdMin);
      tr.appendChild(tdStatus);
      tr.appendChild(tdCusto);
      tr.appendChild(tdPreco);
      tr.appendChild(tdLucro);
      tr.appendChild(tdAcoes);
      frag.appendChild(tr);
    });
    // Limpar e inserir fragmento
    tEstoque.innerHTML = '';
    tEstoque.appendChild(frag);
    if(withFlash) flashTableRows('tEstoque');
  }

  filtrarProdutosVenda();
  filtrarProdutosCarrinho();
  renderCarrinho(withFlash);

  // Atualiza selects de modo de lucro e arredondamento conforme as configura√ß√µes atuais
  const pmSel = $("profitMode");
  if(pmSel) pmSel.value = profitMode;
  const prSel = $("profitRound");
  if(prSel) prSel.value = profitRound;
  // Atualiza o t√≠tulo da coluna de lucro para mostrar o modo ativo (Markup ou Margem)
  const thLuc = $("thLucro");
  if(thLuc){
    const lbl = profitMode === 'margin' ? 'Lucro (Margem)' : 'Lucro (Markup)';
    thLuc.textContent = lbl;
  }

  if(tAlertas){
    tAlertas.innerHTML = alertas.map(p=>{
      const min = clampInt(p.min,0);
      const qtd = clampInt(p.qtd,0);
      return `<tr ${withFlash ? 'class="flash"' : ''}><td>${escapeHTML(p.cod)}</td><td class="rowleft">${escapeHTML(p.nome)}</td><td>${qtd}</td><td>${min}</td></tr>`;
    }).join("");
    if(withFlash) flashTableRows("tAlertas");
  }
  if(d_alertInfo){
    d_alertInfo.textContent = alertas.length ? `${alertas.length} item(ns) abaixo do m√≠nimo.` : "Nenhum alerta üéâ";
  }

  const tVendas = $("tVendas");
  let fat_c = 0, luc_c = 0, vendasOkCount = 0;

  if(tVendas){
    const vendasList = (db.vendas || []).slice().sort(function(a,b){
      try{
        const da = new Date(a.data);
        const dbb = new Date(b.data);
        return vendasOrderDesc ? (dbb - da) : (da - dbb);
      }catch(_e){ return 0; }
    });
    tVendas.innerHTML = vendasList.map(v=>{
      const cancelada = !!v.cancelada;
      const status = cancelada ? '<span class="bad">CANCELADA</span>' : '<span class="ok">OK</span>';

      const total_c = moneyOf(v,"total_c","total");
      const lucro_c = moneyOf(v,"lucro_c","lucro");

      if(!cancelada){
        fat_c += total_c;
        luc_c += lucro_c;
        vendasOkCount++;
      }

      const btn = cancelada
        ? '<button class="ghost" disabled>Cancelada</button>'
        : `<button class="danger" onclick="cancelarVenda(${Number(v.id)})">Cancelar</button>`;

      return `<tr ${withFlash ? 'class="flash"' : ''}>
        <td>${escapeHTML(v.data)}</td>
        <td class="rowleft">${escapeHTML(v.nome)}</td>
        <td>${clampInt(v.qtd,0)}</td>
        <td>R$ ${centsToBR(total_c)}</td>
        <td>${escapeHTML(v.pag)}</td>
        <td>${status}</td>
        <td>${btn}</td>
      </tr>`;
    }).join("");
    if(withFlash) flashTableRows("tVendas");
  }

  if($("d_fat")) $("d_fat").textContent = centsToBR(fat_c);
  if($("d_lucro")) $("d_lucro").textContent = centsToBR(luc_c);
  if($("d_vendas")) $("d_vendas").textContent = String(vendasOkCount);
  if($("d_ticket")) $("d_ticket").textContent = centsToBR(vendasOkCount ? Math.round(fat_c / vendasOkCount) : 0);

  const tUsers = $("tUsers");
  if(tUsers){
    let lista = db.usuarios || [];
    if(currentUser){
      if(currentUser.role === "admin"){
        lista = lista.filter(u => s(u.user) === s(currentUser.user) || s(u.owner) === s(currentUser.user));
      }else{
        lista = lista.filter(u => s(u.user) === s(currentUser.user));
      }
    }
    tUsers.innerHTML = lista.map(function(u){
      var actions = '';
      if(hasPerm('manageUsers')){
        actions += "<button class=\"button-secondary\" onclick=\"editUser('" + escapeHTML(u.user) + "')\">Editar</button> ";
        actions += "<button class=\"button-secondary\" onclick=\"toggleUserActive('" + escapeHTML(u.user) + "')\">" + (u.ativo ? 'Desativar' : 'Ativar') + "</button> ";
        actions += "<button class=\"button-secondary\" onclick=\"resetUserPass('" + escapeHTML(u.user) + "')\">Resetar Senha</button>";
      }
      var cls = withFlash ? 'class="flash"' : '';
      return '<tr ' + cls + '><td>' + escapeHTML(u.user) + '</td><td>' + escapeHTML(u.role) + '</td><td>' + actions + '</td></tr>';
    }).join('');
    if(withFlash) flashTableRows("tUsers");
  }

  const d_caixa_status = $("d_caixa_status");
  if(d_caixa_status){
    d_caixa_status.textContent = db.caixaAberto ? "ABERTO" : "FECHADO";
    d_caixa_status.className = db.caixaAberto ? "ok" : "bad";
  }
  const v_caixa_badge = $("v_caixa_badge");
  if(v_caixa_badge){
    v_caixa_badge.textContent = db.caixaAberto ? "ABERTO" : "FECHADO";
    v_caixa_badge.className = db.caixaAberto ? "ok" : "bad";
  }

  renderPerfilView();
  renderGraficos();
  aplicarRestricoesPorPerfil();

  // Renderiza√ß√£o adicional: agenda, devedores e notas (ferramentas extras)
  try{
    renderAgenda();
  }catch(e){}
  try{
    renderDevedores();
  }catch(e){}
  // Dashboard: atualizar o bloco de devedores em aberto com m√©tricas e gr√°fico simples
  try{
    renderDevedorDashboard();
  }catch(e){}
  try{
    renderNotes();
  }catch(e){}
  try{
    renderTodos();
  }catch(e){}

  // Ap√≥s renderizar todos os componentes, ajusta a interface conforme as prefer√™ncias do usu√°rio
  applyPreferencesUI();

  // Atualizar o hist√≥rico de caixa a cada render
  try{
    if(typeof renderCaixaTable === 'function') renderCaixaTable();
  }catch(_err){}
  updatePreferenceUI();
}

/* ========== Listeners ========== */
document.addEventListener("keydown", (e)=>{
  if(e.key === "Escape"){
    // Fecha or√ßamento se estiver aberto
    const oc = $("orcCard");
    if(oc && oc.style.display !== "none"){
      fecharOrcamentoUI();
      return;
    }
    // Se estiver no m√≥dulo de scanner, volta √† √∫ltima se√ß√£o visitada
    const scannerSec = $("scanner");
    if(scannerSec && scannerSec.style.display !== "none"){
      if(typeof show === 'function') show(lastSection || 'dashboard');
      return;
    }
  }
});

$("v_busca")?.addEventListener("input", filtrarProdutosVenda);
$("v_busca")?.addEventListener("keydown", (e)=>{ if(e.key === "Enter") $("v_qtd")?.focus(); });

$("v_qtd")?.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){ e.preventDefault(); registrarVenda(); }
});

// Eventos adicionais para a venda r√°pida: calcular troco dinamicamente
$("v_prod")?.addEventListener("change", calcQuickTroco);
$("v_qtd")?.addEventListener("input", calcQuickTroco);
$("v_servico")?.addEventListener("input", calcQuickTroco);
$("v_pag")?.addEventListener("change", calcQuickTroco);
$("v_recebido")?.addEventListener("input", calcQuickTroco);

// Descontos e segundo pagamento tamb√©m afetam o c√°lculo do total e do troco
$("v_desc_item")?.addEventListener("input", calcQuickTroco);
$("v_desc_total")?.addEventListener("input", calcQuickTroco);
// Eventos para segundo pagamento foram removidos do modo de venda r√°pida.

$("c_busca")?.addEventListener("input", filtrarProdutosCarrinho);

$("c_qtd")?.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){ e.preventDefault(); addToCart(); }
});

$("c_servico")?.addEventListener("input", ()=>renderCarrinho(true));
$("c_pag")?.addEventListener("change", ()=>renderCarrinho(true));
$("c_recebido")?.addEventListener("input", ()=>renderCarrinho(false));
// Permite finalizar a venda do carrinho ao pressionar Enter no campo de recebido
$("c_recebido")?.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    try { finalizarCarrinho(); } catch(_e) {}
  }
});

$("o_busca")?.addEventListener("input", renderOrcProdutos);
$("o_qtd")?.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); addItemOrc(); }});
$("o_servico")?.addEventListener("input", ()=>renderOrc(false));

/* ‚úÖ Polida: Enter no login chama doLogin de forma consistente */
$("l_user")?.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); $("l_pass")?.focus(); }});
$("l_pass")?.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); doLogin(); }});

  // Quando o modo smartphone est√° ativo, aplicar r√≥tulos de cabe√ßalhos
  // nos elementos <td> de todas as tabelas renderizadas. Isso garante
  // que listas convertidas em cart√µes tenham r√≥tulos leg√≠veis mesmo
  // ap√≥s atualiza√ß√µes din√¢micas de dados (estoque, vendas, carrinho etc.).
  try{
    if(document.body.classList.contains('smartphone') && typeof adaptTables === 'function'){
      adaptTables();
    }
  }catch(e){ console.warn('adaptTables failed', e); }

/* ========== Tema e Ajustes ==========
   Vari√°veis e fun√ß√µes para alternar temas (claro/escuro) e controlar
   a exibi√ß√£o das sub-se√ß√µes de ajustes. */
const themeVars = {
  default: {
    "--bg":"#070b16",
    "--panel":"#0f1435",
    "--panel2":"#0b1030",
    "--primary":"#2c3dd1",
    "--primary2":"#4257ff",
    "--text":"#f0f0ff",
    "--muted":"#b7c1ff",
    "--border":"#2c3380",
    "--ok":"#4cff9a",
    "--bad":"#ff6b6b",
    "--warn":"#ffcc00",
    "--shadow":"0 12px 35px rgba(0,0,0,.45)",
    "--shadow2":"0 8px 24px rgba(0,0,0,.35)"
  },
  white: {
    /*
      Paleta totalmente redesenhada para o modo claro. Optamos por tons
      extremamente claros e past√©is para aproximar a experi√™ncia de um
      aplicativo moderno: fundo quase branco com leves nuvens azuis,
      pain√©is em branco puro, sombras suaves e textos escuros. As cores
      prim√°rias s√£o um azul m√©dio e um azul mais claro para criar uma
      transi√ß√£o delicada no cabe√ßalho e elementos de destaque.
    */
    "--bg":"#f7f9fb",
    "--panel":"#ffffff",
    "--panel2":"#f3f5fa",
    /* Ajuste de paleta: o modo branco agora utiliza tons de azul mais claros
       para evitar contrastes fortes. Substitu√≠mos o azul escuro padr√£o por
       um azul claro e pastel. */
    "--primary":"#6aa7e6",
    "--primary2":"#90bbe9",
    "--text":"#1d2433",
    "--muted":"#6e7a8a",
    "--border":"#d9dfe9",
    "--ok":"#28a745",
    "--bad":"#dc3545",
    "--warn":"#f0ad4e",
    "--shadow":"0 4px 12px rgba(0,0,0,.06)",
    "--shadow2":"0 2px 6px rgba(0,0,0,.04)"
  }
};

function applyTheme(theme){
  const vars = themeVars[theme] || themeVars.default;
  for(const key in vars){
    document.documentElement.style.setProperty(key, vars[key]);
  }
  // Ajuste o plano de fundo do corpo dependendo do tema. Para o modo
  // branco, usamos um gradiente claro com suaves manchas azuis; no
  // modo padr√£o, removemos qualquer estilo inline para que o CSS
  // original aplique o gradiente escuro. Ao limpar o valor,
  // devolvemos o controle ao CSS definido na folha de estilos.
  if(theme === "white"){
    document.body.style.background =
      "radial-gradient(1200px 800px at 20% 0%, rgba(52,152,219,0.12), transparent 55%),"+
      "radial-gradient(1200px 800px at 80% 20%, rgba(93,173,226,0.12), transparent 55%),"+
      "linear-gradient(180deg, #f9fbff, #eef5ff)";
  }else{
    // remove estilo inline para restabelecer o gradiente padr√£o definido no CSS
    document.body.style.background = "";
  }
  // Persistir tema usando m√©todo seguro para evitar exce√ß√µes no localStorage
  safeLocalSet("erp_theme", theme);
}
function applyThemeFromStorage(){
  const current = safeLocalGet("erp_theme", "default") || "default";
  applyTheme(current);
}
function setTheme(theme){
  applyTheme(theme);
  toast("Tema aplicado!", "ok");
}
function toggleSubAjuste(id){
    const sections = {
    "tema": $("ajusteTema"),
    "arquivo": $("ajusteArquivo"),
    "extras": $("ajusteExtras"),
    "interface": $("ajusteInterface"),
    "comercio": $("ajusteComercio"),
    "despesas": $("ajusteDespesas"),
    // nova se√ß√£o de prefer√™ncias
    "preferencias": $("ajustePreferencias"),
    // nova se√ß√£o financeira (configura√ß√µes de lucro e arredondamento)
    "financeiro": $("ajusteFinanceiro"),
    // nova se√ß√£o de seguran√ßa (sess√£o, tentativas, auditoria)
    "seguranca": $("ajusteSeguranca"),
    // nova se√ß√£o de or√ßamentos salvos
    "orcamentos": $("ajusteOrcamentos")
  };
  for(const k in sections){
    if(sections[k]){
      if(k === id){
        // alterna a visibilidade da se√ß√£o atual
        const show = sections[k].style.display === "none" || sections[k].style.display === "";
        sections[k].style.display = show ? "block" : "none";
        // Se a se√ß√£o de despesas for exibida, renderize a tabela
        if(show && k === 'despesas' && typeof renderDespesasTable === 'function'){
          renderDespesasTable();
        }
        // Se a se√ß√£o financeira for exibida, sincronize os selects com o estado atual
        if(show && k === 'financeiro'){
          const pmSel = $("cfg_profitMode");
          const prSel = $("cfg_profitRound");
          if(pmSel) pmSel.value = profitMode;
          if(prSel) prSel.value = profitRound;
        }
        // Se a se√ß√£o de seguran√ßa for exibida, sincronize os inputs com os valores atuais
        if(show && k === 'seguranca'){
          const st = $("input_session_timeout");
          if(st) st.value = sessionTimeoutMin;
          const lat = $("input_login_attempts");
          if(lat) lat.value = loginAttemptLimit;
        }
        // Se a se√ß√£o de or√ßamentos for exibida, renderize a lista
        if(show && k === 'orcamentos' && typeof renderOrcamentos === 'function'){
          renderOrcamentos();
        }
        // Se a se√ß√£o de prefer√™ncias for exibida, sincronize os selects de dispositivo
        if(show && k === 'preferencias'){
          const scanSel = $("cfg_scanDevice");
          const printerSel = $("cfg_printerDevice");
          if(scanSel && db._meta) scanSel.value = db._meta.scanDevice || 'camera';
          if(printerSel && db._meta) printerSel.value = db._meta.printerDevice || 'default';
        }
      }else{
        // oculta outras se√ß√µes
        sections[k].style.display = "none";
      }
    }
  }
}

/* =========================
   Licenciamento e prote√ß√£o
   ========================= */
// Executa verifica√ß√£o de conectividade e for√ßa recarregamento ap√≥s 24h.
// Armazena o √∫ltimo momento em que houve conex√£o em localStorage (chave 'erp_last_online').
function initLicense(){
  try{
    // Sempre agendar um recarregamento em 24 horas para garantir sincroniza√ß√£o de licen√ßa.
    setTimeout(() => {
      toast('Verificando licen√ßa...', 'info');
      // reload com cache bust para garantir que o usu√°rio carrega a vers√£o mais recente
      location.reload(true);
    }, 24 * 60 * 60 * 1000);
    // Executa verifica√ß√£o inicial
    checkConnectivity();
    // Verifica√ß√£o peri√≥dica a cada 4 horas (outra oportunidade de atualiza√ß√£o de last_online)
    setInterval(() => {
      checkConnectivity();
    }, 4 * 60 * 60 * 1000);
    // Ap√≥s o carregamento completo da p√°gina, refor√ßa a verifica√ß√£o para que o overlay seja aplicado mesmo
    // quando o elemento ainda n√£o existia durante a inicializa√ß√£o
    if(typeof window !== 'undefined'){
      window.addEventListener('load', () => {
        try{ enforceLicense(); }catch(_e){}
      });
    }
  }catch(e){
    console.warn('initLicense error', e);
  }
}

// Tenta realizar um fetch a um recurso p√∫blico para determinar conectividade. Atualiza last_online.
async function checkConnectivity(){
  try{
    // Usamos um recurso que retorna 204 sem corpo para testar a conex√£o. No-cors evita bloqueios CORS.
    await fetch('https://www.gstatic.com/generate_204', { method:'GET', mode:'no-cors', cache:'no-store' });
    // Se o fetch n√£o lan√ßar erro, consideramos online. Atualiza o timestamp.
    updateLastOnline();
  }catch(e){
    // Falha no fetch significa falta de conectividade ou bloqueio por CORS; n√£o atualiza last_online
    console.warn('connectivity check failed');
  }finally{
    enforceLicense();
  }
}

// Atualiza timestamp last_online em localStorage
function updateLastOnline(){
  try{
    // usa grava√ß√£o segura ao atualizar o timestamp para lidar com ambientes onde o localStorage est√° indispon√≠vel
    safeLocalSet('erp_last_online', String(Date.now()));
  }catch(e){
    console.warn('Unable to store last_online', e);
  }
}

// Verifica se a √∫ltima conex√£o est√° dentro de 24h; caso contr√°rio, bloqueia o uso
function enforceLicense(){
  try{
    const overlay = $('licenseBlockOverlay');
    // A verifica√ß√£o de licen√ßa foi desativada: sempre ocultamos o overlay de licen√ßa.
    if(overlay){
      overlay.style.display = 'none';
    }
    // O restante da l√≥gica de verifica√ß√£o de licen√ßa √© ignorado para que apenas a tela de conex√£o indispon√≠vel seja utilizada.
  }catch(e){
    console.warn('enforceLicense error', e);
  }
}

// Permite ao usu√°rio tentar manualmente a verifica√ß√£o de licen√ßa a partir do overlay
function retryLicenseCheck(){
  checkConnectivity();
}

/* =========================
   Prefer√™ncias de Usu√°rio
   ========================= */
// Alterna um booleano nas configura√ß√µes (em db._meta) e atualiza UI
function togglePreference(key){
  try{
    if(!db._meta) db._meta = {};
    const current = db._meta[key];
    db._meta[key] = !current;
    save();
    // Atualiza r√≥tulos dos bot√µes de prefer√™ncias
    updatePreferenceUI();
    // Aplica as prefer√™ncias visuais e de neg√≥cio
    applyPreferencesUI();
    render();
    toast('Prefer√™ncia atualizada.', 'ok');
  }catch(e){
    console.warn('togglePreference error', e);
  }
}

// Atualiza texto dos bot√µes de prefer√™ncias conforme estado atual
function updatePreferenceUI(){
  try{
    const meta = db && db._meta ? db._meta : {};
    const bScan = $('btnToggleScanner');
    if(bScan){
      bScan.textContent = meta.scannerEnabled ? 'Desativar Scanner' : 'Ativar Scanner';
      bScan.classList.toggle('active', !!meta.scannerEnabled);
    }
    const bOrc = $('btnToggleOrcamento');
    if(bOrc){
      bOrc.textContent = meta.orcamentoEnabled ? 'Desativar Or√ßamento' : 'Ativar Or√ßamento';
      bOrc.classList.toggle('active', !!meta.orcamentoEnabled);
    }
    const bMao = $('btnToggleMaoObra');
    if(bMao){
      bMao.textContent = meta.maoObraEnabled ? 'Desativar M√£o de Obra' : 'Ativar M√£o de Obra';
      bMao.classList.toggle('active', !!meta.maoObraEnabled);
    }

    // Novo: Venda R√°pida
    const bQuick = $('btnToggleQuickSale');
    if(bQuick){
      // default: ativa se undefined
      const qs = (meta.quickSaleEnabled !== false);
      bQuick.textContent = qs ? 'Desativar Venda R√°pida' : 'Ativar Venda R√°pida';
      bQuick.classList.toggle('active', qs);
    }
    // Novo: Nota Fiscal em PDF
    const bNfPDF = $('btnToggleNfPDF');
    if(bNfPDF){
      const pdf = !!meta.nf_pdf_enabled;
      bNfPDF.textContent = pdf ? 'Desativar NF em PDF' : 'Ativar NF em PDF';
      bNfPDF.classList.toggle('active', pdf);
    }
    // Novo: Nota Fiscal impressa
    const bNfPrint = $('btnToggleNfPrint');
    if(bNfPrint){
      const pr = !!meta.nf_print_enabled;
      bNfPrint.textContent = pr ? 'Desativar NF Impressa' : 'Ativar NF Impressa';
      bNfPrint.classList.toggle('active', pr);
    }
  }catch(e){
    console.warn('updatePreferenceUI error', e);
  }
}

// Aplica prefer√™ncias na interface (esconde/mostra bot√µes, campos e cards)
function applyPreferencesUI(){
  try{
    const meta = db && db._meta ? db._meta : {};
    // Scanner buttons
    const skEstoque = $('skan_estoque_btn');
    if(skEstoque){
      skEstoque.style.display = meta.scannerEnabled ? '' : 'none';
    }
    const skVenda = $('skan_vendas_btn');
    if(skVenda){
      skVenda.style.display = meta.scannerEnabled ? '' : 'none';
    }
    // Or√ßamento: bot√µes e card
    const orcBtnRapida = $('btnOrcamentoRapida');
    if(orcBtnRapida){
      orcBtnRapida.style.display = meta.orcamentoEnabled ? '' : 'none';
    }
    const orcBtnCart = $('btnOrcamentoCart');
    if(orcBtnCart){
      orcBtnCart.style.display = meta.orcamentoEnabled ? '' : 'none';
    }
    const orcCard = $('orcCard');
    if(orcCard){
      // se desativado, oculta; se ativado, mant√©m de acordo com estado atual
      if(!meta.orcamentoEnabled){
        orcCard.style.display = 'none';
      }
    }
    // Mostrar/ocultar bot√£o e aba de or√ßamentos em Ajustes
    const orcNavBtn = $('btnCfg_orcamentos');
    if(orcNavBtn){
      orcNavBtn.style.display = meta.orcamentoEnabled ? '' : 'none';
    }
    const ajusteOrc = $('ajusteOrcamentos');
    if(ajusteOrc){
      if(!meta.orcamentoEnabled){
        ajusteOrc.style.display = 'none';
      }
    }
    // M√£o de obra: inputs e estat√≠sticas
    const vServico = $('v_servico');
    if(vServico){
      vServico.style.display = meta.maoObraEnabled ? '' : 'none';
    }
    const cServico = $('c_servico');
    if(cServico){
      cServico.style.display = meta.maoObraEnabled ? '' : 'none';
    }
    const oServico = $('o_servico');
    if(oServico){
      oServico.style.display = meta.maoObraEnabled ? '' : 'none';
    }
    const oMaoStat = $('o_mao');
    if(oMaoStat && oMaoStat.closest('.stat')){
      // hide entire stat box if meta disabled
      const parent = oMaoStat.closest('.stat');
      parent.style.display = meta.maoObraEnabled ? '' : 'none';
    }
    const cSrvStat = $('c_srv_stat');
    if(cSrvStat){
      cSrvStat.style.display = meta.maoObraEnabled ? '' : 'none';
    }

    // Venda r√°pida habilitada/desabilitada
    try{
      const quickEnabled = (meta.quickSaleEnabled !== false);
      const btnRapida = $('btnModeRapida');
      const btnCompleta = $('btnModeCompleta');
      const saleQuickWrap = $('saleQuickWrap');
      // ocultar bot√£o e se√ß√£o do modo r√°pido se desativado
      if(btnRapida) btnRapida.style.display = quickEnabled ? '' : 'none';
      if(saleQuickWrap){
        if(!quickEnabled){
          // garante que n√£o fique vis√≠vel
          saleQuickWrap.style.display = 'none';
          // for√ßa modo completa se modo r√°pido estava ativo
          if(typeof setSalesMode === 'function') setSalesMode('completa');
        }
      }
      // tamb√©m ajustar classe active se necess√°rio
      if(btnCompleta && !quickEnabled){
        btnCompleta.classList.add('active');
      }
    }catch(_err){}
  }catch(e){
    console.warn('applyPreferencesUI error', e);
  }
}

/* ========== Interface Mode ==========
   Permite alternar entre a interface padr√£o e uma vers√£o simplificada.
   O estado √© salvo no localStorage e aplicado adicionando/removendo
   a classe ``simple-mode`` no corpo da p√°gina. */
let interfaceMode = 'standard';
function applyInterfaceMode(){
  document.body.classList.toggle('simple-mode', interfaceMode === 'simple');
}
function setInterfaceMode(mode){
  interfaceMode = (mode === 'simple') ? 'simple' : 'standard';
  try{ safeLocalSet('erp_interface_mode', interfaceMode); }catch(e){}
  applyInterfaceMode();
  toast('Interface aplicada!', 'ok');
}
function applyInterfaceFromStorage(){
  // L√™ o modo de interface usando acesso seguro ao storage
  let saved = safeLocalGet('erp_interface_mode', null);
  if(saved){ interfaceMode = saved; }
  applyInterfaceMode();
}

/* ========== UI Mode (Desktop/Smartphone/Auto) ==========
   Permite alternar entre tr√™s modos de apresenta√ß√£o: desktop, smartphone
   e autom√°tico. O estado √© salvo em localStorage e, quando ativo,
   adiciona a classe ``smartphone`` ao corpo para aplicar estilos
   espec√≠ficos. Uma barra de navega√ß√£o inferior √© mostrada apenas no
   modo smartphone. */
let uiMode = 'auto';
function applyUIMode(){
  // ler prefer√™ncias salvas
  try{
    const saved = safeLocalGet('erp_ui_mode', null);
    if(saved) uiMode = saved;
  }catch(e){}
  const w = window.innerWidth;
  const isPhone = w <= 600;
  let mode = uiMode;
  if(mode === 'auto'){
    mode = isPhone ? 'smartphone' : 'desktop';
  }
  // Ativa a classe smartphone tanto no modo smartphone quanto no novo modo mobile, pois ambos usam barra inferior e cartas responsivas.
  const isPhoneMode = (mode === 'smartphone' || mode === 'mobile');
  document.body.classList.toggle('smartphone', isPhoneMode);
  // Nova classe mobile-mode adiciona ajustes espec√≠ficos para telas pequenas em p√©
  document.body.classList.toggle('mobile-mode', mode === 'mobile');
  const bottom = document.getElementById('bottomNav');
  if(bottom){
    bottom.style.display = isPhoneMode ? 'flex' : 'none';
  }
  if(isPhoneMode){
    adaptTables();
  }
}
function adaptTables(){
  // Adiciona data-label aos td's baseado no cabe√ßalho para leitura em cards
  if(!document.body.classList.contains('smartphone')) return;
  document.querySelectorAll('table').forEach(table => {
    const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    table.querySelectorAll('tbody tr').forEach(row => {
      row.querySelectorAll('td').forEach((cell,i) => {
        if(!cell.getAttribute('data-label')){
          cell.setAttribute('data-label', headers[i] || '');
        }
      });
    });
  });
}
function setUIMode(mode){
  uiMode = mode;
  try{ safeLocalSet('erp_ui_mode', uiMode); }catch(e){}
  applyUIMode();
  toast('Modo de interface aplicado!', 'ok');
}
function applyUIModeFromStorage(){
  try{
    const saved = safeLocalGet('erp_ui_mode', null);
    if(saved) uiMode = saved;
  }catch(e){}
  applyUIMode();
}
// Ajusta automaticamente o modo ao redimensionar a janela
window.addEventListener('resize', function(){ applyUIMode(); });

/* ========== Navega√ß√£o das Ferramentas Extras ==========
   Mostra apenas o cart√£o da ferramenta selecionada na √°rea de extras. */
function showTool(tool){
  // Lista de ferramentas dispon√≠veis. Adicionamos 'orcamentos' para permitir acesso aos or√ßamentos via Ferramentas.
  const tools = ['calc','pw','conv','notes','todo','rand','bmi','agenda','devedores','despesas','ai','diag','orcamentos'];
  tools.forEach(t => {
    const el = document.getElementById('tool_'+t);
    if(el){ el.style.display = (t === tool) ? 'block' : 'none'; }
  });
  // Renderizar a lista de or√ßamentos ao selecionar a ferramenta correspondente.
  if(tool === 'orcamentos'){
    try{ renderOrcamentos(); }catch(e){}
  }
}

/* ========== Assistente IA ==========
   Interpreta comandos simples do usu√°rio e executa a√ß√µes internas. */
function generateReport(){
  const vendasOk = (db.vendas || []).filter(v => !v.cancelada);
  const total_c = vendasOk.reduce((sum,v) => sum + (Number(v.total_c)||0), 0);
  const count = vendasOk.length;
  const agg = {};
  vendasOk.forEach(v => {
    const nome = s(v.nome);
    const qtd  = Math.max(0, Number(v.qtd) || 0);
    if(nome) agg[nome] = (agg[nome]||0) + qtd;
  });
  const top = Object.entries(agg).sort((a,b)=>b[1]-a[1]).slice(0,3);
  let out = 'Relat√≥rio de Vendas\n';
  out += 'Total de vendas: ' + count + '\n';
  out += 'Faturamento total: R$ ' + centsToBR(total_c) + '\n';
  if(top.length > 0){
    out += 'Top produtos:\n';
    top.forEach(([nome,qtd],i) => {
      out += (i+1) + '. ' + nome + ' (' + qtd + ')\n';
    });
  }
  return out;
}
function executeAI(){
  const raw = s($("ai_input")?.value).toLowerCase();
  let msg = '';
  // Express√µes matem√°ticas simples: se a entrada contiver apenas n√∫meros, espa√ßos, v√≠rgulas, pontos, par√™nteses e operadores, avalie-a
  const mathRegex = /^[0-9+\-*/().,\s]+$/;
  const isMathOnly = raw && mathRegex.test(raw) && !/[a-z√°√¢√£√†√©√™√≠√≥√¥√µ√∫√ß]/.test(raw);
  if(isMathOnly && /\d/.test(raw)){
    try{
      const expr = raw.replace(/,/g, '.');
      const result = eval(expr);
      if(!isNaN(result)){
        msg = 'Resultado: ' + result.toString();
      } else {
        msg = 'Express√£o inv√°lida.';
      }
    }catch(e){
      msg = 'N√£o foi poss√≠vel calcular a express√£o.';
    }
  } else if(!raw){ msg = 'Digite um comando ou pergunta.'; }
  // Perguntas sobre opera√ß√µes matem√°ticas em linguagem natural
  else if(/raiz quadrada/.test(raw)){
    // Extrai o n√∫mero ap√≥s "raiz quadrada de"
    const m = raw.match(/raiz quadrada de\s*([0-9]+[\.,]?[0-9]*)/);
    if(m){
      const num = parseFloat(m[1].replace(',', '.'));
      if(!isNaN(num)){
        const raiz = Math.sqrt(num);
        msg = 'Raiz quadrada de ' + num + ' √© ' + raiz.toFixed(2).replace('.', ',') + '.';
      } else {
        msg = 'N√∫mero inv√°lido para raiz quadrada.';
      }
    } else {
      msg = 'Informe um n√∫mero para calcular a raiz quadrada.';
    }
  } else if(/elevado a/.test(raw)){
    // Exemplo: "2 elevado a 3" ou "5,5 elevado a 2"
    const m = raw.match(/([0-9]+[\.,]?[0-9]*)\s*elevado a\s*([0-9]+[\.,]?[0-9]*)/);
    if(m){
      const base = parseFloat(m[1].replace(',', '.'));
      const exp = parseFloat(m[2].replace(',', '.'));
      if(!isNaN(base) && !isNaN(exp)){
        const potencia = Math.pow(base, exp);
        msg = base + ' elevado a ' + exp + ' √© ' + potencia.toFixed(2).replace('.', ',') + '.';
      } else {
        msg = 'N√∫meros inv√°lidos para pot√™ncia.';
      }
    } else {
      msg = 'Informe dois n√∫meros (base e expoente) para calcular a pot√™ncia.';
    }
  }else if(raw.includes('relatorio') || raw.includes('relat√≥rio')){
    msg = generateReport();
  }else if(raw.includes('orcamento') || raw.includes('or√ßamento')){
    if(typeof abrirOrcamentoUI === 'function') abrirOrcamentoUI();
    msg = 'Abrindo m√≥dulo de or√ßamento...';
  }else if(raw.includes('vendas') && raw.includes('dia')){
    // Conta quantas vendas ocorreram hoje
    const today = new Date().toLocaleDateString();
    let count = 0;
    let soma_c = 0;
    try{
      (db.vendas || []).forEach(v => {
        if(v.data && v.data.startsWith(today)){
          count++;
          soma_c += (v.total_c || 0);
        }
      });
    }catch(e){}
    const valor = (soma_c/100).toFixed(2).replace('.', ',');
    msg = 'Hoje foram registradas ' + count + ' vendas, totalizando R$ ' + valor + '.';
  }else if(raw.includes('venda')){
    if(typeof show === 'function') show('vendas');
    msg = 'Abrindo m√≥dulo de vendas...';
  }else if(raw.includes('estoque')){
    if(typeof show === 'function') show('estoque');
    msg = 'Abrindo m√≥dulo de estoque...';
  }else if(raw.includes('caixa')){
    if(typeof show === 'function') show('caixa');
    msg = 'Abrindo m√≥dulo de caixa...';
  }else if(raw.includes('dashboard') || raw.includes('in√≠cio') || raw.includes('inicio')){
    if(typeof show === 'function') show('dashboard');
    msg = 'Exibindo dashboard...';
  }else if(raw.includes('scan')){
    if(typeof openScanOverlay === 'function') openScanOverlay();
    msg = 'Abrindo scanner...';
  }else if(/troco/.test(raw)){
    // Calcula troco a partir dos n√∫meros informados no comando
    const nums = raw.match(/\d+[\.,]?\d*/g);
    if(nums && nums.length >= 2){
      const pago = parseFloat(nums[0].replace(',', '.'));
      const total = parseFloat(nums[1].replace(',', '.'));
      const troco = pago - total;
      msg = troco >= 0
        ? ('Troco: R$ ' + troco.toFixed(2).replace('.', ','))
        : ('Falta: R$ ' + Math.abs(troco).toFixed(2).replace('.', ','));
    } else {
      msg = 'Para calcular troco, informe dois valores (pago e total).';
    }
  }else if(/(cadastrar|adicionar).*(produto)|novo.*produto/.test(raw)){
    // Assistente para cadastro de produtos: abre o estoque e instrui o usu√°rio
    if(typeof show === 'function') show('estoque');
    msg = 'Para cadastrar um novo produto, clique em Estoque, preencha C√≥digo, Nome, Quantidade, M√≠nimo, Custo e Pre√ßo e clique em Salvar.';
  }else if(raw.includes('abrir caixa')){
    // Abre o m√≥dulo de caixa e tenta abrir automaticamente se necess√°rio
    if(typeof show === 'function') show('caixa');
    try{
      if(!db.caixaAberto && typeof abrirCaixa === 'function'){
        // Define um valor de abertura zero caso o campo esteja vazio
        const inp = document.getElementById('cx_abertura');
        if(inp && !inp.value) inp.value = '0';
        abrirCaixa();
        msg = 'Caixa aberto com sucesso!';
      }else{
        msg = 'Caixa j√° est√° aberto.';
      }
    }catch(e){ msg = 'N√£o foi poss√≠vel abrir o caixa.'; }
  }else if(raw.includes('fechar caixa')){
    // Fecha o caixa se estiver aberto
    if(typeof show === 'function') show('caixa');
    try{
      if(db.caixaAberto && typeof fecharCaixa === 'function'){
        fecharCaixa();
        msg = 'Caixa fechado.';
      }else{
        msg = 'Caixa j√° est√° fechado.';
      }
    }catch(e){ msg = 'N√£o foi poss√≠vel fechar o caixa.'; }
  }else if(raw.includes('capital') && (raw.includes('brasil') || raw.includes('brasilia'))){
    // Conhecimento geral: capital do Brasil
    msg = 'A capital do Brasil √© Bras√≠lia.';
  }else if(raw.includes('capital') && (raw.includes('fran√ßa') || raw.includes('franca'))){
    msg = 'A capital da Fran√ßa √© Paris.';
  }else if(raw.includes('capital') && (raw.includes('italia') || raw.includes('it√°lia'))){
    msg = 'A capital da It√°lia √© Roma.';
  }else if(raw.includes('capital') && (raw.includes('espanha') || raw.includes('espanha'))){
    msg = 'A capital da Espanha √© Madri.';
  }else if(raw.includes('capital') && raw.includes('argentina')){
    msg = 'A capital da Argentina √© Buenos Aires.';
  }else if(raw.includes('quem') && raw.includes('voc√™')){
    // Auto-descri√ß√£o do assistente
    msg = 'Sou um assistente virtual integrado ao sistema ERP, pronto para ajudar com comandos, c√°lculos e perguntas.';
  }else if(raw.includes('despesas')){
    // Abrir o m√≥dulo de despesas mensais
    if(typeof show === 'function') show('ajustes');
    if(typeof toggleSubAjuste === 'function') toggleSubAjuste('despesas');
    msg = 'Abrindo m√≥dulo de despesas mensais...';
  }else if(raw.includes('rentabilidade')){
    // Calcula rentabilidade (receita, lucro e despesas) e retorna um resumo
    if(typeof calcularDespesas === 'function') calcularDespesas();
    // Reproduz a mesma l√≥gica de c√°lculo usada em calcularDespesas() para
    // construir a resposta textual aqui. Isso garante que o assistente
    // retorne n√∫meros atualizados sem depender do DOM.
    let totalDespesas_c = despesas.reduce((a,b) => a + (b.valor_c || 0), 0);
    let totalReceita_c = 0;
    let totalLucroVendas_c = 0;
    try{
      (db.vendas || []).forEach(v => {
        totalReceita_c += (v.total_c || 0);
        if(typeof v.lucro_c === 'number'){
          totalLucroVendas_c += v.lucro_c;
        } else {
          totalLucroVendas_c += (v.total_c || 0) - (v.servico_c || 0);
        }
      });
    }catch(e){}
    const lucroLiquido_c = totalLucroVendas_c - totalDespesas_c;
    const receitaStr = (totalReceita_c / 100).toFixed(2).replace('.', ',');
    const lucroBrutoStr = (totalLucroVendas_c / 100).toFixed(2).replace('.', ',');
    const despesasStr = (totalDespesas_c / 100).toFixed(2).replace('.', ',');
    const lucroLiquidoStr = (Math.abs(lucroLiquido_c) / 100).toFixed(2).replace('.', ',');
    msg = 'Receita total: R$ ' + receitaStr + '; Lucro bruto das vendas: R$ ' + lucroBrutoStr + '; Despesas: R$ ' + despesasStr + '; ';
    msg += lucroLiquido_c >= 0 ? ('Lucro l√≠quido: R$ ' + lucroLiquidoStr) : ('Preju√≠zo l√≠quido: R$ ' + lucroLiquidoStr);
  }else if(raw.includes('faturamento')){
    // Calcula o faturamento total somando todas as vendas registradas
    let total_c = 0;
    try{
      (db.vendas || []).forEach(v => { total_c += (v.total_c || 0); });
    }catch(e){ total_c = 0; }
    const total = (total_c / 100).toFixed(2).replace('.', ',');
    msg = 'Faturamento total registrado: R$ ' + total + '.';
  }else if(raw.includes('vendas') && raw.includes('dia')){
    // Conta quantas vendas ocorreram hoje
    const today = new Date().toLocaleDateString();
    let count = 0;
    let soma_c = 0;
    try{
      (db.vendas || []).forEach(v => {
        if(v.data && v.data.startsWith(today)){
          count++;
          soma_c += (v.total_c || 0);
        }
      });
    }catch(e){}
    const valor = (soma_c/100).toFixed(2).replace('.', ',');
    msg = 'Hoje foram registradas ' + count + ' vendas, totalizando R$ ' + valor + '.';
  }else if(raw.includes('ajuda') || raw.includes('help')){
    msg = 'Comandos dispon√≠veis: relat√≥rio, or√ßamento, vendas, estoque, caixa, dashboard, scan, troco [pago total], despesas, rentabilidade, c√°lculos.';
  }else if(raw.includes('como vai') || raw.includes('tudo bem') || raw.includes('bom dia') || raw.includes('boa tarde') || raw.includes('boa noite')){
    msg = 'Ol√°! Estou sempre pronto para ajudar. Como posso auxili√°-lo hoje?';
  }else {
    // Verificar perguntas aritm√©ticas simples com operadores em portugu√™s
    const arit = raw.match(/([0-9]+[\.,]?[0-9]*)\s*(mais|menos|vezes|multiplicado por|dividido por|dividido)\s*([0-9]+[\.,]?[0-9]*)/);
    if(arit){
      const a = parseFloat(arit[1].replace(',', '.'));
      const op = arit[2];
      const b = parseFloat(arit[3].replace(',', '.'));
      if(!isNaN(a) && !isNaN(b)){
        let res;
        switch(op){
          case 'mais': res = a + b; break;
          case 'menos': res = a - b; break;
          case 'vezes':
          case 'multiplicado por': res = a * b; break;
          case 'dividido por':
          case 'dividido': res = b !== 0 ? a / b : NaN; break;
          default: res = NaN;
        }
        if(!isNaN(res)){
          msg = 'Resultado: ' + res.toString().replace('.', ',');
        }else{
          msg = 'N√£o foi poss√≠vel efetuar o c√°lculo.';
        }
      }else{
        msg = 'N√∫meros inv√°lidos para c√°lculo.';
      }
    } else {
      msg = 'Desculpe, n√£o entendi o comando.';
    }
  }
  const outEl = $("ai_output");
  if(outEl) outEl.textContent = msg;
}

/* ========== Toggle para o gr√°fico de Faturamento ==========
   Permite minimizar/expandir a visualiza√ß√£o dos √∫ltimos 30 dias. */
function toggleFatEvolution(){
  const cont = document.getElementById('fatEvolutionContent');
  const btn = document.getElementById('fatToggleBtn');
  if(!cont) return;
  const hidden = cont.style.display === 'none';
  cont.style.display = hidden ? 'block' : 'none';
  // Alterne o √≠cone do bot√£o conforme o estado: seta para baixo quando aberto, seta para a direita quando fechado
  if(btn){
    btn.textContent = hidden ? 'üîΩ' : '‚ñ∂';
  }
}

/* ========== Despesas Mensais ========== */
// Lista de despesas mensais (cada item possui nome e valor em centavos)
let despesas = [];

// Carrega despesas armazenadas no banco de dados (localStorage)
function loadDespesas(){
  try{
    despesas = (db.despesas && Array.isArray(db.despesas)) ? db.despesas.map(d=>({
      nome: d.nome || '',
      valor_c: d.valor_c || 0,
      tipo: (typeof d.tipo === 'string' && (d.tipo.toLowerCase() === 'variavel' || d.tipo.toLowerCase() === 'fixa')) ? d.tipo.toLowerCase() : 'fixa'
    })) : [];
  }catch(e){ despesas = []; }
}

// Salva a lista de despesas de volta ao banco de dados e persiste
function saveDespesas(){
  // Persiste a lista de despesas com nome, valor e tipo
  db.despesas = despesas.map(d => ({
    nome: d.nome || '',
    valor_c: Number(d.valor_c) || 0,
    tipo: d.tipo || 'fixa'
  }));
  // reutiliza a fun√ß√£o save() para persistir o banco
  if(typeof save === 'function') save();
}

// Renderiza a tabela de despesas no card de Ajustes
function renderDespesasTable(){
  const cont = document.getElementById('despesasTable');
  if(!cont) return;
  let html = '';
  if(!despesas || despesas.length === 0){
    html = '<p class="small">Nenhuma despesa registrada.</p>';
  }else{
    html = '<table class="tight"><thead><tr><th>#</th><th class="rowleft">Descri√ß√£o</th><th>Tipo</th><th>Valor (R$)</th><th>A√ß√£o</th></tr></thead><tbody>';
    despesas.forEach((d,i)=>{
      const valor = (d.valor_c || 0) / 100;
      const valorStr = valor.toFixed(2).replace('.', ',');
      // garante tipo v√°lido
      const tipo = (d.tipo === 'variavel' || d.tipo === 'fixa') ? d.tipo : 'fixa';
      html += '<tr>';
      html += '<td>' + (i+1) + '</td>';
      html += '<td><input type="text" value="' + escapeHTML(d.nome || '') + '" onchange="updateDespesaNome(' + i + ', this.value)" /></td>';
      html += '<td><select onchange="updateDespesaTipo(' + i + ', this.value)">' +
                '<option value="fixa"' + (tipo === 'fixa' ? ' selected' : '') + '>Fixa</option>' +
                '<option value="variavel"' + (tipo === 'variavel' ? ' selected' : '') + '>Vari√°vel</option>' +
              '</select></td>';
      html += '<td><input type="text" value="' + valorStr + '" onchange="updateDespesaValor(' + i + ', this.value)" style="max-width:80px;" /></td>';
      html += '<td><button class="danger" onclick="removeDespesaRow(' + i + ')">Remover</button></td>';
      html += '</tr>';
    });
    html += '</tbody></table>';
  }
  cont.innerHTML = html;
}

// Adiciona uma nova despesa vazia
function addDespesaRow(){
  despesas.push({ nome:'', valor_c:0, tipo:'fixa' });
  renderDespesasTable();
  saveDespesas();
}

// Remove uma despesa pelo √≠ndice
function removeDespesaRow(i){
  despesas.splice(i, 1);
  renderDespesasTable();
  saveDespesas();
}

// Atualiza o nome de uma despesa
function updateDespesaNome(i, value){
  if(!despesas[i]) return;
  despesas[i].nome = value;
  saveDespesas();
}

// Atualiza o valor de uma despesa (entrada em reais com v√≠rgula ou ponto)
function updateDespesaValor(i, value){
  if(!despesas[i]) return;
  const cents = parseMoneyToCents(value);
  despesas[i].valor_c = cents;
  saveDespesas();
  // n√£o renderiza novamente para manter foco
}

// Atualiza o tipo de uma despesa (fixa ou variavel)
function updateDespesaTipo(i, value){
  if(!despesas[i]) return;
  const v = String(value || '').toLowerCase();
  despesas[i].tipo = (v === 'variavel' || v === 'fixa') ? v : 'fixa';
  saveDespesas();
  // n√£o renderiza novamente para manter foco
}

// Calcula a soma de despesas e compara com o faturamento total
function calcularDespesas(){
  // Soma despesas (centavos) e por tipo
  let totalDespesas_c = 0;
  const porTipo = { fixa: 0, variavel: 0 };
  despesas.forEach(d => {
    const v = Number(d.valor_c) || 0;
    totalDespesas_c += v;
    const t = (String(d.tipo).toLowerCase() === 'variavel') ? 'variavel' : 'fixa';
    porTipo[t] += v;
  });
  // Soma o faturamento e o lucro bruto de todas as vendas. Para vendas que
  // possuem o campo lucro_c, usamos esse valor para determinar o lucro
  // gerado por cada item; caso contr√°rio, o lucro bruto √© calculado
  // subtraindo-se o custo estimado da receita total. Isso fornece um
  // balan√ßo mais completo (Receita ‚Äì Custo dos Produtos ‚Äì Despesas).
  let totalReceita_c = 0;
  let totalLucroVendas_c = 0;
  try{
    (db.vendas || []).forEach(v => {
      totalReceita_c += (v.total_c || 0);
      if(typeof v.lucro_c === 'number'){
        totalLucroVendas_c += v.lucro_c;
      } else {
        // Se lucro_c n√£o existir, estime lucro como total_c (receita) menos
        // qualquer servi√ßo registrado. Este c√°lculo √© aproximado, pois n√£o
        // temos acesso ao custo unit√°rio do produto nesta venda. Considere
        // servico_c como parte da margem de lucro.
        totalLucroVendas_c += (v.total_c || 0) - (v.servico_c || 0);
      }
    });
  }catch(e){}
  // Lucro l√≠quido = lucro bruto das vendas ‚Äì despesas
  const lucroLiquido_c = totalLucroVendas_c - totalDespesas_c;
  const resEl = document.getElementById('despesasResultado');
  if(resEl){
    const despesasStr = centsToBR(totalDespesas_c);
    const receitaStr = centsToBR(totalReceita_c);
    const lucroBrutoStr = centsToBR(totalLucroVendas_c);
    const lucroLiquidoStr = centsToBR(Math.abs(lucroLiquido_c));
    // Totais por tipo
    const fixaStr = centsToBR(porTipo.fixa);
    const varStr = centsToBR(porTipo.variavel);
    let msg = '';
    msg += '<div><b>Resumo de Despesas e Receitas</b></div>';
    msg += '<div>Receita total: R$ ' + receitaStr + '</div>';
    msg += '<div>Lucro bruto das vendas: R$ ' + lucroBrutoStr + '</div>';
    msg += '<div>Despesas totais: R$ ' + despesasStr + '</div>';
    msg += '<div style="margin-left:12px;">- Despesas fixas: R$ ' + fixaStr + '</div>';
    msg += '<div style="margin-left:12px;">- Despesas vari√°veis: R$ ' + varStr + '</div>';
    if(lucroLiquido_c >= 0){
      msg += '<div><b>Lucro l√≠quido:</b> R$ ' + lucroLiquidoStr + '</div>';
    } else {
      msg += '<div><b>Preju√≠zo l√≠quido:</b> R$ ' + lucroLiquidoStr + '</div>';
    }
    msg += '<div class="small" style="margin-top:6px;">O lucro l√≠quido considera o lucro bruto das vendas subtra√≠do das despesas registradas acima.</div>';
    resEl.innerHTML = msg;
  }
  saveDespesas();
}

// Limpa todas as despesas cadastradas
function limparDespesas(){
  despesas = [];
  renderDespesasTable();
  const resEl = document.getElementById('despesasResultado');
  if(resEl) resEl.innerHTML = '';
  saveDespesas();
}

/* ========== Contabilidade / Balan√ßo ==========
 *
 * Esta se√ß√£o adiciona funcionalidades de contabilidade ao ERP. O
 * usu√°rio pode selecionar diferentes per√≠odos (hoje, m√™s atual,
 * √∫ltimos 3 ou 6 meses, ano atual ou um m√™s/ano espec√≠ficos) e
 * obter um balan√ßo financeiro composto por entradas e sa√≠das do
 * caixa, vendas e uma estimativa de despesas fixas. O resultado
 * inclui um resumo de lucros e preju√≠zos e pode ser impresso.
 */
function toggleContabilidade(){
  try{
    const card = document.getElementById('contabilidadeCard');
    if(!card) return;
    const show = card.style.display === 'none' || card.style.display === '';
    card.style.display = show ? 'block' : 'none';
  }catch(e){ console.warn('toggleContabilidade error', e); }
}

function contabPeriodo(tipo, value){
  const now = new Date();
  let start;
  let end;
  // Normaliza para 00:00 de hoje
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  switch(tipo){
    case 'dia':
      start = new Date(today);
      end = new Date(today);
      end.setDate(end.getDate() + 1);
      break;
    case 'mes':
      start = new Date(now.getFullYear(), now.getMonth(), 1);
      end = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      break;
    case '3meses':
      end = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      start = new Date(now.getFullYear(), now.getMonth() - 2, 1);
      break;
    case '6meses':
      end = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      start = new Date(now.getFullYear(), now.getMonth() - 5, 1);
      break;
    case 'ano':
      start = new Date(now.getFullYear(), 0, 1);
      end = new Date(now.getFullYear() + 1, 0, 1);
      break;
    case 'mesSel':
      if(!value) return;
      try{
        const parts = String(value).split('-');
        if(parts.length === 2){
          const y = parseInt(parts[0]);
          const m = parseInt(parts[1]);
          if(!isNaN(y) && !isNaN(m)){
            start = new Date(y, m - 1, 1);
            end = new Date(y, m, 1);
          }
        }
      }catch(_e){ return; }
      break;
    case 'anoSel':
      try{
        const y = parseInt(value);
        if(!isNaN(y)){
          start = new Date(y, 0, 1);
          end = new Date(y + 1, 0, 1);
        }
      }catch(_){ return; }
      break;
    default:
      return;
  }
  if(start && end){
    computeContabilidade(start, end);
  }
}

function computeContabilidade(start, end){
  try{
    const resEl = document.getElementById('contabResult');
    if(!resEl) return;
    const startTime = start.getTime();
    const endTime = end.getTime();
    let entradas_c = 0;
    let saidas_c = 0;
    const entradasPorCat = {};
    const saidasPorCat = {};
    // Percorre lan√ßamentos do caixa no per√≠odo
    (db.caixa || []).forEach(rec => {
      if(!rec || !rec.data) return;
      let d;
      try{ d = new Date(rec.data); }catch(_e){ return; }
      if(!d || isNaN(d.getTime())) return;
      const t = d.getTime();
      if(t < startTime || t >= endTime) return;
      const valor = Number(rec.valor_c) || 0;
      // Categoria pode n√£o existir; ca√≠mos para a descri√ß√£o
      const cat = rec.categoria || rec.desc || 'Outro';
      if(valor >= 0){
        entradas_c += valor;
        entradasPorCat[cat] = (entradasPorCat[cat] || 0) + valor;
      } else {
        const vAbs = Math.abs(valor);
        saidas_c += vAbs;
        saidasPorCat[cat] = (saidasPorCat[cat] || 0) + vAbs;
      }
    });
    // Percorre vendas para receita e lucro
    let vendas_c = 0;
    let lucro_c = 0;
    (db.vendas || []).forEach(v => {
      if(!v || v.cancelada) return;
      let d;
      // tenta m√∫ltiplos campos para data
      if(v.dataIso){
        try{ d = new Date(v.dataIso); }catch(_){ d = null; }
      }
      if(!d && v.data){
        try{ d = new Date(v.data); }catch(_){ d = null; }
      }
      if(!d || isNaN(d.getTime())) return;
      const t = d.getTime();
      if(t < startTime || t >= endTime) return;
      const total = Number(v.total_c) || 0;
      vendas_c += total;
      if(typeof v.lucro_c === 'number'){
        lucro_c += Number(v.lucro_c) || 0;
      } else {
        lucro_c += total - (Number(v.servico_c) || 0);
      }
    });
    // Estimativa de despesas fixas para o per√≠odo: multiplicamos cada despesa pelo n√∫mero de meses no intervalo
    let totalDespesasFixasPeriod_c = 0;
    try{
      // calcula diferen√ßa em meses: end no primeiro dia do pr√≥ximo m√™s menos start no primeiro dia do m√™s
      const monthsDiff = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      const meses = Math.max(1, monthsDiff);
      (db.despesas || []).forEach(d => {
        const v = Number(d.valor_c) || 0;
        totalDespesasFixasPeriod_c += v * meses;
      });
    }catch(_e){}
    const lucroLiquido_c = lucro_c - saidas_c - totalDespesasFixasPeriod_c;
    // Fun√ß√£o para formatar centavos
    const fmt = x => centsToBR(x);
    // Monta HTML do relat√≥rio
    let html = '';
    html += '<div><b>Per√≠odo:</b> ' + start.toLocaleDateString() + ' a ' + new Date(end.getTime() - 1).toLocaleDateString() + '</div>';
    html += '<div><b>Entradas (Caixa):</b> R$ ' + fmt(entradas_c) + '</div>';
    html += '<div><b>Sa√≠das (Caixa):</b> R$ ' + fmt(saidas_c) + '</div>';
    html += '<div><b>Saldo do Caixa:</b> R$ ' + fmt(entradas_c - saidas_c) + '</div>';
    html += '<div><b>Receita de Vendas:</b> R$ ' + fmt(vendas_c) + '</div>';
    html += '<div><b>Lucro Bruto das Vendas:</b> R$ ' + fmt(lucro_c) + '</div>';
    html += '<div><b>Despesas Fixas (aprox.):</b> R$ ' + fmt(totalDespesasFixasPeriod_c) + '</div>';
    if(lucroLiquido_c >= 0){
      html += '<div><b>Lucro L√≠quido:</b> R$ ' + fmt(lucroLiquido_c) + '</div>';
    } else {
      html += '<div><b>Preju√≠zo L√≠quido:</b> R$ ' + fmt(Math.abs(lucroLiquido_c)) + '</div>';
    }
    // Entradas por categoria
    const entries = Object.entries(entradasPorCat).sort((a,b)=> b[1] - a[1]);
    if(entries.length > 0){
      html += '<hr><div><b>Entradas por Categoria:</b></div>';
      entries.forEach(([cat,val]) => {
        html += '<div style="margin-left:12px;">' + escapeHTML(cat) + ': R$ ' + fmt(val) + '</div>';
      });
    }
    const exits = Object.entries(saidasPorCat).sort((a,b)=> b[1] - a[1]);
    if(exits.length > 0){
      html += '<hr><div><b>Sa√≠das por Categoria:</b></div>';
      exits.forEach(([cat,val]) => {
        html += '<div style="margin-left:12px;">' + escapeHTML(cat) + ': R$ ' + fmt(val) + '</div>';
      });
    }
    resEl.innerHTML = html;
  }catch(e){ console.warn('computeContabilidade error', e); }
}

function printContabilidade(){
  try{
    const resEl = document.getElementById('contabResult');
    if(!resEl) return;
    const html = '<div style="font-family:Arial, sans-serif; font-size:14px;">' + resEl.innerHTML + '</div>';
    const wrapper = '<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><title>Relat√≥rio de Contabilidade</title></head><body>' + html + '</body></html>';
    const blob = new Blob([wrapper], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const w = window.open(url, '_blank');
    if(!w){
      const a = document.createElement('a');
      a.href = url;
      a.download = 'contabilidade.html';
      a.click();
    } else {
      w.addEventListener('load', () => {
        try{ w.print(); }catch(_e){}
      });
    }
    setTimeout(() => URL.revokeObjectURL(url), 12000);
  }catch(e){ console.warn('printContabilidade error', e); }
}

/* ========== Perfil de Com√©rcio ========== */
// Define o perfil do neg√≥cio (supermercado, loja ou assist√™ncia).
// Essa configura√ß√£o √© armazenada no localStorage e sincronizada com o m√≥dulo de scanner
// para ativar fun√ß√µes espec√≠ficas (descontos, ordens de servi√ßo, etc.).
let commerceProfile = 'store';

function setCommerceProfile(p){
  commerceProfile = p;
  try{
    safeLocalSet('erp_commerce_profile', p);
  }catch(e){}
  // Se o scanner estiver carregado, atualize o perfil dele
  try{
    if(typeof scanProfile !== 'undefined') scanProfile = p;
    if(typeof scanRenderProfile === 'function') scanRenderProfile();
  }catch(e){}
  toast('Perfil de com√©rcio definido para ' + (p === 'super' ? 'Supermercado' : p === 'service' ? 'Assist√™ncia' : 'Loja Comum') + '.', 'ok');
}

// Aplica o perfil salvo ao iniciar a p√°gina
function applyCommerceProfile(){
  // Carrega perfil de com√©rcio usando acesso seguro ao storage
  let saved = safeLocalGet('erp_commerce_profile', null);
  if(saved){ commerceProfile = saved; }
  try{
    if(typeof scanProfile !== 'undefined') scanProfile = commerceProfile;
    if(typeof scanRenderProfile === 'function') scanRenderProfile();
  }catch(e){}
}

// Bot√£o para abrir o scanner a partir da venda r√°pida
function openScannerFromVendas(){
  // Ao abrir a partir de vendas, exibe a janela flutuante do scanner e
  // inicia automaticamente o leitor se ainda n√£o estiver ativo. Isso
  // garante que o modal e o bot√£o de scan fiquem sincronizados. 
  if(typeof openScanOverlay === 'function'){
    openScanOverlay();
  }
  // Se o scanner n√£o estiver ligado, inicialize-o. startScanner j√°
  // invoca updateScanButton() para atualizar textos dos bot√µes.
  if(typeof startScanner === 'function' && !scanOn){
    startScanner();
  }
}

/* ========== Agenda (Calendar) ========== */
function renderAgenda(withFlash=false){
  const tbody = $("tAgenda");
  if(!tbody) return;
  const now = new Date();
  const events = (db.agenda || []).slice().sort((a,b)=> new Date(a.data) - new Date(b.data));
  tbody.innerHTML = '';
  if(events.length === 0){
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 5;
    td.className = 'small';
    td.textContent = 'Nenhum evento.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  } else {
    const frag = document.createDocumentFragment();
    events.forEach(ev => {
      const tr = document.createElement('tr');
      if(withFlash) tr.classList.add('flash');
      // Data/hora
      const tdData = document.createElement('td');
      tdData.textContent = String((ev.data||'').replace('T',' ').substring(0,16));
      tr.appendChild(tdData);
      // T√≠tulo
      const tdTitulo = document.createElement('td');
      tdTitulo.className = 'rowleft';
      tdTitulo.textContent = ev.titulo;
      tr.appendChild(tdTitulo);
      // Descri√ß√£o
      const tdDesc = document.createElement('td');
      tdDesc.className = 'rowleft';
      tdDesc.textContent = ev.desc || '';
      tr.appendChild(tdDesc);
      // Status
      const tdStatus = document.createElement('td');
      const spanStatus = document.createElement('span');
      const dt = new Date(ev.data);
      if(dt < now){
        spanStatus.className = 'bad';
        spanStatus.textContent = 'Vencido';
      }else{
        spanStatus.className = 'ok';
        spanStatus.textContent = 'Futuro';
      }
      tdStatus.appendChild(spanStatus);
      tr.appendChild(tdStatus);
      // A√ß√£o
      const tdAcao = document.createElement('td');
      const btnDel = document.createElement('button');
      btnDel.className = 'danger';
      btnDel.textContent = 'Apagar';
      btnDel.onclick = function(){ deleteAgendaItem(ev.id); };
      tdAcao.appendChild(btnDel);
      tr.appendChild(tdAcao);
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
  }
}
function addAgendaItem(){
  const titulo = s($("ag_titulo")?.value);
  const data = s($("ag_data")?.value);
  const desc = s($("ag_desc")?.value);
  if(isEmpty(titulo) || isEmpty(data)){
    toast("Preencha t√≠tulo e data/hora.", "warn");
    return;
  }
  const id = makeId();
  db.agenda.push({id, titulo, data, desc});
  save();
  renderAgenda(true);
  if($("ag_titulo")) $("ag_titulo").value="";
  if($("ag_data")) $("ag_data").value="";
  if($("ag_desc")) $("ag_desc").value="";
  toast("Evento adicionado!", "ok");
}
function deleteAgendaItem(id){
  db.agenda = (db.agenda || []).filter(ev => Number(ev.id) !== Number(id));
  save();
  renderAgenda(true);
  toast("Evento removido.", "warn");
}
function checkAgendaAlerts(){
  // Normaliza hora atual para c√°lculo em milissegundos
  const nowMs = Date.now();
  (db.agenda || []).forEach(ev => {
    // Se n√£o houver data v√°lida, ignore
    const dt = new Date(ev.data);
    const evMs = dt.getTime();
    if(!Number.isFinite(evMs)) return;
    const diff = evMs - nowMs;
    // Use ID √∫nico (preferencialmente ev.id) ou combina√ß√£o de campos
    const idKey = ev.id || `${ev.data}-${ev.titulo}`;
    // Se evento est√° dentro da janela de alerta (pr√≥xima hora ou at√© 1h atr√°s)
    if((diff <= 0 && diff > -3600000) || (diff > 0 && diff <= 3600000)){
      if(!agendaAlertNotified.has(idKey)){
        // alerta espec√≠fico dependendo se est√° pr√≥ximo ou atrasado
        const msg = diff <= 0
          ? `Evento: ${ev.titulo} agora/atrasado`
          : `Evento pr√≥ximo: ${ev.titulo}`;
        toast(msg, diff <= 0 ? "warn" : "ok");
        agendaAlertNotified.add(idKey);
      }
    }else{
      // Fora da janela de alerta: limpar flag para permitir aviso futuro
      if(agendaAlertNotified.has(idKey)) agendaAlertNotified.delete(idKey);
    }
  });
}

/* ========== Devedores (Fiado) ========== */
function renderDevedores(withFlash=false){
  const tbody = $("tDevedores");
  if(!tbody) return;
  const now = new Date();
  const list = db.devedores || [];
  tbody.innerHTML = '';
  if(list.length === 0){
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 6;
    td.className = 'small';
    td.textContent = 'Nenhum devedor.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  } else {
    const frag = document.createDocumentFragment();
    list.forEach(dv => {
      const dt = new Date(dv.data);
      const tr = document.createElement('tr');
      if(withFlash) tr.classList.add('flash');
      // Nome
      const tdNome = document.createElement('td');
      tdNome.className = 'rowleft';
      tdNome.textContent = dv.nome;
      tr.appendChild(tdNome);
      // Valor
      const tdVal = document.createElement('td');
      tdVal.textContent = 'R$ ' + centsToBR(dv.valor_c);
      tr.appendChild(tdVal);
      // Data
      const tdData = document.createElement('td');
      tdData.textContent = dv.data;
      tr.appendChild(tdData);
      // Status
      const tdStatus = document.createElement('td');
      const spanStatus = document.createElement('span');
      if(dv.pago){
        spanStatus.className = 'ok';
        spanStatus.textContent = 'Pago';
      }else{
        if(dt < now){
          spanStatus.className = 'bad';
          spanStatus.textContent = 'Vencido';
        }else{
          spanStatus.className = 'warn';
          spanStatus.textContent = 'Em aberto';
        }
      }
      tdStatus.appendChild(spanStatus);
      tr.appendChild(tdStatus);
      // Descri√ß√£o
      const tdDesc = document.createElement('td');
      tdDesc.className = 'rowleft';
      tdDesc.textContent = dv.desc || '';
      tr.appendChild(tdDesc);
      // A√ß√µes: sempre permitir editar, receber (se ainda n√£o pago) e apagar.  Os
      // bot√µes chamam fun√ß√µes que lidam com confirma√ß√£o e persist√™ncia.  Um
      // espa√ßo √© adicionado entre eles para legibilidade.
      const tdAcoes = document.createElement('td');
      // Bot√£o Editar: preenche o formul√°rio com os dados do devedor
      const btnEdit = document.createElement('button');
      btnEdit.textContent = 'Editar';
      btnEdit.onclick = function(){ editDevedor(dv.id); };
      tdAcoes.appendChild(btnEdit);
      tdAcoes.appendChild(document.createTextNode(' '));
      // Bot√£o Receber: apenas se ainda n√£o pago
      if(!dv.pago){
        const btnRec = document.createElement('button');
        btnRec.textContent = 'Receber';
        btnRec.onclick = function(){ markDevedorPago(dv.id); };
        tdAcoes.appendChild(btnRec);
        tdAcoes.appendChild(document.createTextNode(' '));
      }
      // Bot√£o Apagar: sempre dispon√≠vel
      const btnDel = document.createElement('button');
      btnDel.className = 'danger';
      btnDel.textContent = 'Apagar';
      btnDel.onclick = function(){ deleteDevedor(dv.id); };
      tdAcoes.appendChild(btnDel);
      tr.appendChild(tdAcoes);
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
  }
}
function addDevedor(){
  const nome = s($("dv_nome")?.value);
  const valor_c = parseMoneyToCents($("dv_valor")?.value);
  const data = s($("dv_data")?.value);
  const desc = s($("dv_desc")?.value);
  if(isEmpty(nome) || valor_c <= 0 || isEmpty(data)){
    toast("Preencha nome, valor e data.", "warn");
    return;
  }
  const id = makeId();
  db.devedores.push({id, nome, valor_c, data, desc, pago:false});
  save();
  // Ao adicionar um devedor, atualiza a lista e o dashboard
  renderDevedores(true);
  render(true);
  if($("dv_nome")) $("dv_nome").value="";
  if($("dv_valor")) $("dv_valor").value="";
  if($("dv_data")) $("dv_data").value="";
  if($("dv_desc")) $("dv_desc").value="";
  toast("Devedor registrado!", "ok");
}
function markDevedorPago(id){
  const dv = (db.devedores || []).find(x => Number(x.id) === Number(id));
  if(!dv || dv.pago){
    toast("Devedor n√£o encontrado ou j√° pago.", "warn");
    return;
  }
  if(!confirm(`Confirmar recebimento de R$ ${centsToBR(dv.valor_c)} de ${dv.nome}?`)) return;
  dv.pago = true;
  dv.pagoEm = new Date().toISOString();
  // registrar entrada no caixa se estiver aberto
  if(db.caixaAberto){
    db.caixa.push({
      data: nowDateTime(),
      desc: "Recebimento fiado: " + dv.nome,
      valor_c: dv.valor_c,
      tipo: "entrada",
      pag: "dinheiro",
      categoria: "fiado",
      obs: dv.desc || ""
    });
  }
  save();
  renderDevedores(true);
  render(true);
  toast("Pagamento registrado!", "ok");
}
function deleteDevedor(id){
  const idx = (db.devedores || []).findIndex(x => Number(x.id) === Number(id));
  if(idx < 0){
    toast("Devedor n√£o encontrado.", "bad");
    return;
  }
  if(!confirm("Apagar este devedor?")) return;
  db.devedores.splice(idx, 1);
  save();
  // Atualiza lista e dashboard ap√≥s remo√ß√£o
  renderDevedores(true);
  render(true);
  toast("Devedor removido.", "warn");
}

// Vari√°vel global para controlar qual devedor est√° sendo editado. Quando
// null, n√£o h√° devedor em edi√ß√£o e o formul√°rio opera em modo adicionar.
let editingDevedorId = null;

// Inicia a edi√ß√£o de um devedor. Carrega os dados no formul√°rio e ajusta os
// bot√µes de adicionar/salvar e cancelar.  A fun√ß√£o find() retorna o
// objeto devedor correspondente; se n√£o encontrado, exibe alerta.
function editDevedor(id){
  id = Number(id);
  const dv = (db.devedores || []).find(x => Number(x.id) === id);
  if(!dv){
    toast("Devedor n√£o encontrado.", "bad");
    return;
  }
  editingDevedorId = id;
  // Preenche campos com os dados atuais
  if($("dv_nome")) $("dv_nome").value = dv.nome || "";
  if($("dv_valor")) $("dv_valor").value = centsToBR(dv.valor_c);
  if($("dv_data")) $("dv_data").value = dv.data || "";
  if($("dv_desc")) $("dv_desc").value = dv.desc || "";
  // Ajusta bot√£o principal para modo salvar e mostra bot√£o cancelar
  const btnAdd = $("dvBtnAdd");
  if(btnAdd){
    btnAdd.textContent = "Salvar";
    btnAdd.onclick = updateDevedor;
  }
  const btnCancel = $("dvBtnCancel");
  if(btnCancel){
    btnCancel.style.display = "inline-block";
  }
  toast("Modo edi√ß√£o de devedor ativado.", "ok");
  $("dv_nome")?.focus();
}

// Salva as altera√ß√µes de um devedor em edi√ß√£o.  Mant√©m o ID e status de
// pagamento.  Valida campos obrigat√≥rios e atualiza o objeto. Ap√≥s salvar,
// retorna ao modo adicionar.
function updateDevedor(){
  if(editingDevedorId === null){
    // Nada para atualizar; volta ao modo adicionar
    addDevedor();
    return;
  }
  const nome = s($("dv_nome")?.value);
  const valor_c = parseMoneyToCents($("dv_valor")?.value);
  const data = s($("dv_data")?.value);
  const desc = s($("dv_desc")?.value);
  if(isEmpty(nome) || valor_c <= 0 || isEmpty(data)){
    toast("Preencha nome, valor e data.", "warn");
    return;
  }
  const dv = (db.devedores || []).find(x => Number(x.id) === Number(editingDevedorId));
  if(!dv){
    toast("Devedor n√£o encontrado.", "bad");
    return;
  }
  dv.nome = nome;
  dv.valor_c = valor_c;
  dv.data = data;
  dv.desc = desc;
  // preserva dv.pago e dv.pagoEm
  save();
  // Restaura modo adicionar
  editingDevedorId = null;
  const btnAdd = $("dvBtnAdd");
  if(btnAdd){
    btnAdd.textContent = "Adicionar Devedor";
    btnAdd.onclick = addDevedor;
  }
  const btnCancel = $("dvBtnCancel");
  if(btnCancel){
    btnCancel.style.display = "none";
  }
  // Limpa campos
  if($("dv_nome")) $("dv_nome").value="";
  if($("dv_valor")) $("dv_valor").value="";
  if($("dv_data")) $("dv_data").value="";
  if($("dv_desc")) $("dv_desc").value="";
  renderDevedores(true);
  render(true);
  toast("Devedor atualizado.", "ok");
}

// Cancela o modo edi√ß√£o para devedores e volta ao modo de inser√ß√£o.  N√£o
// altera dados nem salva, apenas restaura a interface.  Se nenhum devedor
// estiver em edi√ß√£o, a fun√ß√£o simplesmente limpa o formul√°rio.
function cancelEditDevedor(){
  editingDevedorId = null;
  // Restaura bot√£o principal
  const btnAdd = $("dvBtnAdd");
  if(btnAdd){
    btnAdd.textContent = "Adicionar Devedor";
    btnAdd.onclick = addDevedor;
  }
  const btnCancel = $("dvBtnCancel");
  if(btnCancel){
    btnCancel.style.display = "none";
  }
  // Limpa campos
  if($("dv_nome")) $("dv_nome").value="";
  if($("dv_valor")) $("dv_valor").value="";
  if($("dv_data")) $("dv_data").value="";
  if($("dv_desc")) $("dv_desc").value="";
  toast("Edi√ß√£o cancelada.", "warn");
}

// Atualiza o card do dashboard referente aos devedores em aberto.  Calcula o
// total em centavos, a quantidade de devedores n√£o pagos, ordena os maiores
// valores e monta a tabela de top 5 com barras proporcionais.  Se n√£o
// houver devedores em aberto, esconde o card completamente.
function renderDevedorDashboard(){
  const card = $("dash_devedores");
  const spanTotal = $("d_dev_total");
  const spanCount = $("d_dev_count");
  const gTop = $("g_dev_top");
  if(!card || !spanTotal || !spanCount || !gTop) return;
  const list = (db.devedores || []).filter(dv => !dv.pago);
  const count = list.length;
  if(count === 0){
    card.style.display = "none";
    return;
  }
  // Exibe card e preenche m√©tricas
  card.style.display = "";
  const total_c = list.reduce((sum,dv) => sum + clampInt(dv.valor_c,0), 0);
  spanTotal.textContent = centsToBR(total_c);
  spanCount.textContent = String(count);
  // Ordena por valor desc e pega top 5
  const top = [...list].sort((a,b)=>b.valor_c - a.valor_c).slice(0,5);
  const maxVal = top.length ? top[0].valor_c : 0;
  gTop.innerHTML = top.map((dv,i) => (
    `<tr>
      <td>${i+1}</td>
      <td class="rowleft">${escapeHTML(dv.nome)}</td>
      <td>R$ ${centsToBR(dv.valor_c)}</td>
      <td><div class="barwrap"><div class="bar" style="width:${maxVal>0?pct(dv.valor_c,maxVal).toFixed(1):0}%"></div></div></td>
    </tr>`
  )).join("");
  if(top.length === 0){
    gTop.innerHTML = `<tr><td colspan="4" class="small">Nenhum devedor em aberto.</td></tr>`;
  }
}
function checkDevedorAlerts(){
  const nowMs = Date.now();
  (db.devedores || []).forEach(dv => {
    if(dv.pago) return;
    const dt = new Date(dv.data);
    const dvMs = dt.getTime();
    if(!Number.isFinite(dvMs)) return;
    const diff = dvMs - nowMs;
    // ID √∫nico (usar dv.id se houver)
    const idKey = dv.id || `${dv.data}-${dv.nome}`;
    // Janela de alerta: at√© 24h antes ou 24h ap√≥s o vencimento
    if((diff <= 0 && diff > -86400000) || (diff > 0 && diff <= 86400000)){
      if(!devedorAlertNotified.has(idKey)){
        const msg = diff <= 0
          ? `Pagamento vencido: ${dv.nome}`
          : `Prazo pr√≥ximo para ${dv.nome}`;
        toast(msg, diff <= 0 ? "bad" : "warn");
        devedorAlertNotified.add(idKey);
      }
    }else{
      if(devedorAlertNotified.has(idKey)) devedorAlertNotified.delete(idKey);
    }
  });
}

/* ========== Ferramentas Extras: calculadora, conversor, senha e notas ========== */
function calculateExpression(){
  const expr = s($("calc_expr")?.value);
  if(isEmpty(expr)){
    toast("Digite uma express√£o matem√°tica.", "warn");
    return;
  }
  try {
    // Permitir apenas n√∫meros, operadores aritm√©ticos b√°sicos, par√™nteses,
    // v√≠rgula e ponto. Se houver qualquer outro caractere, abortar. Isso
    // previne inje√ß√£o de c√≥digo via Function().
    if (/[^0-9+\-*/().,%\s]/.test(expr)) {
      throw new Error('Caracteres inv√°lidos');
    }
    // Avalia a express√£o matem√°tica em modo estrito. A v√≠rgula √©
    // substitu√≠da por ponto para permitir casas decimais.
    const safeExpr = expr.replace(/,/g, '.');
    const result = Function('"use strict"; return (' + safeExpr + ')')();
    $("calc_result").textContent = String(result);
  } catch (e) {
    $("calc_result").textContent = "Erro";
    toast("Express√£o inv√°lida.", "bad");
  }
}
function generatePassword(){
  const length = Math.max(4, parseInt($("pw_length")?.value) || 12);
  const useLower = $("pw_lower")?.checked;
  const useUpper = $("pw_upper")?.checked;
  const useNumbers = $("pw_num")?.checked;
  const useSymbols = $("pw_sym")?.checked;
  let chars = "";
  if(useLower) chars += "abcdefghijklmnopqrstuvwxyz";
  if(useUpper) chars += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if(useNumbers) chars += "0123456789";
  if(useSymbols) chars += "!@#$%^&*()-_=+[]{};:,<.>/?";
  if(chars === ""){
    toast("Selecione pelo menos um conjunto de caracteres.", "warn");
    return;
  }
  let pwd = "";
  for (let i = 0; i < length; i++) {
    // Utilize crypto.getRandomValues se dispon√≠vel para melhor aleatoriedade; caso
    // contr√°rio, fallback para Math.random(). O √≠ndice √© obtido via m√≥dulo
    // do valor aleat√≥rio pelo tamanho do conjunto de caracteres.
    let randIndex;
    if (window.crypto && window.crypto.getRandomValues) {
      const arr = new Uint32Array(1);
      window.crypto.getRandomValues(arr);
      randIndex = arr[0] % chars.length;
    } else {
      randIndex = Math.floor(Math.random() * chars.length);
    }
    pwd += chars.charAt(randIndex);
  }
  $("pw_result").value = pwd;
}
function convertUnit(){
  const value = Number($("conv_value")?.value);
  const type = $("conv_type")?.value;
  if(!Number.isFinite(value)){
    toast("Digite um valor v√°lido.", "warn");
    return;
  }
  let result = "";
  switch(type){
    case "c2f":
      result = (value * 9/5 + 32).toFixed(2) + " ¬∞F";
      break;
    case "f2c":
      result = ((value - 32) * 5/9).toFixed(2) + " ¬∞C";
      break;
    case "km2mi":
      result = (value * 0.621371).toFixed(3) + " mi";
      break;
    case "mi2km":
      result = (value / 0.621371).toFixed(3) + " km";
      break;
    default:
      result = "";
  }
  $("conv_result").textContent = result;
  // Mostra um toast para depurar e verificar se a fun√ß√£o est√° sendo chamada
  toast("Convers√£o realizada: " + result, "ok");
}

/* ========== Lista de Tarefas e outras utilidades ==========
   As fun√ß√µes abaixo implementam uma lista de tarefas simples (to‚Äëdo), um
   gerador de n√∫meros aleat√≥rios e uma calculadora de IMC. Elas armazenam
   dados no banco (db.todos) para persist√™ncia e reaproveitam estilos
   existentes. */
function renderTodos(withFlash=false){
  const list = $("todo_list");
  if(!list) return;
  let html = "";
  (db.todos || []).forEach(todo=>{
    const checked = todo.done ? "checked" : "";
    const style = todo.done ? "text-decoration: line-through; color: var(--muted);" : "";
    html += `<div class="flex" style="margin:4px 0; align-items:center;">
      <label style="flex:1; ${style}">
        <input type="checkbox" onchange="toggleTodo(${todo.id})" ${checked} />
        ${escapeHTML(todo.text)}
      </label>
      <button class="danger" onclick="deleteTodo(${todo.id})">Apagar</button>
    </div>`;
  });
  if(!html) html = '<div class="small">Nenhuma tarefa.</div>';
  list.innerHTML = html;
}
function addTodo(){
  const text = s($("todo_text")?.value);
  if(isEmpty(text)){
    toast("Digite uma tarefa.", "warn");
    return;
  }
  const id = makeId();
  db.todos.push({id, text, done:false});
  save();
  renderTodos(true);
  if($("todo_text")) $("todo_text").value="";
  toast("Tarefa adicionada!", "ok");
}
function toggleTodo(id){
  const t = (db.todos || []).find(x => Number(x.id) === Number(id));
  if(!t) return;
  t.done = !t.done;
  save();
  renderTodos();
}
function deleteTodo(id){
  db.todos = (db.todos || []).filter(x => Number(x.id) !== Number(id));
  save();
  renderTodos(true);
  toast("Tarefa removida.", "warn");
}
function generateRandom(){
  const min = parseFloat($("rand_min")?.value);
  const max = parseFloat($("rand_max")?.value);
  if(!Number.isFinite(min) || !Number.isFinite(max) || min > max){
    toast("Valores inv√°lidos.", "warn");
    return;
  }
  const rand = Math.floor(Math.random() * (max - min + 1)) + min;
  $("rand_result").textContent = String(rand);
}
function calculateBMI(){
  const peso = parseFloat($("bmi_peso")?.value);
  const altura = parseFloat($("bmi_altura")?.value);
  if(!Number.isFinite(peso) || peso <= 0 || !Number.isFinite(altura) || altura <= 0){
    toast("Informe peso e altura v√°lidos.", "warn");
    return;
  }
  const imc = peso / (altura * altura);
  $("bmi_result").textContent = imc.toFixed(1);
  let classific;
  if(imc < 18.5) classific = "Abaixo do peso";
  else if(imc < 25) classific = "Peso normal";
  else if(imc < 30) classific = "Sobrepeso";
  else if(imc < 35) classific = "Obesidade I";
  else if(imc < 40) classific = "Obesidade II";
  else classific = "Obesidade III";
  $("bmi_class").textContent = `(${classific})`;
}
function renderNotes(withFlash=false){
  const list = $("notes_list");
  if(!list) return;
  let html = "";
  (db.notes || []).forEach(note=>{
    html += `<div class="card" style="margin:4px 0; padding:8px 12px;">
      <div class="flex" style="justify-content:space-between; align-items:center;">
        <div>${escapeHTML(note.text)}</div>
        <button class="danger" onclick="deleteNote(${note.id})">Apagar</button>
      </div>
    </div>`;
  });
  if(!html) html = '<div class="small">Nenhuma anota√ß√£o salva.</div>';
  list.innerHTML = html;
}
function addNote(){
  const text = s($("note_text")?.value);
  if(isEmpty(text)){
    toast("Digite uma anota√ß√£o.", "warn");
    return;
  }
  const id = makeId();
  db.notes.push({id, text});
  save();
  renderNotes(true);
  $("note_text").value="";
  toast("Nota adicionada!", "ok");
}
function deleteNote(id){
  db.notes = (db.notes || []).filter(n => Number(n.id) !== Number(id));
  save();
  renderNotes(true);
  toast("Nota removida.", "warn");
}

/* ========== SCAN / PDV FUNCTIONS ========== */
// Estado do m√≥dulo scanner
let scanOn = false;
let scanCart = [];
// Vari√°veis adicionais para suporte a BarcodeDetector e html5‚Äëqrcode
let scanStream = null;
let scanVideo = null;
let barcodeDetector = null;
let scanAnimationId = null;
let html5Qr = null;
// Buffer para leitores f√≠sicos (estilo teclado)
let scanBuffer = "";
let scanBufferTimeoutId = null;
// Controle de duplica√ß√£o de c√≥digos para evitar leituras repetidas
let lastDetectedCode = "";
let lastDetectedTime = 0;

// Atualiza o texto do bot√£o conforme estado do scanner
function updateScanButton(){
  const btn = $("scanToggleBtn");
  if(btn){
    btn.textContent = scanOn ? "üì∑ Scan Off" : "üì∑ Scan On";
  }
  // Tamb√©m sincronizar o bot√£o de scan na venda r√°pida (v_scan_btn) para refletir o estado atual
  const vBtn = $("v_scan_btn");
  if(vBtn){
    vBtn.textContent = scanOn ? "üì∑ Scan Off" : "üì∑ Scan On";
  }
}

// Inicia escuta global de teclas para leitores f√≠sicos
function initPhysicalScannerListeners(){
  document.addEventListener("keypress", physicalScannerHandler);
}
// Remove a escuta global
function removePhysicalScannerListeners(){
  document.removeEventListener("keypress", physicalScannerHandler);
}
// Captura as teclas vindas de leitores tipo teclado (keyboard wedge)
function physicalScannerHandler(e){
  // Ignora se o scanner n√£o estiver ativo
  if(!scanOn) return;
  // N√£o interfere em inputs ou textareas normais
  const active = document.activeElement;
  if(active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) return;
  const char = e.key;
  if(/^[0-9A-Za-z]$/.test(char)){
    scanBuffer += char;
    if(scanBufferTimeoutId) clearTimeout(scanBufferTimeoutId);
    scanBufferTimeoutId = setTimeout(() => {
      if(scanBuffer.length > 0){
        handleScanCode(scanBuffer.trim());
        const lastEl = $("lastScanCode");
        if(lastEl) lastEl.textContent = scanBuffer;
      }
      scanBuffer = "";
    }, 100);
  } else if(char === '\n' || char === '\r'){
    if(scanBuffer.length > 0){
      handleScanCode(scanBuffer.trim());
      const lastEl = $("lastScanCode");
      if(lastEl) lastEl.textContent = scanBuffer;
    }
    scanBuffer = "";
    if(scanBufferTimeoutId) clearTimeout(scanBufferTimeoutId);
  }
}

// Inicia o leitor de c√≥digos de barras (QuaggaJS) se n√£o estiver ativo
function startScanner(){
  if(scanOn) return;
  scanOn = true;
  updateScanButton();
  const statusEl = $("scan_status");
  if(statusEl) statusEl.textContent = "Iniciando...";
  // Pega o elemento de v√≠deo
  scanVideo = $("scan_video");
  // Inicia listener de leitores f√≠sicos
  initPhysicalScannerListeners();
  // Usa BarcodeDetector se dispon√≠vel
  if('BarcodeDetector' in window){
    try{
      const formats = ['ean_13','ean_8','upc_a','upc_e','code_128','code_39','code_93','qr_code'];
      barcodeDetector = new BarcodeDetector({formats});
      navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: "environment" } } })
        .then(stream => {
          scanStream = stream;
          if(scanVideo){ scanVideo.srcObject = stream; scanVideo.play(); }
          if(statusEl) statusEl.textContent = "Scan ativo";
          scanFrame();
        })
        .catch(err => {
          console.error(err);
          if(statusEl) statusEl.textContent = "C√¢mera indispon√≠vel. Use leitor f√≠sico ou entrada manual.";
          toast("N√£o foi poss√≠vel acessar a c√¢mera. Voc√™ ainda pode usar leitores f√≠sicos ou entrada manual.", "warn");
          scanOn = true;
          updateScanButton();
        });
    }catch(err){
      console.error(err);
      if(statusEl) statusEl.textContent = "Leitor de c√≥digo n√£o suportado. Use leitor f√≠sico ou entrada manual.";
      scanOn = true;
      updateScanButton();
    }
  } else if(typeof Html5Qrcode !== 'undefined'){
    // fallback html5-qrcode
    if(html5Qr){
      html5Qr.stop().catch(()=>{}).finally(()=>{ html5Qr.clear(); });
      html5Qr = null;
    }
    try{
      html5Qr = new Html5Qrcode("scan_view");
      const formats = [
        Html5QrcodeSupportedFormats.EAN_13,
        Html5QrcodeSupportedFormats.EAN_8,
        Html5QrcodeSupportedFormats.UPC_A,
        Html5QrcodeSupportedFormats.UPC_E,
        Html5QrcodeSupportedFormats.CODE_128,
        Html5QrcodeSupportedFormats.CODE_39,
        Html5QrcodeSupportedFormats.CODE_93,
        Html5QrcodeSupportedFormats.QR_CODE
      ];
      const config = { fps: 12, qrbox: 250, formatsToSupport: formats };
      html5Qr.start({ facingMode: { exact: "environment" } }, config, function(decodedText){
        if(decodedText){
          const lastEl = $("lastScanCode");
          if(lastEl) lastEl.textContent = decodedText;
          handleScanCode(String(decodedText).trim());
        }
      }).then(() => {
        if(statusEl) statusEl.textContent = "Scan ativo";
      }).catch(err => {
        console.error(err);
        if(statusEl) statusEl.textContent = "C√¢mera indispon√≠vel. Use leitor f√≠sico ou entrada manual.";
        toast("N√£o foi poss√≠vel iniciar a c√¢mera para o scan. Voc√™ ainda pode usar leitores f√≠sicos ou entrada manual.", "warn");
        scanOn = true;
        updateScanButton();
      });
    }catch(err){
      console.error(err);
      if(statusEl) statusEl.textContent = "Falha ao iniciar o scanner. Use leitor f√≠sico ou entrada manual.";
      scanOn = true;
      updateScanButton();
    }
  } else {
    if(statusEl) statusEl.textContent = "Leitor de c√¢mera n√£o suportado. Use leitor f√≠sico ou entrada manual.";
    scanOn = true;
    updateScanButton();
  }
}

// Para o leitor de c√≥digos de barras
function stopScanner(){
  if(!scanOn) return;
  scanOn = false;
  updateScanButton();
  // Remove escuta de leitores f√≠sicos
  removePhysicalScannerListeners();
  // Cancela o loop de detec√ß√£o
  if(scanAnimationId){ cancelAnimationFrame(scanAnimationId); scanAnimationId = null; }
  // Encerra stream de v√≠deo
  if(scanStream){ scanStream.getTracks().forEach(t => t.stop()); scanStream = null; }
  // Limpa o elemento de v√≠deo
  if(scanVideo){ scanVideo.srcObject = null; }
  // Encerra html5-qrcode
  if(html5Qr){ html5Qr.stop().catch(()=>{}).finally(()=>{ html5Qr.clear(); html5Qr = null; }); }
  const statusEl = $("scan_status");
  if(statusEl) statusEl.textContent = "Scan inativo";
}

// Alterna o estado do scanner
function toggleScan(){
  // Alterna o status do scanner. Quando j√° estiver ativo, apenas interrompe
  // a leitura; caso contr√°rio, utiliza openScanOverlay() para exibir a
  // janela flutuante e iniciar a c√¢mera. Isso garante que a sobreposi√ß√£o
  // capture eventos e fique vis√≠vel antes de iniciar o scanner.
  if(scanOn){
    stopScanner();
  } else {
    // openScanOverlay controla visibilidade e pointerEvents
    if(typeof openScanOverlay === 'function') openScanOverlay();
  }
}

// Fecha o m√≥dulo scanner: encerra o scan e volta √† √∫ltima se√ß√£o
function closeScanner(){
  stopScanner();
  // Voltar para a √∫ltima se√ß√£o registrada ou dashboard
  show(lastSection || 'dashboard');
}

// Callback quando um c√≥digo √© detectado pelo Quagga
// Fun√ß√£o onScanDetected removida: QuaggaJS n√£o √© mais utilizado

// Procura o produto no estoque e adiciona ao carrinho
function handleScanCode(code){
  // Localiza o produto pelo c√≥digo digitado ou lido. Caso n√£o exista, mostra aviso.
  const prod = (db.estoque || []).find(x => s(x.cod) === code);
  const infoEl = $("scan_product_info");
  if(!prod){
    // Se o produto n√£o existir, avisa e limpa info
    if(infoEl){
      infoEl.style.display = 'block';
      infoEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--bad') || '#ff6b6b';
      infoEl.textContent = 'Produto n√£o encontrado: ' + code;
    }
    toast("Produto n√£o encontrado: " + code, "bad");
    return;
  }
  // Produto existe: exibe informa√ß√µes do produto
  if(infoEl){
    infoEl.style.display = 'block';
    infoEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--ok') || '#4cff9a';
    infoEl.textContent = `${prod.nome} (C√≥digo: ${prod.cod}) ‚Äî Pre√ßo: R$ ${centsToBR(prod.preco_c)} ‚Äî Estoque: ${clampInt(prod.qtd, 0)}`;
  }
  // Verifica o estoque dispon√≠vel para evitar adicionar mais do que existe
  const stock = clampInt(prod.qtd, 0);
  let it = scanCart.find(x => x.cod === prod.cod);
  if(it){
    // Se j√° existe no carrinho, incrementa a quantidade se houver saldo
    if(stock <= it.qtd){
      toast("Estoque insuficiente para " + prod.nome, "bad");
      return;
    }
    it.qtd++;
    it.total_c = addCents(it.total_c, prod.preco_c);
  } else {
    // Caso contr√°rio, adiciona novo item se houver estoque
    if(stock <= 0){
      toast("Estoque insuficiente para " + prod.nome, "bad");
      return;
    }
    it = { cod: prod.cod, nome: prod.nome, qtd: 1, preco_c: prod.preco_c, custo_c: prod.custo_c, total_c: prod.preco_c };
    scanCart.push(it);
  }
  // Atualiza a interface do carrinho
  renderScanCart();
  // Exibe um toast amig√°vel indicando que o item foi adicionado ou incrementado
  toast(prod.nome + " adicionado" + (it.qtd > 1 ? " (x" + it.qtd + ")" : ""), "ok");
}

// Adiciona manualmente um c√≥digo de barras ao carrinho. √ötil para testes
// ou quando o leitor de c√≥digo de barras n√£o est√° dispon√≠vel. L√™ o valor
// do campo #manual_scan_code, chama handleScanCode() e limpa o campo.
function manualAddScan(){
  const inp = $("manual_scan_code");
  if(!inp) return;
  const code = String(inp.value || "").trim();
  if(!code) return;
  handleScanCode(code);
  inp.value = "";
}

// Permite pressionar Enter no campo de c√≥digo manual para adicionar imediatamente
document.addEventListener('DOMContentLoaded', function(){
  const manualInput = $("manual_scan_code");
  if(manualInput){
    manualInput.addEventListener('keypress', function(e){
      if(e.key === 'Enter'){
        e.preventDefault();
        manualAddScan();
      }
    });
  }
});

// Configura eventos de atualiza√ß√£o autom√°tica do pre√ßo e da porcentagem de lucro nos campos de estoque.
document.addEventListener('DOMContentLoaded', function(){
  const inpCusto = $("e_custo");
  const inpLucro = $("e_lucro");
  const inpPreco = $("e_preco");
  if(inpCusto && inpLucro && inpPreco){
    inpCusto.addEventListener('input', calcPrecoFromLucro);
    inpLucro.addEventListener('input', calcPrecoFromLucro);
    // Quando o usu√°rio editar manualmente o pre√ßo, atualiza a porcentagem de lucro
    inpPreco.addEventListener('input', calcLucroFromPreco);
  }
});

// === Controle do modal de scanner ===
// Exibe o scanner como uma janela flutuante sobre a interface principal.
function openScanOverlay(){
  const overlay = document.getElementById('scannerOverlay');
  if(!overlay) return;
  // Memorizar a se√ß√£o atual para que possamos retornar ao fech√°-lo
  try{
    lastSection = currentSection || lastSection || 'dashboard';
  }catch(e){}
  // Elevar z-index explicitamente para evitar ser coberto por outros elementos
  overlay.style.zIndex = '99999';
  // Mostra o overlay e habilita o recebimento de eventos
  overlay.style.setProperty('display','flex','important');
  overlay.style.pointerEvents = 'auto';
  // Remove estado minimizado, caso esteja ativo
  overlay.classList.remove('minimized');
  // Iniciar automaticamente o leitor se ainda n√£o estiver ativo. Caso a
  // c√¢mera n√£o possa ser iniciada, a fun√ß√£o startScanner() exibir√° uma
  // mensagem ao usu√°rio e permitir√° que a entrada manual continue.
  if(typeof startScanner === 'function' && !scanOn){
    startScanner();
  }
  // Foco na entrada manual para permitir leitores USB (atuam como teclado)
  // imediatamente ap√≥s abrir o PDV/Scanner.
  try{
    const inp = document.getElementById('manual_scan_code');
    if(inp) setTimeout(()=>{ try{ inp.focus(); }catch(e){} }, 50);
  }catch(e){}
  // Atualiza o texto dos bot√µes de scan
  if(typeof updateScanButton === 'function') updateScanButton();
}

// Suporte dedicado a leitores USB (atuam como teclado). Quando o modal de
// scanner estiver aberto, capturamos sequ√™ncias r√°pidas de teclas e, ao
// pressionar Enter, tratamos como um c√≥digo de barras.
(function(){
  let buf = "";
  let t = 0;
  const isChar = (k)=> typeof k === 'string' && k.length === 1;
  document.addEventListener('keydown', function(e){
    const overlay = document.getElementById('scannerOverlay');
    if(!overlay || overlay.style.display === 'none') return;
    // N√£o interferir se o usu√°rio estiver digitando manualmente em um input/textarea
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if(tag === 'input' || tag === 'textarea') return;
    const now = Date.now();
    if(now - t > 80) buf = ""; // timeout curto t√≠pico de scanner
    t = now;
    if(e.key === 'Enter'){
      const code = buf.trim();
      buf = "";
      if(code && code.length >= 4){
        e.preventDefault();
        try{ handleScanCode(String(code)); }catch(err){ console.warn('USB scan erro:', err); }
      }
      return;
    }
    if(isChar(e.key)){
      buf += e.key;
    }
  }, true);
})();

// Oculta o modal de scanner e interrompe a leitura de c√≥digos de barras
function closeScanOverlay(){
  // Parar o scanner, se estiver ativo
  if(typeof stopScanner === 'function') stopScanner();
  const overlay = document.getElementById('scannerOverlay');
  if(overlay){
    // Oculta e desativa eventos para n√£o interceptar cliques
    overlay.style.setProperty('display','none','important');
    overlay.style.pointerEvents = 'none';
  }
}

// Alterna a minimiza√ß√£o da janela do scanner. Quando minimizada, a janela
// √© reposicionada no rodap√© e reduzida em tamanho; ao expandir, retorna ao centro.
function toggleMinimizeScan(){
  const overlay = document.getElementById('scannerOverlay');
  if(!overlay) return;
  overlay.classList.toggle('minimized');
}

// Loop de detec√ß√£o de c√≥digos usando BarcodeDetector. Evita leituras duplicadas em intervalo curto.
function scanFrame(){
  if(!scanOn || !barcodeDetector || !scanVideo) return;
  barcodeDetector.detect(scanVideo).then(barcodes => {
    if(Array.isArray(barcodes) && barcodes.length > 0){
      const code = barcodes[0].rawValue;
      const now = Date.now();
      if(code && !(code === lastDetectedCode && now - lastDetectedTime < 800)){
        lastDetectedCode = code;
        lastDetectedTime = now;
        const lastEl = $("lastScanCode");
        if(lastEl) lastEl.textContent = code;
        handleScanCode(String(code).trim());
      }
    }
    scanAnimationId = requestAnimationFrame(scanFrame);
  }).catch(err => {
    scanAnimationId = requestAnimationFrame(scanFrame);
  });
}

// Renderiza a tabela do carrinho e atualiza os totais
function renderScanCart(){
  const tbody = $("scanCartTable");
  if(!tbody) return;
  let html = "";
  scanCart.forEach((it, idx) => {
    html += `<tr>`+
      `<td>${escapeHTML(it.cod)}</td>`+
      `<td class="rowleft">${escapeHTML(it.nome)}</td>`+
      `<td>R$ ${centsToBR(it.preco_c)}</td>`+
      `<td>${it.qtd}</td>`+
      `<td>R$ ${centsToBR(it.total_c)}</td>`+
      `<td><button class="danger" onclick="removeScanItem(${idx})">Remover</button></td>`+
    `</tr>`;
  });
  if(!html) html = `<tr><td colspan="6" class="small">Nenhum item.</td></tr>`;
  tbody.innerHTML = html;
  calcScanTotals();
}

// Remove item do carrinho pelo √≠ndice
function removeScanItem(i){
  if(i>=0 && i < scanCart.length){ scanCart.splice(i,1); renderScanCart(); }
}

// Converte campo textual em centavos (permite v√≠rgula ou ponto)
function parseScanValue(val){
  val = String(val || "").replace(/[^0-9,\.]/g, "");
  val = val.replace(',', '.');
  const n = parseFloat(val);
  return Number.isFinite(n) ? Math.round(n * 100) : 0;
}

// Calcula totais e atualiza os campos de resumo
function calcScanTotals(){
  let items = 0, subtotal_c = 0;
  scanCart.forEach(it => { items += it.qtd; subtotal_c = addCents(subtotal_c, it.total_c); });
  const servico_c = parseScanValue($("scan_service")?.value);
  const desconto_c = parseScanValue($("scan_discount")?.value);
  let total_c = addCents(subtotal_c, servico_c);
  total_c = Math.max(0, total_c - desconto_c);
  if($("scan_items")) $("scan_items").textContent = String(items);
  if($("scan_subtotal")) $("scan_subtotal").textContent = centsToBR(subtotal_c);
  if($("scan_total")) $("scan_total").textContent = centsToBR(total_c);
  const rec_c = parseScanValue($("scan_recebido")?.value);
  let troco_c = 0;
  if(rec_c > 0){ troco_c = rec_c - total_c; if(troco_c < 0) troco_c = 0; }
  if($("scan_troco")) $("scan_troco").textContent = centsToBR(troco_c);
}

// Recalcular sempre que um campo relevante for alterado
document.addEventListener("input", function(e){
  const id = e.target?.id || "";
  if(id === "scan_service" || id === "scan_discount" || id === "scan_recebido"){ calcScanTotals(); }
});

// Limpa o carrinho e os campos de entrada do scanner
function limparScanCarrinho(){
  scanCart = [];
  if($("scan_service")) $("scan_service").value = "";
  if($("scan_discount")) $("scan_discount").value = "";
  if($("scan_recebido")) $("scan_recebido").value = "";
  renderScanCart();
}

// Finaliza a venda do scanner, grava no banco e registra no caixa
function finalizarScanVenda(){
  if(!db.caixaAberto){ toast("Abra o caixa primeiro.", "warn"); return; }
  if(scanCart.length === 0){ toast("Carrinho vazio.", "warn"); return; }
  let subtotal_c = 0;
  scanCart.forEach(it => { subtotal_c = addCents(subtotal_c, it.total_c); });
  const servico_c = parseScanValue($("scan_service")?.value);
  const desconto_c = parseScanValue($("scan_discount")?.value);
  let total_c = addCents(subtotal_c, servico_c);
  total_c = Math.max(0, total_c - desconto_c);
  const rec_c = parseScanValue($("scan_recebido")?.value);
  let troco_c = 0;
  if(rec_c < total_c){
    toast("Recebido insuficiente para fechar a venda.", "bad");
    return;
  } else {
    troco_c = rec_c - total_c;
  }
  // verificar estoque
  for(const it of scanCart){
    const p = (db.estoque || []).find(x => s(x.cod) === s(it.cod));
    if(!p || clampInt(p.qtd,0) < it.qtd){ toast("Estoque insuficiente: " + it.nome, "bad"); return; }
  }
  const pag = "dinheiro";
  const agora = nowDateTime();
  const groupId = "SCAN-" + Date.now();
  scanCart.forEach((it, idx) => {
    const p = (db.estoque || []).find(x => s(x.cod) === s(it.cod));
    // Atualiza estoque: subtrai a quantidade vendida via scanner do estoque.
    // Mantemos a matem√°tica de invent√°rio correta subtraindo apenas a
    // quantidade vendida, evitando zerar o estoque. clampInt previne
    // valores negativos.
    p.qtd = clampInt(p.qtd, 0) - it.qtd;
    const lucroItem_c = mulCents((it.preco_c - it.custo_c), it.qtd);
    const serv_c = (idx === 0) ? servico_c : 0;
    const desc_c = (idx === 0) ? desconto_c : 0;
    const totalLinha_c = addCents(it.total_c, serv_c) - desc_c;
    const lucroLinha_c = addCents(lucroItem_c, serv_c) - desc_c;
    db.vendas.push({
      id: makeId(),
      data: agora,
      cod: it.cod,
      nome: it.nome,
      qtd: it.qtd,
      servico_c: addCents(serv_c, -desc_c),
      total_c: totalLinha_c,
      pag,
      lucro_c: lucroLinha_c,
      cancelada: false,
      groupId
    });
  });
  // Registrar entrada (total)
  db.caixa.push({ data: agora, desc: "Venda (Scanner)", valor_c: total_c, tipo: "entrada", pag, groupId });
  // Registrar sa√≠da de troco se houver
  if(troco_c > 0){ db.caixa.push({ data: agora, desc: "Troco venda (Scanner)", valor_c: troco_c, tipo:"saida", pag, groupId }); }
  save(); render(true);
  limparScanCarrinho();
  toast("Venda conclu√≠da!", "ok");
  // Toca som de venda conclu√≠da
  try{ if(typeof saleSound === 'function') saleSound(); }catch(_e){}
  // Fecha o modal de scanner ao finalizar a venda
  if(typeof closeScanOverlay === 'function') closeScanOverlay();
}

// Verifica o estoque do √∫ltimo c√≥digo lido ou do c√≥digo digitado manualmente
function checkScanStock(){
  // Obt√©m o c√≥digo a partir do √∫ltimo c√≥digo detectado ou da entrada manual
  let code = String(lastDetectedCode || '').trim();
  const manual = $("manual_scan_code");
  if(manual && manual.value){
    code = String(manual.value).trim();
  }
  if(!code){
    toast('Nenhum c√≥digo lido ou digitado.', 'warn');
    return;
  }
  const prod = (db.estoque || []).find(x => s(x.cod) === code);
  if(prod){
    // Exibe informa√ß√µes detalhadas via toast e na interface
    const msg = `${prod.nome} ‚Äî C√≥digo: ${prod.cod} ‚Äî Pre√ßo: R$ ${centsToBR(prod.preco_c)} ‚Äî Estoque: ${clampInt(prod.qtd,0)}`;
    toast(msg, 'ok');
    const infoEl = $("scan_product_info");
    if(infoEl){
      infoEl.style.display = 'block';
      infoEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--ok') || '#4cff9a';
      infoEl.textContent = msg;
    }
  } else {
    // Se n√£o existir, pergunta se deseja cadastrar o produto
    const confirmMsg = 'Produto n√£o encontrado. Deseja cadastr√°-lo no estoque?';
    if(confirm(confirmMsg)){
      // Fecha o modal de scanner e navega para o m√≥dulo de estoque
      closeScanOverlay();
      if(typeof show === 'function') show('estoque');
      // Pr√©-preenche o c√≥digo no formul√°rio de produto
      const codeField = $("e_cod");
      if(codeField) codeField.value = code;
      if(codeField) codeField.focus();
    } else {
      toast('Produto n√£o encontrado.', 'bad');
      const infoEl = $("scan_product_info");
      if(infoEl){
        infoEl.style.display = 'block';
        infoEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--bad') || '#ff6b6b';
        infoEl.textContent = 'Produto n√£o encontrado: ' + code;
      }
    }
  }
}

// Ajusta campos conforme o perfil comercial (mostra desconto para supermercados)
function scanRenderProfile(){
  const disc = $("scan_discount");
  if(disc){
    const parent = disc.parentElement;
    if(parent){ parent.style.display = (commerceProfile === 'super') ? '' : 'none'; }
  }
}

// Captura a tecla ESC para sair do scanner
document.addEventListener('keydown', function(ev){
  if(ev.key === 'Escape'){
    const overlay = document.getElementById('scannerOverlay');
    if(overlay && overlay.style.display !== 'none'){
      closeScanOverlay();
      ev.preventDefault();
    }
  }
});

/* Init (ordem segura) */
// ======= Assistente Virtual =======
// Hist√≥rico de mensagens do chat
let assistantHistory = [];

// Renderiza o conte√∫do do chat com base no hist√≥rico
function assistantRenderChat(){
  const chat = $("assistant_chat");
  if(!chat) return;
  chat.innerHTML = "";
  assistantHistory.forEach(({role, text}) => {
    const div = document.createElement('div');
    div.className = 'message ' + (role === 'user' ? 'user' : 'assistant');
    // Prefixa a mensagem com o remetente. Usu√°rio usa "Voc√™:", a IA usa
    // "Assistente:" para indicar o assistente virtual.
    div.textContent = (role === 'user' ? 'Voc√™: ' : 'Assistente: ') + text;
    chat.appendChild(div);
  });
  chat.scrollTop = chat.scrollHeight;
}

// Gera resposta do assistente para a entrada do usu√°rio
function assistantGenerateResponse(raw){
  // Normaliza o texto: remove acentos e converte para min√∫sculas
  const textRaw = String(raw || '');
  const text = textRaw.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
  // Sauda√ß√µes e perguntas de bem‚Äëestar
  if(/\b(ola|oi|bom dia|boa tarde|boa noite)\b/.test(text) || /como vai/.test(text) || /tudo bem/.test(text) || /como voce esta/.test(text)){
    return 'Ol√°! Estou aqui para ajudar. Como posso auxiliar?';
  }
  // Pergunta sobre o criador/origem
  if(/quem.*(criador|criou|desenvolveu|fez)/.test(text) || /de onde voce veio/.test(text)){
    return 'Fui criado por Lucas Rodrigues de Souza, desenvolvedor deste ERP, para ajudar comerciantes com suas tarefas di√°rias.';
  }
  // Quem √© Lucas
  if(/quem.*lucas/.test(text) || /quem e lucas/.test(text)){
    return 'Lucas Rodrigues de Souza √© o desenvolvedor e criador deste sistema e do assistente. Ele projetou o ERP para facilitar a vida do comerciante.';
  }
  // Nome do assistente
  if(/(como.*(voce )?se chama|qual.*seu.*nome)/.test(text)){
    return 'Sou o assistente virtual do sistema, sempre √† disposi√ß√£o para ajudar.';
  }
  // Relat√≥rio
  if(/relat[√≥o]rio/.test(text)){
    return 'Para gerar um relat√≥rio, abra o m√≥dulo desejado (como vendas ou estoque), filtre o per√≠odo e clique em ‚ÄúGerar PDF‚Äù. Posso gui√°-lo no passo a passo, se precisar.';
  }
  // Or√ßamento
  if(/orcamento|or√ßamento/.test(text)){
    return 'Para criar um or√ßamento, abra o m√≥dulo de vendas, adicione os itens desejados e clique em ‚ÄúGerar Or√ßamento‚Äù para obter o PDF.';
  }
  // Informa√ß√µes sobre estoque (quando n√£o √© pedido para abrir)
  if(/estoque/.test(text) && !/abrir/.test(text)){
    return 'No m√≥dulo de estoque voc√™ pode cadastrar, editar e consultar produtos. Para acessar, clique em ‚ÄúEstoque‚Äù no menu principal.';
  }
  // Informa√ß√µes sobre vendas (quando n√£o √© pedido para abrir)
  if(/(venda|vendas)/.test(text) && !/abrir/.test(text)){
    return 'No m√≥dulo de vendas voc√™ registra vendas r√°pidas ou com carrinho, aplica descontos e gera or√ßamentos.';
  }
  // Informa√ß√µes sobre caixa (quando n√£o √© pedido para abrir)
  if(/caixa/.test(text) && !/abrir/.test(text)){
    return 'O m√≥dulo de caixa permite abrir e fechar o caixa e registrar transa√ß√µes de entrada e sa√≠da. Para acessar, clique em ‚ÄúCaixa‚Äù no menu principal.';
  }
  // Capitais
  if(/capital.*brasil/.test(text)){
    return 'A capital do Brasil √© Bras√≠lia.';
  }
  if(/capital.*franca/.test(text)){
    return 'A capital da Fran√ßa √© Paris.';
  }
  if(/capital.*espanha/.test(text)){
    return 'A capital da Espanha √© Madri.';
  }
  if(/capital.*italia/.test(text)){
    return 'A capital da It√°lia √© Roma.';
  }
  // Pergunta sobre fun√ß√£o ou identidade do assistente
  if(/qual.*sua.*funcao/.test(text) || /quem.*voce/.test(text)){
    return 'Sou um assistente virtual integrado ao ERP. Posso orientar o uso do sistema, responder perguntas simples, realizar c√°lculos e fornecer informa√ß√µes gerais.';
  }
  // C√°lculos matem√°ticos simples
  if(/(calcular|quanto e|resultado)/.test(text) || (/\d/.test(text) && /[+\-*\/]/.test(text)) || /(vezes|dividido|por|mais|menos|multiplicado)/.test(text)){
    try{
      // Substitui palavras por operadores
      let expr = text.replace(/dividido(?: por)?/g, '/').replace(/multiplicado(?: por)?/g, '*').replace(/vezes/g, '*').replace(/mais/g, '+').replace(/menos/g, '-').replace(/por/g, '*');
      const m = expr.match(/([0-9\s+\-*/,.]+)/);
      if(m){
        const sanitized = m[1].replace(/,/g, '.');
        const res = Function('return (' + sanitized + ')')();
        if(!isNaN(res)){
          const formatted = Number(res.toFixed(10)).toString().replace('.', ',');
          return 'O resultado √© ' + formatted + '.';
        }
      }
    }catch(e){}
  }
  // Data e hora
  if(/(data|dia).*(hoje)?/.test(text) || /hoje.*(dia|data)/.test(text) || /que dia/.test(text) || /qual dia/.test(text) || /(horario|hora).*(atual)?/.test(text) || /que horas/.test(text)){
    const now = new Date();
    return 'Hoje √© ' + now.toLocaleDateString('pt-BR') + ' e o hor√°rio √© ' + now.toLocaleTimeString('pt-BR') + '.';
  }
  // Ajuda ou pedido de assist√™ncia
  if(/preciso.*ajuda/.test(text) || /ajude.*(me)?/.test(text) || /ajuda/.test(text)){
    return 'Claro! Posso orientar tarefas no ERP, como cadastrar produtos, gerar relat√≥rios ou abrir m√≥dulos. Diga-me o que precisa e explicarei como proceder.';
  }
  // Perguntas sobre execu√ß√£o de tarefas gen√©ricas
  if(/(executar|fazer).*(tarefa|operacao)/.test(text) || /como faz/.test(text) || /explica.*como/.test(text)){
    return 'Diga qual tarefa voc√™ deseja realizar no ERP e eu explicarei o passo a passo.';
  }
  // Cadastro de produto
  if(/cadastr[ao]r?.*produto/.test(text) || /adicionar.*produto/.test(text)){
    return 'Para cadastrar um produto, abra o m√≥dulo de estoque, clique em ‚ÄúAdicionar Produto‚Äù e informe c√≥digo, nome, quantidade, pre√ßo de custo e venda. Depois, salve o cadastro.';
  }
  // Abrir m√≥dulos espec√≠ficos
  if(/abrir.*modulo.*estoque/.test(text) || /abrir.*estoque/.test(text)){
    return 'Para abrir o m√≥dulo de estoque, acesse o menu principal e clique em ‚ÄúEstoque‚Äù. L√° voc√™ poder√° cadastrar, editar ou consultar produtos.';
  }
  if(/abrir.*modulo.*venda/.test(text) || /abrir.*vendas/.test(text)){
    return 'Para abrir o m√≥dulo de vendas, clique em ‚ÄúVendas‚Äù no menu principal. Voc√™ poder√° realizar venda r√°pida, com carrinho e gerar or√ßamentos.';
  }
  if(/abrir.*modulo.*caixa/.test(text) || /abrir.*caixa/.test(text)){
    return 'Para abrir o m√≥dulo de caixa, clique em ‚ÄúCaixa‚Äù no menu principal. L√° voc√™ pode abrir e fechar o caixa e registrar movimentos.';
  }
  // Agradecimentos
  if(/obrigado|obrigada|valeu/.test(text)){
    return 'De nada! Sempre que precisar estou √† disposi√ß√£o.';
  }
  // Caso n√£o se encaixe em nenhuma regra
  return 'Desculpe, n√£o entendi sua solicita√ß√£o. Posso ajudar com d√∫vidas sobre o ERP, c√°lculos e informa√ß√µes gerais.';
}

// Envia a mensagem do usu√°rio e adiciona a resposta da IA
function assistantSendMessage(){
  const input = $("assistant_input");
  if(!input) return;
  const msg = String(input.value || '').trim();
  if(!msg) return;
  assistantHistory.push({role:'user', text: msg});
  input.value = '';
  const resp = assistantGenerateResponse(msg);
  assistantHistory.push({role:'assistant', text: resp});
  assistantRenderChat();
}

// Inicializa o chat ao carregar e adiciona suporte a Enter para envio
document.addEventListener('DOMContentLoaded', function(){
  assistantRenderChat();
  const inp = $("assistant_input");
  if(inp){
    inp.addEventListener('keypress', function(e){
      if(e.key === 'Enter'){
        e.preventDefault();
        assistantSendMessage();
      }
    });
  }
});
applyThemeFromStorage();
// Carregar despesas salvas antes de renderizar a interface
if(typeof loadDespesas === 'function') loadDespesas();
// Aplicar a interface simples ou padr√£o conforme configura√ß√£o salva
if(typeof applyInterfaceFromStorage === 'function') applyInterfaceFromStorage();
// Aplicar o modo de tela (desktop, smartphone ou autom√°tico) salvo no storage
if(typeof applyUIModeFromStorage === 'function') applyUIModeFromStorage();
setEstoqueModeUI();
renderPerfilView();
    // Definimos o modo de venda padr√£o como "completa" (carrinho)
    setSalesMode("completa");
// Renderizar tabela e outras se√ß√µes
render(true);
// Aplicar perfil de com√©rcio salvo (supermercado, loja ou assist√™ncia)
applyCommerceProfile();

    // --- Carregar dados da nuvem automaticamente se a sincroniza√ß√£o estiver habilitada ---
    try {
      if (window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableCloudSync && window.Update && Update.integrations && Update.integrations.serverSync) {
        const token = window.UPDATE_FLAGS.cloudToken || (window.db && window.db._meta && window.db._meta.cloudToken);
        if (token) {
          Update.integrations.serverSync.mergeFromServer({ token, prefer: 'import', sumStockQty: true }).then((res) => {
            if (res && res.ok) {
              // Ap√≥s a mesclagem, persistimos e re-renderizamos a interface
              try { save(); } catch(_){ }
              try { render(true); } catch(_){ }
              if (typeof toast === 'function') toast('Dados sincronizados com a nuvem.', 'ok');
            }
          }).catch((_err) => {
            console.warn('Falha ao sincronizar com a nuvem:', _err);
          });
        }
      }
    } catch(_){ /* ignore */ }
// Selecionar uma ferramenta padr√£o ao abrir as ferramentas extras, para evitar tela vazia
if(typeof showTool === 'function') showTool('calc');
// agendar verifica√ß√µes peri√≥dicas para agenda e devedores
setInterval(checkAgendaAlerts, 60000);
setInterval(checkDevedorAlerts, 600000);
// (removido) atualiza√ß√£o de bot√£o de scan antigo foi substitu√≠da pelo novo m√≥dulo de scanner
</script>

  <!-- Overlay de bloqueio de licen√ßa. Exibido quando o aplicativo n√£o consegue
       verificar a licen√ßa por mais de 24 horas de uso offline. -->
  <div id="licenseBlockOverlay" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:#ffffff; color:#202124; z-index:99999; font-family:Arial, sans-serif; display:flex; justify-content:center; align-items:center;">
    <div style="max-width:960px; width:100%; padding:20px; display:flex; flex-wrap:wrap; justify-content:space-between; align-items:flex-start;">
      <div style="max-width:600px;">
        <h1 style="font-size:32px; margin-bottom:16px; font-weight:bold;">Verifica√ß√£o de licen√ßa necess√°ria</h1>
        <p style="font-size:18px; margin-bottom:20px;">N√£o foi poss√≠vel verificar sua licen√ßa nas √∫ltimas 24 horas ou n√£o tivemos acesso ao servidor do ERP.</p>
        <p style="font-size:16px; margin-bottom:8px;"><strong>Para resolver, voc√™ pode:</strong></p>
        <ul style="font-size:16px; list-style-type:disc; margin:0 0 0 20px; padding:0;">
          <li style="margin-bottom:6px;">Conectar-se √† internet e garantir que o servidor est√° acess√≠vel.</li>
          <li style="margin-bottom:6px;">Verificar se o endere√ßo do servidor est√° correto.</li>
          <li style="margin-bottom:6px;">Tentar novamente mais tarde.</li>
        </ul>
      </div>
      <div style="display:flex; flex-direction:column; align-items:flex-end; gap:12px;">
        <button onclick="retryLicenseCheck()" style="padding:10px 16px; border-radius:4px; font-size:14px; border:none; background:#1a73e8; color:#ffffff; cursor:pointer;">Verificar agora</button>
      </div>
    </div>
  </div>

    <!-- ========== Depend√™ncias do m√≥dulo Skan ========== -->
    <script src="https://unpkg.com/onscan.js@2.4.0/onscan.min.js"></script>
    <script src="https://unpkg.com/webserial-barcode-scanner/dist/webserial-barcode-scanner.umd.js"></script>
    <script src="https://unpkg.com/@ericblade/quagga2@1.2.6/dist/quagga.min.js"></script>
    <!-- ========== M√≥dulo Skan ==========
         Este script substitui o scanner antigo por um m√≥dulo unificado que suporta leitores USB (modo teclado),
         scanners em modo serial e leitura por c√¢mera (BarcodeDetector, ZXing e Quagga2). Quando o scanner √©
         ativado nas se√ß√µes de vendas ou estoque, o bot√£o correspondente muda de cor e o overlay de leitura
         √© exibido. O c√≥digo lido √© despachado para as fun√ß√µes adequadas e um evento `skan:scan` √© emitido
         para integra√ß√µes externas.  -->
    <script>
    (() => {
      // Estado do m√≥dulo
      let skanActive = false;
      let skanContext = null;
      let lastScanTime = 0;
      const minInterval = 800; // evita duplicidades
      // beep curto para feedback
      function beep() {
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const ctx = new AudioContext();
          const osc = ctx.createOscillator();
          osc.type = 'square';
          osc.frequency.value = 880;
          osc.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + 0.08);
        } catch (e) {
          // ignore se n√£o suportado
        }
      }

      // Som de venda conclu√≠da (plim/dinheiro). Executa dois beeps r√°pidos para
      // simular o som de moedas. Exporta a fun√ß√£o para uso global.
      /**
       * Som de venda conclu√≠da.
       *
       * Em vez de reutilizar o beep quadrado padr√£o, esta fun√ß√£o cria dois
       * osciladores em forma de tri√¢ngulo com frequ√™ncias diferentes e
       * envelopes curtos. O objetivo √© simular o som de moedas caindo
       * (‚Äúplim‚Äù/‚Äúdim‚Äù) sem depender de arquivos externos. Caso o
       * Web¬†Audio¬†API n√£o esteja dispon√≠vel, a fun√ß√£o falha silenciosamente.
       */
      function saleSound(){
        try{
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const ctx = new AudioContext();
          const now = ctx.currentTime;
          // Primeiro ‚Äúplim‚Äù: frequ√™ncia mais alta com decaimento r√°pido
          const osc1 = ctx.createOscillator();
          osc1.type = 'triangle';
          osc1.frequency.setValueAtTime(1200, now);
          const gain1 = ctx.createGain();
          gain1.gain.setValueAtTime(0.25, now);
          gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
          osc1.connect(gain1).connect(ctx.destination);
          osc1.start(now);
          osc1.stop(now + 0.15);
          // Segundo ‚Äúdim‚Äù: frequ√™ncia um pouco mais baixa, iniciado com atraso
          const osc2 = ctx.createOscillator();
          osc2.type = 'triangle';
          osc2.frequency.setValueAtTime(800, now + 0.18);
          const gain2 = ctx.createGain();
          gain2.gain.setValueAtTime(0.25, now + 0.18);
          gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.18 + 0.15);
          osc2.connect(gain2).connect(ctx.destination);
          osc2.start(now + 0.18);
          osc2.stop(now + 0.18 + 0.15);
        }catch(_e){ /* ignora se API de √°udio n√£o suportada */ }
      }
      // Exp√µe saleSound globalmente para que outras fun√ß√µes possam cham√°‚Äëla.
      window.saleSound = saleSound;
      // Carrega ZXing dinamicamente, apenas quando necess√°rio
      let zxingLoaded = false;
      function loadZXing() {
        return new Promise((resolve, reject) => {
          if (zxingLoaded && window.ZXingBrowser) { resolve(window.ZXingBrowser); return; }
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/@zxing/browser@latest';
          script.onload = () => {
            zxingLoaded = true;
            if (window.ZXingBrowser) resolve(window.ZXingBrowser);
            else reject(new Error('ZXingBrowser n√£o carregado'));
          };
          script.onerror = () => reject(new Error('Falha ao carregar ZXing'));
          document.head.appendChild(script);
        });
      }
      // Vari√°veis do v√≠deo/c√¢mera
      let cameraStream = null;
      let zxReader = null;
      let zxControls = null;
      let quaggaRunning = false;
      // obt√©m refer√™ncias aos elementos do overlay
      const overlay = document.getElementById('skanOverlay');
      const videoEl  = document.getElementById('skanVideo');
      const statusEl = document.getElementById('skanStatus');
      // Fun√ß√£o para iniciar a captura da c√¢mera
      async function startCamera() {
        // tenta BarcodeDetector
        if ('BarcodeDetector' in window) {
          try {
            const supported = await BarcodeDetector.getSupportedFormats();
            const detector = new BarcodeDetector({ formats: supported });
            cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } } });
            videoEl.srcObject = cameraStream;
            await videoEl.play();
            async function scan() {
              if (!skanActive) return;
              try {
                const detections = await detector.detect(videoEl);
                const now = Date.now();
                detections.forEach(det => {
                  if (now - lastScanTime > minInterval) {
                    lastScanTime = now;
                    handleSkan(det.rawValue || det.value || det.code || '');
                  }
                });
              } catch (err) {
                console.warn('BarcodeDetector erro:', err);
              }
              requestAnimationFrame(scan);
            }
            scan();
            return;
          } catch (err) {
            console.warn('Falha com BarcodeDetector:', err);
          }
        }
        // tenta ZXing
        try {
          const ZXingBrowser = await loadZXing();
          const { BrowserMultiFormatReader, BrowserCodeReader } = ZXingBrowser;
          zxReader = new BrowserMultiFormatReader();
          const devices = await BrowserCodeReader.listVideoInputDevices();
          if (!devices || devices.length === 0) throw new Error('Nenhuma c√¢mera encontrada');
          let selectedId = devices[0].deviceId;
          const env = devices.find(d => /back|rear|environment|world/i.test(d.label));
          if (env) selectedId = env.deviceId;
          zxControls = await zxReader.decodeFromVideoDevice(selectedId, videoEl, (result, err) => {
            if (result) {
              const now = Date.now();
              const code = result.getText ? result.getText() : (result.text || result.rawValue || result);
              if (now - lastScanTime > minInterval) {
                lastScanTime = now;
                handleSkan(code);
              }
            }
          });
          return;
        } catch (err) {
          console.warn('Falha com ZXing:', err);
        }
        // fallback: Quagga2 para c√≥digos 1D
        try {
          Quagga.init({
            inputStream: {
              name: 'Live',
              type: 'LiveStream',
              target: videoEl,
              constraints: { facingMode: { ideal: 'environment' } }
            },
            decoder: {
              readers: ['ean_reader','ean_8_reader','upc_reader','upc_e_reader','code_128_reader','code_39_reader','code_93_reader']
            }
          }, (err) => {
            if (err) {
              console.error('Quagga init error:', err);
              return;
            }
            Quagga.start();
            quaggaRunning = true;
            Quagga.onDetected((data) => {
              const now = Date.now();
              const code = data.codeResult && data.codeResult.code;
              if (code && (now - lastScanTime > minInterval)) {
                lastScanTime = now;
                handleSkan(code);
              }
            });
          });
        } catch (err) {
          console.warn('Falha ao iniciar Quagga:', err);
        }
      }
      // Encerra a c√¢mera e leitores
      function stopCamera() {
        if (cameraStream) {
          cameraStream.getTracks().forEach(t => t.stop());
          cameraStream = null;
        }
        if (zxControls) {
          try { zxControls.stop(); } catch(e) {}
          zxControls = null;
        }
        if (zxReader) {
          try { zxReader.reset(); } catch(e) {}
          zxReader = null;
        }
        if (quaggaRunning) {
          Quagga.stop();
          quaggaRunning = false;
        }
        if (videoEl) {
          videoEl.srcObject = null;
        }
      }
      // Inst√¢ncia para o scanner serial
      let serialScanner = null;
      async function connectSerial() {
        if (serialScanner) return;
        if (!('serial' in navigator)) return;
        try {
          serialScanner = new WebSerialBarcodeScanner();
          await serialScanner.connect();
          serialScanner.addEventListener('barcode', (e) => {
            const now = Date.now();
            const code = e && e.value;
            if (code && (now - lastScanTime > minInterval)) {
              lastScanTime = now;
              handleSkan(code);
            }
          });
        } catch (err) {
          console.warn('Erro ao conectar scanner serial:', err);
        }
      }
      // Define o manipulador principal de c√≥digos
      function handleSkan(code) {
        if (!code) return;
        beep();
        if (statusEl) statusEl.textContent = 'C√≥digo lido: ' + code;
        if (skanContext === 'vendas') {
          // Determina o modo de venda: 'rapida' ou 'completa'. Se indefinido, assume completa.
          let mode = 'completa';
          try{
            if(typeof salesMode !== 'undefined') mode = salesMode;
          }catch(_e){ mode = 'completa'; }
          if (mode === 'rapida') {
            // Venda r√°pida: preenche campo de busca, seleciona produto e define quantidade 1
            const busca = document.getElementById('v_busca');
            const sel = document.getElementById('v_prod');
            const qtdEl = document.getElementById('v_qtd');
            if (busca) busca.value = code;
            if (typeof filtrarProdutosVenda === 'function') filtrarProdutosVenda();
            if (sel) {
              // seleciona o item se existir no dropdown
              sel.value = code;
            }
            if (qtdEl) qtdEl.value = 1;
            if (typeof calcQuickTroco === 'function') calcQuickTroco();
          } else {
            // Venda completa (carrinho): preenche campo de busca e seleciona no carrinho
            const busca = document.getElementById('c_busca');
            const sel = document.getElementById('c_prod');
            const qtdEl = document.getElementById('c_qtd');
            if (busca) busca.value = code;
            if (typeof filtrarProdutosCarrinho === 'function') filtrarProdutosCarrinho();
            if (sel) {
              sel.value = code;
            }
            if (qtdEl) qtdEl.value = 1;
          }
        } else if (skanContext === 'estoque') {
          // Scanner do estoque: preenche o c√≥digo do formul√°rio de cadastro
          const codInput = document.getElementById('e_cod');
          if (codInput) codInput.value = code;
        }
        window.dispatchEvent(new CustomEvent('skan:scan', { detail: { code, context: skanContext } }));
      }
      // inicia o m√≥dulo de scanner
      function startSkan(context) {
        if (skanActive) return;
        skanActive = true;
        skanContext = context;
        updateButtons();
        if (overlay) overlay.style.display = 'flex';
        startCamera();
        connectSerial();
      }
      // encerra o m√≥dulo
      function stopSkan() {
        if (!skanActive) return;
        skanActive = false;
        skanContext = null;
        updateButtons();
        stopCamera();
        if (overlay) overlay.style.display = 'none';
        if (serialScanner) {
          try { serialScanner.disconnect(); } catch(e) {}
          serialScanner = null;
        }
      }
      // alterna estado conforme contexto
      function toggleSkan(context) {
        // Respeita prefer√™ncia do usu√°rio: se scanner desativado, n√£o inicia
        try{
          if(!(db._meta && db._meta.scannerEnabled)){
            toast('Scanner desativado nas prefer√™ncias.', 'warn');
            return;
          }
        }catch(_e){}
        if (skanActive && skanContext === context) {
          stopSkan();
        } else {
          startSkan(context);
        }
      }
      // atualiza r√≥tulos e cores dos bot√µes
      function updateButtons() {
        const vBtn = document.getElementById('skan_vendas_btn');
        const eBtn = document.getElementById('skan_estoque_btn');
        if (vBtn) {
          if (skanActive && skanContext === 'vendas') {
            vBtn.textContent = 'üîç Scanner Ativado';
            vBtn.style.background = getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#007bff';
            vBtn.style.color = '#fff';
          } else {
            vBtn.textContent = 'üîç Scanner Desativado';
            vBtn.style.background = '';
            vBtn.style.color = '';
          }
        }
        if (eBtn) {
          // Se o bot√£o de estoque estiver usando o novo scanner (toggleSkan) ou o antigo (onScannerEstoqueClick),
          // n√£o altere seu texto ou estilo aqui. Isso evita sobrescrever a label personalizada (üì∑ Scanner).
          const handler = eBtn.getAttribute('onclick') || '';
          if (handler.includes('onScannerEstoqueClick') || handler.includes('toggleSkan')) {
            // n√£o modificar a label ou estilo padr√£o
          } else {
            if (skanActive && skanContext === 'estoque') {
              eBtn.textContent = 'üîç Scanner Ativado';
              eBtn.style.background = getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#007bff';
              eBtn.style.color = '#fff';
            } else {
              eBtn.textContent = 'üîç Scanner Desativado';
              eBtn.style.background = '';
              eBtn.style.color = '';
            }
          }
        }
      }
      // Inicia onScan para leitores USB (modo teclado), se a biblioteca existir
      if (typeof onScan !== 'undefined') {
        onScan.attachTo(document, {
          suffixKeyCodes: [13, 9], // Enter ou Tab
          averageWaitTime: 40,
          minLength: 3,
          onScan: (code) => {
            handleSkan(code);
          },
          onScanError: (e) => {
            console.warn('Erro onScan:', e);
          }
        });
      }
      // Exporta fun√ß√µes para o escopo global
      window.toggleSkan = toggleSkan;
      window.stopSkan   = stopSkan;
    })();
    
    /* ========== Merge Backup File ==========
       Esta se√ß√£o adiciona suporte √† mesclagem de arquivos de backup locais. Permite carregar um
       backup e complementar o banco de dados existente sem sobrescrever dados atuais. O bot√£o
       "Mesclar Arquivo" abre um seletor de arquivos oculto (#mergeFile), e ao selecionar um JSON
       v√°lido o conte√∫do √© mesclado conforme regras espec√≠ficas de entidade. A fun√ß√£o mergeDBs
       realiza o merge de vendas, caixa, estoque, or√ßamentos e _meta de forma idempotente. */

    // Abre o seletor de arquivo de mesclagem. Verifica permiss√µes e dispara clique no input oculto.
    window.openImportBackupMerge = function(){
      try{
        if(currentUser && typeof hasPerm === 'function' && !hasPerm('exportImportBackup')){
          toast('Sem permiss√£o para importar backups.', 'bad');
          return;
        }
        const inp = document.getElementById('mergeFile');
        if(!inp){ toast('Input de arquivo n√£o encontrado (#mergeFile).', 'bad'); return; }
        inp.value = '';
        inp.click();
      }catch(e){ console.warn('openImportBackupMerge error', e); }
    };

    // Fun√ß√£o utilit√°ria que mescla dois bancos de dados conforme regras de entidade.
    window.mergeDBs = function(current, incoming){
      try{
        if(!current || typeof current !== 'object') current = {};
        if(!incoming || typeof incoming !== 'object') incoming = {};
        const out = JSON.parse(JSON.stringify(current));
        function parseDate(d){
          try{ return new Date(d).getTime() || 0; }catch(_){ return 0; }
        }
        // Mescla metadados preservando chaves existentes e atualizando savedAt se mais recente
        out._meta = out._meta && typeof out._meta === 'object' ? JSON.parse(JSON.stringify(out._meta)) : {};
        if(incoming._meta && typeof incoming._meta === 'object'){
          for(const k in incoming._meta){
            if(k === 'savedAt'){
              const curT = parseDate(out._meta.savedAt);
              const incT = parseDate(incoming._meta.savedAt);
              if(incT > curT) out._meta.savedAt = incoming._meta.savedAt;
            }else{
              if(out._meta[k] === undefined){ out._meta[k] = incoming._meta[k]; }
            }
          }
        }
        // Mesclar vendas por id ou chave composta. Atualiza se a venda importada for mais recente.
        const vendasMap = new Map();
        const curV = Array.isArray(current.vendas) ? current.vendas : [];
        const incV = Array.isArray(incoming.vendas) ? incoming.vendas : [];
        function keyVenda(v){
          if(v && v.id !== undefined && v.id !== null) return String(v.id);
          return String((v.groupId||'') + '|' + (v.data||'') + '|' + (v.cod||'') + '|' + ((v.total_c ?? v.total) || 0));
        }
        curV.forEach(v=>{ vendasMap.set(keyVenda(v), v); });
        incV.forEach(v=>{
          const k = keyVenda(v);
          if(!vendasMap.has(k)) vendasMap.set(k, v);
          else {
            const cur = vendasMap.get(k);
            const curDate = parseDate(cur.updatedAt || cur.data);
            const incDate = parseDate(v.updatedAt || v.data);
            if(incDate > curDate){ vendasMap.set(k, Object.assign({}, cur, v)); }
          }
        });
        out.vendas = Array.from(vendasMap.values());
        out.vendas.sort((a,b)=>parseDate(a.data) - parseDate(b.data));
        // Mesclar caixa por id ou por chave composta. Atualiza se importado for mais recente.
        const caixaMap = new Map();
        const curC = Array.isArray(current.caixa) ? current.caixa : [];
        const incC = Array.isArray(incoming.caixa) ? incoming.caixa : [];
        function keyCaixa(c){
          if(c && c.id !== undefined && c.id !== null) return String(c.id);
          return String((c.data||'') + '|' + (c.desc||'') + '|' + ((c.valor_c ?? c.valor) || 0) + '|' + (c.tipo||'') + '|' + (c.groupId||''));
        }
        curC.forEach(c=>{ caixaMap.set(keyCaixa(c), c); });
        incC.forEach(c=>{
          const k = keyCaixa(c);
          if(!caixaMap.has(k)) caixaMap.set(k, c);
          else {
            const cur = caixaMap.get(k);
            const curDate = parseDate(cur.updatedAt || cur.data);
            const incDate = parseDate(c.updatedAt || c.data);
            if(incDate > curDate){ caixaMap.set(k, Object.assign({}, cur, c)); }
          }
        });
        out.caixa = Array.from(caixaMap.values());
        out.caixa.sort((a,b)=>parseDate(a.data) - parseDate(b.data));
        // Mesclar estoque por c√≥digo. Atualiza quantidade e alguns campos.
        const estoqueMap = new Map();
        const curE = Array.isArray(current.estoque) ? current.estoque : [];
        const incE = Array.isArray(incoming.estoque) ? incoming.estoque : [];
        curE.forEach(p=>{
          const cod = String((p.cod ?? '').trim());
          if(!cod) return;
          estoqueMap.set(cod, Object.assign({}, p));
        });
        incE.forEach(p=>{
          const cod = String((p.cod ?? '').trim());
          if(!cod) return;
          if(!estoqueMap.has(cod)){
            estoqueMap.set(cod, Object.assign({}, p));
          }else{
            const cur = estoqueMap.get(cod);
            const merged = Object.assign({}, cur);
            const curQtd = Number(cur.qtd) || 0;
            const incQtd = Number(p.qtd) || 0;
            if(incQtd > curQtd){ merged.qtd = curQtd + (incQtd - curQtd); }
            else if(incQtd > 0 && curQtd === 0){ merged.qtd = incQtd; }
            else { merged.qtd = curQtd; }
            const curDate = parseDate(cur.updatedAt || cur.data || cur.savedAt);
            const incDate = parseDate(p.updatedAt || p.data || (incoming._meta && incoming._meta.savedAt));
            if(incDate > curDate){
              if(p.preco_c !== undefined && p.preco_c !== null && !Number.isNaN(Number(p.preco_c))) merged.preco_c = p.preco_c;
              if(p.custo_c !== undefined && p.custo_c !== null && !Number.isNaN(Number(p.custo_c))) merged.custo_c = p.custo_c;
              if(p.nome) merged.nome = p.nome;
            }
            estoqueMap.set(cod, merged);
          }
        });
        out.estoque = Array.from(estoqueMap.values());
        // Mesclar or√ßamentos por id. Atualiza se importado for mais recente.
        const orcMap = new Map();
        const curO = Array.isArray(current.orcamentos) ? current.orcamentos : [];
        const incO = Array.isArray(incoming.orcamentos) ? incoming.orcamentos : [];
        curO.forEach(o=>{
          const id = (o && o.id != null) ? String(o.id) : null;
          if(id) orcMap.set(id, o);
        });
        incO.forEach(o=>{
          const id = (o && o.id != null) ? String(o.id) : null;
          if(!id) return;
          if(!orcMap.has(id)) orcMap.set(id, o);
          else {
            const cur = orcMap.get(id);
            const curDate = parseDate(cur.updatedAt || cur.data);
            const incDate = parseDate(o.updatedAt || o.data);
            if(incDate > curDate){ orcMap.set(id, Object.assign({}, cur, o)); }
          }
        });
        out.orcamentos = Array.from(orcMap.values());
        return out;
      }catch(err){ console.error('mergeDBs error', err); return current; }
    };

    // Escuta mudan√ßas no input #mergeFile para efetuar o merge ao selecionar um arquivo
    (function(){
      try{
        const inp = document.getElementById('mergeFile');
        if(!inp) return;
        inp.addEventListener('change', async function(){
          const file = this.files && this.files[0];
          if(!file) return;
          try{
            const text = await file.text();
            let obj;
            try{ obj = JSON.parse(text); }catch(_){ obj = null; }
            if(!obj){ toast('Arquivo inv√°lido.', 'bad'); this.value=''; return; }
            let incoming = obj;
            if(obj && obj.db) incoming = obj.db;
            if(!incoming || typeof incoming !== 'object'){ toast('Backup inv√°lido.', 'bad'); this.value=''; return; }
            const merged = window.mergeDBs(db || {}, incoming);
            db = normalizeDB(merged);
            save();
            if(typeof render === 'function') render(true);
            toast('Backup mesclado com sucesso!', 'ok');
          }catch(err){ console.error(err); toast('Falha ao mesclar o backup.', 'bad'); }
          finally { this.value = ''; }
        });
      }catch(e){ console.warn('mergeFile handler error', e); }
    })();

    /* ========== Prote√ß√£o contra abas duplicadas ==========
       Esta rotina impede o uso simult√¢neo do ERP em mais de uma aba. Quando
       detecta outra aba ativa, exibe um overlay bloqueador com a mensagem
       "O sistema est√° aberto duas vezes". O controle usa localStorage para
       coordenar tabs e eventos de storage para transi√ß√µes din√¢micas. */
    (function(){
      try{
        const TAB_KEY = 'ERP_SINGLE_TAB_ID';
        const tabId = String(Date.now() + '_' + Math.random());
        let isMaster = false;
        function claimMaster(){
          try{
            const current = localStorage.getItem(TAB_KEY);
            if(!current){ localStorage.setItem(TAB_KEY, tabId); return true; }
            return current === tabId;
          }catch(_){ return true; }
        }
        function showDup(){
          let ov = document.getElementById('duplicateTabOverlay');
          if(!ov){
            ov = document.createElement('div');
            ov.id = 'duplicateTabOverlay';
            ov.style.position = 'fixed';
            ov.style.zIndex = '100000';
            ov.style.top = '0';
            ov.style.left = '0';
            ov.style.right = '0';
            ov.style.bottom = '0';
            ov.style.backgroundColor = '#fff';
            ov.style.color = '#000';
            ov.style.display = 'flex';
            ov.style.justifyContent = 'center';
            ov.style.alignItems = 'center';
            ov.style.flexDirection = 'column';
            ov.style.textAlign = 'center';
            ov.style.padding = '20px';
            ov.style.fontSize = '28px';
            ov.textContent = 'O sistema est√° aberto duas vezes';
            document.body.appendChild(ov);
          }
          ov.style.display = 'flex';
        }
        function hideDup(){
          const ov = document.getElementById('duplicateTabOverlay');
          if(ov) ov.style.display = 'none';
        }
        isMaster = claimMaster();
        if(!isMaster){ showDup(); }
        window.addEventListener('storage', function(e){
          if(e.key !== TAB_KEY) return;
          const val = e.newValue;
          if(val === null){
            if(!isMaster){
              isMaster = claimMaster();
              if(isMaster) hideDup();
            }
          }else{
            if(val !== tabId){
              if(isMaster){ isMaster = false; showDup(); }
              else { showDup(); }
            }
          }
        });
        window.addEventListener('beforeunload', function(){
          try{
            if(isMaster && localStorage.getItem(TAB_KEY) === tabId){ localStorage.removeItem(TAB_KEY); }
          }catch(_){}
        });
      }catch(e){ console.warn('Duplicate tab protection error', e); }
    })();

    /* ========== Tela offline ==========
       Exibe um overlay semelhante √† p√°gina padr√£o de "P√°gina n√£o encontrada" do navegador
       quando o dispositivo estiver sem acesso √† internet. Permite digitar
       "offlinetesteoffline" para desbloquear o uso offline, persistindo at√© que a aba
       seja fechada. Quando a conex√£o for restabelecida, remove automaticamente o overlay
       e limpa a permiss√£o tempor√°ria. */
    (function(){
      try{
        const overrideKey = 'ERP_OFFLINE_OVERRIDE';
        function createOfflineOverlay(){
          // Cria ou reutiliza o overlay que cobre toda a tela. Este painel √©
          // exibido somente quando o navegador est√° offline e nenhuma permiss√£o
          // tempor√°ria foi concedida. A estrutura e o texto seguem uma
          // inspira√ß√£o da p√°gina de erro do Google Chrome para tornar a mensagem
          // mais convincente. A l√≥gica de ativar o modo offline permanece
          // inalterada; pressionar o bot√£o "Ativar modo offline" chamar√° a mesma
          // rotina usada anteriormente (atualizando a marca√ß√£o de √∫ltima conex√£o
          // e gravando a permiss√£o no sessionStorage). O overlay n√£o intercepta
          // atalhos globais como Ctrl+L, permitindo que o console oculto seja
          // acessado normalmente.
          let ov = document.getElementById('offlineOverlay');
          if(!ov){
            ov = document.createElement('div');
            ov.id = 'offlineOverlay';
            // Ocupa toda a janela e centra o conte√∫do
            ov.style.position = 'fixed';
            ov.style.top = '0';
            ov.style.left = '0';
            ov.style.right = '0';
            ov.style.bottom = '0';
            // Definir cores com base nas vari√°veis de tema do ERP para suportar modos claro/escuro.
            // Obtemos as propriedades CSS definidas no :root (ex.: --panel2, --bg, --text, --primary, etc.).
            const rootStyle = getComputedStyle(document.documentElement);
            const bgColor   = (rootStyle.getPropertyValue('--panel2') || rootStyle.getPropertyValue('--bg') || '#ffffff').trim();
            const textColor = (rootStyle.getPropertyValue('--text') || '#5f6368').trim();
            const primaryColor = (rootStyle.getPropertyValue('--primary2') || rootStyle.getPropertyValue('--primary') || '#1a73e8').trim();
            ov.style.backgroundColor = bgColor || '#ffffff';
            // herda a cor de texto da aplica√ß√£o
            ov.style.color = textColor || '#5f6368';
            ov.style.zIndex = '99998';
            ov.style.display = 'none';
            ov.style.flexDirection = 'column';
            ov.style.justifyContent = 'center';
            ov.style.alignItems = 'center';
            ov.style.textAlign = 'center';
            ov.style.fontFamily = 'Arial, sans-serif';

            // Monta estrutura inspirada em uma p√°gina de erro do navegador, com texto e lista √† esquerda e bot√µes √† direita.
            const container = document.createElement('div');
            container.style.maxWidth = '960px';
            container.style.width = '100%';
            container.style.padding = '20px';
            container.style.display = 'flex';
            container.style.flexWrap = 'wrap';
            container.style.justifyContent = 'space-between';
            container.style.alignItems = 'flex-start';

            // Se√ß√£o de texto (esquerda)
            const textSec = document.createElement('div');
            textSec.style.maxWidth = '600px';

            const title = document.createElement('h1');
            // T√≠tulo ajustado conforme especifica√ß√£o de tela offline personalizada
            title.textContent = 'Este site n√£o foi encontrado.';
            title.style.fontSize = '32px';
            title.style.marginBottom = '16px';
            title.style.fontWeight = 'bold';

            const desc = document.createElement('p');
            // Subt√≠tulo atualizado para refletir falha de conex√£o gen√©rica
            desc.textContent = 'N√£o foi poss√≠vel conectar com o servidor.';
            desc.style.fontSize = '18px';
            desc.style.marginBottom = '20px';

            const intro = document.createElement('p');
            // Linha adicional para explicar que o servidor pode estar indispon√≠vel ou bloqueado
            intro.textContent = 'O servidor pode ter bloqueado ou estar indispon√≠vel.';
            intro.style.fontSize = '16px';
            intro.style.marginBottom = '8px';

            const list = document.createElement('ul');
            list.style.fontSize = '16px';
            list.style.listStyleType = 'disc';
            list.style.margin = '0 0 0 20px';
            list.style.padding = '0';
            const items = [
              // Sugest√µes conforme especifica√ß√£o: orientar usu√°rio a tentar mais tarde, checar rede e bloqueios de firewall/DNS.
              'Tentar novamente mais tarde',
              'Verificar a conex√£o de rede',
              'Verificar se a rede possui bloqueio (firewall/DNS)'
            ];
            items.forEach((txt) => {
              const li = document.createElement('li');
              li.textContent = txt;
              li.style.marginBottom = '6px';
              list.appendChild(li);
            });

            textSec.appendChild(title);
            textSec.appendChild(desc);
            textSec.appendChild(intro);
            textSec.appendChild(list);

            // Se√ß√£o de bot√µes (direita)
            const btnSec = document.createElement('div');
            btnSec.style.display = 'flex';
            btnSec.style.flexDirection = 'column';
            btnSec.style.alignItems = 'flex-end';
            btnSec.style.gap = '12px';

            const retryBtn = document.createElement('button');
            retryBtn.textContent = 'Tentar novamente';
            retryBtn.style.padding = '10px 16px';
            retryBtn.style.fontSize = '14px';
            retryBtn.style.border = 'none';
            retryBtn.style.borderRadius = '4px';
            // Bot√£o "Tentar novamente" usa a cor prim√°ria do tema
            retryBtn.style.backgroundColor = primaryColor || '#1a73e8';
            retryBtn.style.color = '#ffffff';
            retryBtn.style.cursor = 'pointer';
            retryBtn.onclick = function(){
              try{ location.reload(); }catch(_e){ location.href = location.href; }
            };

            const offlineBtn = document.createElement('button');
            offlineBtn.textContent = 'Ativar modo offline';
            offlineBtn.style.padding = '10px 16px';
            offlineBtn.style.fontSize = '14px';
            // Bot√£o "Ativar modo offline" usa cor prim√°ria para borda e cor de fundo igual ao painel
            offlineBtn.style.border = `1px solid ${primaryColor}`;
            offlineBtn.style.borderRadius = '4px';
            offlineBtn.style.backgroundColor = bgColor;
            offlineBtn.style.color = primaryColor;
            offlineBtn.style.cursor = 'pointer';
            offlineBtn.onclick = function(){
              try{
                sessionStorage.setItem(overrideKey, '1');
                if(typeof window.updateLastOnline === 'function'){
                  window.updateLastOnline();
                }else{
                  try{ localStorage.setItem('erp_last_online', String(Date.now())); }catch(_){}
                }
              }catch(_){}
              ov.style.display = 'none';
            };

            btnSec.appendChild(retryBtn);
            // O bot√£o de ativar modo offline foi removido da interface. O modo offline continua acess√≠vel via console oculto.

            container.appendChild(textSec);
            container.appendChild(btnSec);
            ov.appendChild(container);
            document.body.appendChild(ov);
          }
          return ov;
        }
        async function updateOfflineOverlay(){
          const ov = createOfflineOverlay();
          const override = sessionStorage.getItem(overrideKey) === '1';
          let show = false;
          try{
            // Se estiver offline (navigator.onLine === false) ou rodando via file://, marcamos para exibir a tela.
            if(!navigator.onLine || location.protocol === 'file:'){
              show = true;
            }else{
              // Verifica a disponibilidade do backend com uma requisi√ß√£o de sa√∫de e um timeout curto.
              // Se a chamada falhar ou n√£o responder com status OK, consideramos indispon√≠vel.
              const controller = new AbortController();
              const timer = setTimeout(() => controller.abort(), 1500);
              try{
                const resp = await fetch('/.netlify/functions/erp_health', {
                  method: 'GET',
                  cache: 'no-store',
                  signal: controller.signal
                });
                clearTimeout(timer);
                if(!resp.ok){
                  show = true;
                }
              }catch(_e){
                clearTimeout(timer);
                show = true;
              }
            }
          }catch(_e){
            show = true;
          }
          if(show && !override){
            ov.style.display = 'flex';
            // Se houver overlay de licen√ßa vis√≠vel, esconda-o enquanto a tela offline estiver ativa
            const lic = document.getElementById('licenseBlockOverlay');
            if(lic) lic.style.display = 'none';
          }else{
            ov.style.display = 'none';
            // Quando retornar √† conex√£o normal, removemos a permiss√£o de override
            if(navigator.onLine && override){
              sessionStorage.removeItem(overrideKey);
            }
            // Refor√ßa a verifica√ß√£o de licen√ßa para restaurar o overlay de licen√ßa se necess√°rio
            if(typeof enforceLicense === 'function'){
              try{ enforceLicense(); }catch(_){}
            }
          }
        }
        window.addEventListener('online', updateOfflineOverlay);
        window.addEventListener('offline', updateOfflineOverlay);
        setTimeout(updateOfflineOverlay, 100);
      }catch(e){ console.warn('Offline overlay error', e); }
    })();

    /* ========== Auto reload a cada 24 horas ==========
       Agenda um recarregamento autom√°tico da p√°gina ap√≥s 24 horas de uso continuo.
       O reload for√ßa a atualiza√ß√£o com cache busting (modo true), garantindo que o
       usu√°rio esteja sempre com a vers√£o mais recente da aplica√ß√£o. */
    (function(){
      try{
        const ms = 24 * 60 * 60 * 1000;
        setTimeout(function(){
          try{ location.reload(true); }catch(_){ location.reload(); }
        }, ms);
      }catch(e){ console.warn('Auto reload error', e); }
    })();

    </script>
    <!-- ====== M√≥dulo de atualiza√ß√£o e melhorias ====== -->
    <script type="module">
      // Carrega o m√≥dulo update que consolida os oito m√≥dulos legados.
      import { Update } from './update/index.js';
      // Anexa ao escopo global para manter compatibilidade com scripts n√£o-modularizados
      window.Update = Update;
      // Define sinalizadores (feature flags) para ativar melhorias de forma incremental.
      // O administrador pode ajustar estes valores via console ou persist√™ncia no localStorage.
      window.UPDATE_FLAGS = {
        // Se true, a fun√ß√£o save() utilizar√° a valida√ß√£o e salvamento seguro do m√≥dulo update.
        enableSafeSave: false,
        // Habilita os novos relat√≥rios exportados pelo m√≥dulo update (n√£o altera relat√≥rios legados).
        enableNewReports: false,
        // Exibe o bot√£o de scanner na venda completa e utiliza o m√≥dulo update.scanner (fallback para o scanner antigo).
        enableScannerButton: true,
        // Ativa valida√ß√£o e normaliza√ß√£o de dados ao inicializar o banco (sem alterar schema).
        enableNewValidation: false,
        // Ativa o sincronizador de servidor (Netlify Functions). Quando true,
        // as a√ß√µes de salvar/carregar servidor ficam vis√≠veis e operacionais.
        enableServerSync: true
        ,
        // Sincroniza√ß√£o na nuvem: quando true, o ERP salva automaticamente no servidor
        // via Cloudflare Workers usando o token do usu√°rio (definido em UPDATE_FLAGS.cloudToken).
        enableCloudSync: false,
        // Token de usu√°rio para identificar a empresa/usu√°rio na nuvem (persistido em localStorage ou definido manualmente).
        cloudToken: ''
      };

      // Garantir que a se√ß√£o de sincroniza√ß√£o com servidor fique vis√≠vel quando
      // enableServerSync estiver ativada. O script que oculta a se√ß√£o roda
      // antes de definirmos esta flag, portanto aqui reexibimos a se√ß√£o
      // explicitamente. Sem este ajuste a √°rea "‚òÅÔ∏è Sincroniza√ß√£o com Servidor"
      // pode continuar escondida mesmo com a flag enableServerSync = true.
      try {
        const syncSect = document.getElementById('serverSyncSection');
        if (syncSect && window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableServerSync) {
          syncSect.style.display = '';
        }
      } catch (e) {
        console.warn('N√£o foi poss√≠vel ajustar a visibilidade do serverSyncSection', e);
      }
      // Inicializa o update com a mesma chave de storage do sistema atual.
      Update.install({ storageKey: 'ERP_LUKAS_LOGIN_OK' });
      // Se o scanner estiver ativado, inicializa o suporte a leitores USB/c√¢mera.
      if (window.UPDATE_FLAGS.enableScannerButton) {
        try {
          Update.scanner.init({
            onCode: (code) => {
              // Quando um c√≥digo √© lido fora de um overlay de scanner,
              // tentamos adicionar diretamente ao carrinho de vendas via handleScanCode (scanner legado).
              if (typeof handleScanCode === 'function') {
                handleScanCode(code);
              }
            }
          });
        } catch (err) {
          console.warn('Falha ao inicializar scanner do update:', err);
        }
      }
      // Guarda refer√™ncia da fun√ß√£o save original para fallback.
      const _legacySave = window.save;
      // Sobrescreve save() para usar salvamento seguro quando habilitado.
      window.save = function(...args) {
        if (window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableSafeSave && window.Update && Update.db && typeof Update.db.safeSave === 'function') {
          try {
            // Utiliza o objeto global db para salvar com valida√ß√£o e backup.
            Update.db.safeSave(window.db);
            return true;
          } catch (e) {
            console.warn('Update.db.safeSave falhou:', e);
            // Fallback para save legado em caso de erro
            return _legacySave.apply(this, args);
          }
        }
        // Caso a flag esteja desativada, usamos o m√©todo legado.
        return _legacySave.apply(this, args);
      };
      // Fun√ß√£o global para o bot√£o de scanner no carrinho de vendas.
      //
      // Esta implementa√ß√£o tenta abrir a c√¢mera via Update.scanner quando
      // dispon√≠vel e em contexto seguro.  Se a tentativa falhar (por exemplo,
      // devido a navega√ß√£o insegura `file://` ou aus√™ncia de suporte ao
      // BarcodeDetector), a fun√ß√£o recorre automaticamente ao scanner
      // legado, exibindo o modal de leitura (#scannerOverlay).  O fallback
      // tamb√©m √© acionado em qualquer erro inesperado.  A estrutura foi
      // simplificada para melhorar a robustez: o overlay √© somente
      // mostrado quando necess√°rio, evitando chamadas duplicadas.
      // Bot√£o üì∑ Scanner (Venda Completa): abre SEMPRE o PDV/Scanner legado
      // (#scannerOverlay) porque ele suporta:
      //  - c√¢mera via BarcodeDetector (quando HTTPS)
      //  - leitor USB de supermercado (atua como teclado)
      //  - incremento autom√°tico de quantidade ao repetir o mesmo c√≥digo
      // Assim evitamos inconsist√™ncias entre m√∫ltiplos overlays.
      window.onScannerCartClick = function () {
        try {
          window.salesMode = 'completa';
          if (typeof openScanOverlay === 'function') {
            openScanOverlay();
          }
        } catch (e) {
          console.warn('Erro no bot√£o de scanner (completa):', e);
          try { if (typeof openScanOverlay === 'function') openScanOverlay(); } catch(_) {}
        }
      };

      /**
       * Processa um c√≥digo de barras lido pela c√¢mera. Este m√©todo √©
       * compartilhado entre os bot√µes de scanner da venda r√°pida e da
       * venda completa para garantir consist√™ncia. Ele verifica o modo
       * atual de vendas (salesMode) e aplica a l√≥gica correspondente:
       *  - No modo "completa" (carrinho), adiciona o item ao carrinho e
       *    incrementa a quantidade se j√° existir.
       *  - No modo "rapida", seleciona o produto na venda r√°pida e
       *    incrementa a quantidade quando o mesmo c√≥digo √© lido
       *    consecutivamente.
       * Se o produto n√£o for encontrado no estoque, emite um aviso.
       *
       * @param {string} code C√≥digo de barras lido
       */
      window.processCameraScan = function(code) {
        try {
          const prod = (window.db?.estoque || []).find(x => String(x.cod) === String(code));
          if (!prod) {
            if (typeof toast === 'function') toast('Produto n√£o encontrado: ' + code, 'bad');
            return;
          }
          // Determina o modo atual de venda
          const mode = (typeof window.salesMode === 'string' ? window.salesMode : 'completa');
          if (mode === 'completa') {
            // Opera√ß√£o de carrinho (modo venda completa)
            const busca = document.getElementById('c_busca');
            const sel = document.getElementById('c_prod');
            const qtdEl = document.getElementById('c_qtd');
            if (busca && sel && qtdEl) {
              // Preenche campo de busca para filtrar produtos
              busca.value = String(code);
              if (typeof filtrarProdutosCarrinho === 'function') filtrarProdutosCarrinho();
              // Seleciona produto no dropdown
              sel.value = String(code);
              // Define quantidade como 1 para incrementar corretamente via addToCart()
              qtdEl.value = '1';
              if (typeof addToCart === 'function') addToCart();
              // Limpa campo de busca e refiltra op√ß√µes
              busca.value = '';
              if (typeof filtrarProdutosCarrinho === 'function') filtrarProdutosCarrinho();
              if (typeof toast === 'function') toast(`Produto ${prod.nome} adicionado via scanner`, 'ok');
            } else {
              if (typeof toast === 'function') toast('Falha ao localizar campos do carrinho.', 'bad');
            }
          } else {
            // Opera√ß√£o de venda r√°pida (modo unidade)
            const busca = document.getElementById('v_busca');
            const sel = document.getElementById('v_prod');
            const qtdEl = document.getElementById('v_qtd');
            if (busca) busca.value = String(code);
            if (typeof filtrarProdutosVenda === 'function') filtrarProdutosVenda();
            if (sel) sel.value = String(code);
            if (qtdEl) {
              const current = String(sel?.value || '');
              const curVal = parseInt(qtdEl.value || '0', 10) || 0;
              if (current === String(code)) {
                qtdEl.value = String(curVal + 1);
              } else {
                qtdEl.value = '1';
              }
            }
            if (typeof calcQuickTroco === 'function') calcQuickTroco();
            if (typeof toast === 'function') toast(`Produto ${prod.nome} selecionado via scanner`, 'ok');
          }
        } catch (err) {
          console.warn('Erro em processCameraScan:', err);
        }
      };

      // Fun√ß√£o global para o bot√£o de scanner na venda r√°pida.
      // Esta implementa√ß√£o utiliza o mesmo m√≥dulo de scanner do carrinho para ler c√≥digos de barras via c√¢mera.
      // Quando um c√≥digo √© detectado, a venda r√°pida √© preenchida automaticamente e quantidades s√£o incrementadas.
      window.onScannerQuickClick = function() {
        /*
         * Substitu√≠mos a implementa√ß√£o anterior (que tentava abrir a c√¢mera atrav√©s
         * de m√≥dulos externos) por um mecanismo local de leitura de c√≥digo de
         * barras. Ao clicar no bot√£o de scanner, ser√° exibido o modal
         * personalizado definido em scanAndFill(), permitindo que o usu√°rio
         * digite ou cole o c√≥digo do produto. O c√≥digo ser√° inserido no campo
         * correspondente (v_busca ou c_busca) dependendo do modo de venda. Em
         * seguida, a lista de produtos √© filtrada automaticamente.
         */
        try {
          const mode = (typeof salesMode !== 'undefined') ? salesMode : 'rapida';
          const targetId = mode === 'rapida' ? 'v_busca' : 'c_busca';
          const onAfter = () => {
            try{
              if(mode === 'rapida'){
                if(typeof filtrarProdutosVenda === 'function') filtrarProdutosVenda();
              } else {
                if(typeof filtrarProdutosCarrinho === 'function') filtrarProdutosCarrinho();
              }
            }catch(_e){}
          };
          scanAndFill({ targetInputId: targetId, onResult: onAfter });
        } catch (e) {
          console.warn('Erro no bot√£o de scanner (venda r√°pida/completa):', e);
        }
      };
    </script>
    <!-- ====== Namespacing dos m√≥dulos ======
         Para manter o c√≥digo organizado e prevenir polui√ß√£o adicional do
         escopo global, reunimos conjuntos de fun√ß√µes em objetos l√≥gicos.
         Isso tamb√©m facilita testes e futuras extens√µes. As fun√ß√µes ainda
         permanecem dispon√≠veis globalmente para manter compatibilidade
         com atributos inline existentes. -->
    <script>
    (function(){
      try{
        const Core = {
          show,
          toast,
          save,
          load,
          dateKeyLocal,
          parseBRDateTime
        };
        const EstoqueMod = {
          addProduto,
          deleteProduto,
          render,
          setModeUI: setEstoqueModeUI,
          cancelEditProduto
        };
        const VendasMod = {
          registrar: registrarVenda,
          cancelar: cancelarVenda,
          renderCarrinho,
          finalizarCarrinho,
          removeCartItem,
          filtrarProdutos: filtrarProdutosVenda,
          calcCarrinho,
          calcQuickTroco
        };
        const OrcamentoMod = {
          abrir: abrirOrcamentoUI,
          fechar: fecharOrcamentoUI,
          render: renderOrc,
          addItem: addItemOrc,
          removerItem: removerItemOrc,
          limpar: limparOrc,
          gerarPDF: gerarOrcamentoPDF
        };
        const AgendaMod = {
          render: renderAgenda,
          add: addAgendaItem,
          delete: deleteAgendaItem,
          checkAlerts: checkAgendaAlerts
        };
        const DevedoresMod = {
          render: renderDevedores,
          add: addDevedor,
          markPago: markDevedorPago,
          delete: deleteDevedor,
          checkAlerts: checkDevedorAlerts
        };
        const PerfilMod = {
          salvar: salvarPerfil,
          render: renderPerfilView
        };
        const ScannerMod = {
          toggle: toggleSkan,
          stop: stopSkan
        };
        window.AppModules = {
          Core,
          Estoque: EstoqueMod,
          Vendas: VendasMod,
          Orcamento: OrcamentoMod,
          Agenda: AgendaMod,
          Devedores: DevedoresMod,
          Perfil: PerfilMod,
          Scanner: ScannerMod
        };
      // Ap√≥s inicializar todos os m√≥dulos, iniciamos a verifica√ß√£o de licen√ßa.
      try{
        initLicense();
      }catch(e){
        console.warn('Falha ao iniciar verifica√ß√£o de licen√ßa', e);
      }
      }catch(e){
        console.warn('Falha ao inicializar AppModules', e);
      }
    })();
    </script>

    <!-- ====== Server Sync (Netlify) ======
         Integra novas fun√ß√µes para salvar e carregar o banco no servidor Netlify.
         Estas fun√ß√µes s√£o chamadas pelos bot√µes adicionados na se√ß√£o de Backup & Dados.
         Requer que a flag window.UPDATE_FLAGS.enableServerSync seja true e um token de admin v√°lido. -->
    <script>
    (function(){
      // Esconde a se√ß√£o de sincroniza√ß√£o se a flag estiver desativada
      const serverSect = document.getElementById('serverSyncSection');
      if(serverSect && !(window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableServerSync)){
        serverSect.style.display = 'none';
      }
      // Verifica disponibilidade do m√≥dulo serverSync
      function ensureServerSync() {
        return window.UPDATE_FLAGS && window.UPDATE_FLAGS.enableServerSync && window.Update && Update.integrations && Update.integrations.serverSync;
      }
      // Salva o banco atual no servidor Netlify
      window.saveToServer = async function(){
        if(!ensureServerSync()){
          toast('ServerSync n√£o est√° ativo. Verifique as flags.', 'bad');
          return;
        }
        const token = prompt('Token admin para salvar no servidor:');
        if(!token) return;
        try{
          const res = await Update.integrations.serverSync.saveCurrentToServer({ token });
          if(res && res.ok){
            toast('Banco salvo no servidor com sucesso!', 'ok');
          }else{
            const err = res?.error || res?.status || 'erro';
            toast('Falha ao salvar no servidor: ' + err, 'bad');
          }
        }catch(err){
          console.error(err);
          toast('Erro inesperado ao salvar no servidor.', 'bad');
        }
      };
      // Carrega e substitui o banco a partir do servidor
      window.loadFromServerReplace = async function(){
        if(!ensureServerSync()){
          toast('ServerSync n√£o est√° ativo. Verifique as flags.', 'bad');
          return;
        }
        const token = prompt('Token admin para carregar do servidor (substituir):');
        if(!token) return;
        try{
          const res = await Update.integrations.serverSync.loadToLocal({ token });
          if(res && res.ok){
            db = Update.storage.db_core.get();
            if(typeof render === 'function') render(true);
            toast('Banco carregado do servidor (substitu√≠do).', 'ok');
          }else{
            const err = res?.error || res?.status || 'erro';
            toast('Falha ao carregar do servidor: ' + err, 'bad');
          }
        }catch(err){
          console.error(err);
          toast('Erro inesperado ao carregar do servidor.', 'bad');
        }
      };
      // Carrega e mescla o banco a partir do servidor
      window.loadFromServerMerge = async function(){
        if(!ensureServerSync()){
          toast('ServerSync n√£o est√° ativo. Verifique as flags.', 'bad');
          return;
        }
        const token = prompt('Token admin para mesclar com servidor:');
        if(!token) return;
        try{
          const res = await Update.integrations.serverSync.mergeFromServer({ token, sumStockQty: true });
          if(res && res.ok){
            db = Update.storage.db_core.get();
            if(typeof render === 'function') render(true);
            toast('Banco mesclado com sucesso com o servidor.', 'ok');
          }else{
            const err = res?.error || res?.status || 'erro';
            toast('Falha ao mesclar com o servidor: ' + err, 'bad');
          }
        }catch(err){
          console.error(err);
          toast('Erro inesperado ao mesclar com o servidor.', 'bad');
        }
      };
    })();
    </script>
    <!-- Ajustes backup & auto-sync scripts -->
    <script>
    // Backup export/import and auto-sync implementation for Ajustes
    (function(){
      // Attach listener to the hidden file input once when the page loads
      document.addEventListener('DOMContentLoaded', function(){
        const inp = document.getElementById('loadFile');
        if(inp && !inp.__erpBackupBound){
          inp.__erpBackupBound = true;
          inp.addEventListener('change', function(){
            const file = this.files && this.files[0];
            if(!file) return;
            const fr = new FileReader();
            fr.onload = function(){
              try{
                const obj = JSON.parse(fr.result);
                if(!obj || obj.type !== 'erp-backup'){
                  toast('Arquivo inv√°lido: tipo n√£o reconhecido.', 'bad');
                  return;
                }
                // Determine merge mode: confirm returns true for replace, false for merge
                const replace = confirm('Substituir o banco de dados atual pelo backup?\nClique em OK para substituir. Clique em Cancelar para mesclar.');
                const mode = replace ? 'replace' : 'merge';
                if(typeof window.applyImportedBackup === 'function'){
                  window.applyImportedBackup(obj, mode);
                }
              }catch(e){
                console.error('Erro ao ler backup', e);
                toast('Erro ao ler backup.', 'bad');
              }
            };
            fr.readAsText(file);
          });
        }
      });

      // Import backup handler: applies the imported DB either by replacing or merging
      window.applyImportedBackup = function(backup, mode){
        try{
          if(!backup || typeof backup !== 'object'){ toast('Backup inv√°lido.', 'bad'); return; }
          const incoming = backup.db || {};
          if(mode === 'replace'){
            db = normalizeDB(JSON.parse(JSON.stringify(incoming)));
            save();
            if(typeof render === 'function') render(true);
            toast('Backup importado com sucesso (substituiu).', 'ok');
          } else {
            // Merge logic: prefer imported values, sum estoque quantities
            let result = null;
            if(window.Update && Update.integrations && Update.integrations.serverSync && typeof Update.integrations.serverSync.mergeDBSmart === 'function'){
              result = Update.integrations.serverSync.mergeDBSmart(db, incoming, { prefer: 'import', sumStockQty: true });
            } else {
              // fallback simple merge: shallow object assign
              result = { db: Object.assign({}, db, incoming), report: {} };
            }
            if(result && result.db){
              db = normalizeDB(result.db);
              save();
              if(typeof render === 'function') render(true);
              let msg = 'Backup mesclado com sucesso!';
              if(result.report && (result.report.added || result.report.updated || result.report.conflicts)){
                const added = Object.values(result.report.added || {}).reduce((a,b)=>a+b,0);
                const updated = Object.values(result.report.updated || {}).reduce((a,b)=>a+b,0);
                const conflicts = (result.report.conflicts && result.report.conflicts.length) || 0;
                msg = `Backup mesclado: ${added} adicionado(s), ${updated} atualizado(s), ${conflicts} conflito(s).`;
              }
              toast(msg, 'ok');
            } else {
              toast('Falha ao mesclar.', 'bad');
            }
          }
          // Verificar se o usu√°rio atual ainda existe ap√≥s importa√ß√£o
          if(currentUser){
            const ok = (db.usuarios||[]).some(u => s(u.user) === s(currentUser.user) && s(u.pass) === s(currentUser.pass));
            if(!ok){
              currentUser = null;
              $("systemSection").style.display = "none";
              $("loginSection").style.display = "block";
              toast('Backup importado. Fa√ßa login novamente.', 'warn');
              render(true);
              return;
            }
          }
        }catch(err){
          console.error(err);
          toast('Erro ao aplicar backup.', 'bad');
        }
      };

      // Export backup: saves the current DB to a JSON file with metadata
      window.exportBackup = function(){
        if(currentUser && !hasPerm('exportImportBackup')){
          toast('Sem permiss√£o para exportar backups.', 'bad');
          return;
        }
        try{
          const cloneDb = JSON.parse(JSON.stringify(db));
          // Remover senha dos usu√°rios no backup por seguran√ßa
          if(Array.isArray(cloneDb.usuarios)){
            cloneDb.usuarios = cloneDb.usuarios.map(u => {
              const copy = Object.assign({}, u);
              delete copy.pass;
              return copy;
            });
          }
          const settings = {
            theme: safeLocalGet('erp_theme', 'default'),
            interfaceMode: safeLocalGet('erp_interface_mode', 'standard'),
            uiMode: safeLocalGet('erp_ui_mode', 'auto'),
          };
          const token = (cloneDb._meta && cloneDb._meta.cloudToken) || (window.UPDATE_FLAGS && UPDATE_FLAGS.cloudToken) || '';
          const userName = currentUser ? currentUser.user : '';
          const backup = {
            type: 'erp-backup',
            schemaVersion: 1,
            createdAt: new Date().toISOString(),
            tenant: { token, user: userName, blocked: false },
            settings,
            db: cloneDb,
            meta: { app: 'ERP', schemaVersion: (typeof DB_SCHEMA_VERSION !== 'undefined' ? DB_SCHEMA_VERSION : 0) }
          };
          const json = JSON.stringify(backup, null, 2);
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const dt = new Date();
          const y = dt.getFullYear();
          const m = String(dt.getMonth() + 1).padStart(2, '0');
          const d = String(dt.getDate()).padStart(2, '0');
          const filename = `erp-backup_${userName || 'no-user'}_${y}-${m}-${d}.json`;
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          toast('Backup exportado!', 'ok');
          setTimeout(() => URL.revokeObjectURL(url), 8000);
        }catch(err){
          console.error(err);
          toast('Falha ao exportar backup.', 'bad');
        }
      };

      // Open backup import: triggers file selector
      window.openImportBackup = function(){
        if(currentUser && !hasPerm('exportImportBackup')){
          toast('Sem permiss√£o para importar backups.', 'bad');
          return;
        }
        const inp = $("loadFile");
        if(!inp){ toast('Input de arquivo n√£o encontrado (#loadFile).', 'bad'); return; }
        inp.value = '';
        inp.click();
      };

      // Auto-sync variables
      let autoSyncOn = false;
      let lastRev = null;
      let autoSyncTimer = null;

      // Toggle auto sync: start or stop polling the server
      window.toggleAutoSync = function(){
        autoSyncOn = !autoSyncOn;
        const btn = document.getElementById('btnAutoSync');
        if(btn){
          btn.classList.toggle('active', autoSyncOn);
          btn.textContent = autoSyncOn ? 'üîÅ Desconectar' : 'üîÅ Conectar';
        }
        if(autoSyncOn){
          toast('Auto-sync ativado.', 'ok');
          autoSyncLoop();
        } else {
          toast('Auto-sync desativado.', 'warn');
          if(autoSyncTimer){ clearTimeout(autoSyncTimer); autoSyncTimer = null; }
          const ss = document.getElementById('syncStatus');
          if(ss){ ss.textContent = 'Status: offline'; }
        }
      };

      // Periodic polling of the sync status endpoint
      async function autoSyncLoop(){
        if(!autoSyncOn){ return; }
        const ss = document.getElementById('syncStatus');
        const token = (db && db._meta && db._meta.cloudToken) || (window.UPDATE_FLAGS && UPDATE_FLAGS.cloudToken) || '';
        if(!token){
          if(ss){ ss.textContent = 'Status: sem token'; }
          autoSyncTimer = setTimeout(autoSyncLoop, 5000);
          return;
        }
        try{
          if(ss){ ss.textContent = 'Status: verificando...'; }
          const res = await fetch('/api/sync/status?token=' + encodeURIComponent(token));
          const j = await res.json();
          if(j.blocked){
            if(ss){ ss.textContent = 'Status: bloqueado'; }
          } else if(j.ok){
            if(ss){ ss.textContent = 'Status: conectado'; }
            const rev = j.rev || 0;
            if(lastRev === null) lastRev = rev;
            if(rev > lastRev){
              // new revision available: fetch latest data
              if(ss){ ss.textContent = 'Status: sincronizando...'; }
              try{
                const r2 = await fetch('/api/data?token=' + encodeURIComponent(token));
                const d2 = await r2.json();
                if(d2.ok && d2.exists && d2.db){
                  db = normalizeDB(d2.db);
                  save();
                  if(typeof render === 'function') render(true);
                  lastRev = rev;
                  toast('Dados atualizados do servidor.', 'ok');
                }
              } catch(e2){
                console.error('autoSync fetch data', e2);
                if(ss){ ss.textContent = 'Status: erro ao sincronizar'; }
              }
            }
          } else {
            if(ss){ ss.textContent = 'Status: erro'; }
          }
        } catch(err){
          console.error('autoSync error', err);
          if(ss){ ss.textContent = 'Status: offline'; }
        }
        // schedule next check with jitter 3‚Äì8 seconds
        const delay = 3000 + Math.floor(Math.random() * 5000);
        autoSyncTimer = setTimeout(autoSyncLoop, delay);
      }
    })();
    </script>
    <!-- Multi-tenant authentication module -->
    <script src="./tenant-auth.js"></script>
    <!-- Caixa Hist√≥rico e Impress√£o -->
    <script>
    (function(){
      // Converte uma string de data "YYYY-MM-DD HH:mm" em um objeto Date
      function parseDateStr(str){
        try{
          if(!str) return null;
          const s = String(str).trim().replace(' ', 'T');
          const d = new Date(s);
          return isNaN(d.getTime()) ? null : d;
        }catch(e){
          return null;
        }
      }
      function renderCaixaTable(){
        const tbody = document.getElementById('tCaixa');
        const totEl = document.getElementById('cx_totais');
        if(!tbody || !db || !Array.isArray(db.caixa)) return;
        // Ler filtros
        let inicioInput = document.getElementById('cx_filter_inicio');
        let fimInput = document.getElementById('cx_filter_fim');
        let tipoInput = document.getElementById('cx_filter_tipo');
        let searchInput = document.getElementById('cx_search');
        const inicio = inicioInput && inicioInput.value ? new Date(inicioInput.value + 'T00:00:00') : null;
        const fim    = fimInput && fimInput.value ? new Date(fimInput.value + 'T23:59:59') : null;
        const tipoFilter = tipoInput && tipoInput.value ? String(tipoInput.value) : '';
        const searchTerm = searchInput && searchInput.value ? String(searchInput.value).toLowerCase() : '';
        let list = db.caixa.slice().filter(item=>{
          const dt = parseDateStr(item.data);
          if(inicio && dt && dt < inicio) return false;
          if(fim && dt && dt > fim) return false;
          if(tipoFilter && String(item.tipo) !== tipoFilter) return false;
          if(searchTerm){
            const desc = String(item.desc||'');
            const cat  = String(item.categoria||'');
            const resp = String(item.responsavel||'');
            if(!desc.toLowerCase().includes(searchTerm) &&
               !cat.toLowerCase().includes(searchTerm) &&
               !resp.toLowerCase().includes(searchTerm)){
              return false;
            }
          }
          return true;
        });
        list.sort((a,b)=>{
          const da = parseDateStr(a.data) || 0;
          const db2= parseDateStr(b.data) || 0;
          return da - db2;
        });
        let rows = '';
        let totalEntradas = 0;
        let totalSaidas = 0;
        let totalVendas = 0;
        list.forEach(item=>{
          const dt = parseDateStr(item.data);
          const dateStr = dt && typeof formatDateTime === 'function' ? formatDateTime(dt) : (item.data||'');
          const tipo = String(item.tipo||'');
          const categoria = String(item.categoria||'');
          const valor_c = Number(item.valor_c) || 0;
          if(valor_c >= 0) totalEntradas += valor_c; else totalSaidas += valor_c;
          if(categoria && categoria.toLowerCase() === 'venda') totalVendas += Math.abs(valor_c);
          const valorBR = typeof centsToBR === 'function' ? centsToBR(Math.abs(valor_c)) : (Math.abs(valor_c)/100).toFixed(2);
          const desc = String(item.desc||'');
          const pagamento = String(item.pag||'');
          const responsavel = String(item.responsavel||'');
          let actions = '';
          const isVenda = categoria && categoria.toLowerCase() === 'venda';
          if(!isVenda){
            actions = '<button style="margin-right:4px" onclick="editCaixa(\\'' + item.id + '\\')">‚úèÔ∏è</button>';
            actions += '<button onclick="deleteCaixa(\\'' + item.id + '\\')">‚ùå</button>';
          } else {
            actions = '‚Äî';
          }
          rows += '<tr>' +
                  '<td>' + dateStr + '</td>' +
                  '<td>' + tipo + '</td>' +
                  '<td>' + categoria + '</td>' +
                  '<td style="text-align:right;' + (valor_c<0 ? 'color:var(--red5,red);' : 'color:var(--green5,green);') + '">' + (valor_c<0 ? '- R$ ' : 'R$ ') + valorBR + '</td>' +
                  '<td>' + desc + '</td>' +
                  '<td>' + pagamento + '</td>' +
                  '<td>' + responsavel + '</td>' +
                  '<td>' + actions + '</td>' +
                  '</tr>';
        });
        tbody.innerHTML = rows;
        if(totEl){
          const saldo = totalEntradas + totalSaidas;
          let html = '';
          html += 'Entradas: R$ ' + (typeof centsToBR === 'function' ? centsToBR(totalEntradas) : (totalEntradas/100).toFixed(2));
          html += ' &nbsp;&nbsp; Sa√≠das: R$ ' + (typeof centsToBR === 'function' ? centsToBR(Math.abs(totalSaidas)) : (Math.abs(totalSaidas)/100).toFixed(2));
          html += ' &nbsp;&nbsp; Saldo: R$ ' + (typeof centsToBR === 'function' ? centsToBR(saldo) : (saldo/100).toFixed(2));
          if(totalVendas > 0){
            html += ' &nbsp;&nbsp; Vendas: R$ ' + (typeof centsToBR === 'function' ? centsToBR(totalVendas) : (totalVendas/100).toFixed(2));
          }
          totEl.innerHTML = html;
        }
      }
      window.renderCaixaTable = renderCaixaTable;
      function editCaixa(id){
        if(!db || !Array.isArray(db.caixa)) return;
        const item = db.caixa.find(e => String(e.id) === String(id));
        if(!item) return;
        if(String(item.categoria||'').toLowerCase() === 'venda'){
          toast('N√£o √© poss√≠vel editar uma entrada de venda. Use cancelar venda.', 'warn');
          return;
        }
        let tipo = prompt('Tipo (entrada/saida):', String(item.tipo||''));
        if(!tipo){ return; }
        tipo = String(tipo).toLowerCase();
        if(tipo !== 'entrada' && tipo !== 'saida'){
          toast('Tipo inv√°lido.', 'warn');
          return;
        }
        let valStr = prompt('Valor (ex: 123,45):', (Math.abs(item.valor_c)/100).toFixed(2).replace('.',','));
        if(valStr === null){ return; }
        const newVal = parseMoneyToCents(valStr);
        if(!Number.isFinite(newVal) || newVal < 0){
          toast('Valor inv√°lido.', 'warn');
          return;
        }
        const categoria = prompt('Categoria:', String(item.categoria||''));
        const pag = prompt('Forma de pagamento:', String(item.pag||''));
        const desc = prompt('Descri√ß√£o:', String(item.desc||''));
        item.tipo = tipo;
        item.valor_c = tipo === 'saida' ? -Math.abs(newVal) : Math.abs(newVal);
        item.categoria = categoria || '';
        item.pag = pag || '';
        item.desc = desc || '';
        save();
        render(true);
        toast('Lan√ßamento atualizado.', 'ok');
      }
      window.editCaixa = editCaixa;
      function deleteCaixa(id){
        if(!db || !Array.isArray(db.caixa)) return;
        const idx = db.caixa.findIndex(e => String(e.id) === String(id));
        if(idx < 0) return;
        const item = db.caixa[idx];
        if(String(item.categoria||'').toLowerCase() === 'venda'){
          toast('N√£o √© poss√≠vel excluir uma entrada de venda. Use cancelar venda.', 'warn');
          return;
        }
        if(!confirm('Excluir este lan√ßamento?')) return;
        db.caixa.splice(idx, 1);
        save();
        render(true);
        toast('Lan√ßamento exclu√≠do.', 'ok');
      }
      window.deleteCaixa = deleteCaixa;
      function imprimirFluxo(modo){
        if(!db || !Array.isArray(db.caixa)) return;
        let start, end, label;
        const filtroInicio = document.getElementById('cx_filter_inicio');
        if(modo === 'diario'){
          let dia = filtroInicio && filtroInicio.value ? filtroInicio.value : null;
          if(!dia){
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth()+1).padStart(2,'0');
            const dd = String(now.getDate()).padStart(2,'0');
            dia = `${yyyy}-${mm}-${dd}`;
          }
          start = new Date(dia + 'T00:00:00');
          end   = new Date(dia + 'T23:59:59');
          label = dia.split('-').reverse().join('/');
        } else {
          const base = filtroInicio && filtroInicio.value ? new Date(filtroInicio.value) : new Date();
          const y = base.getFullYear();
          const m = base.getMonth();
          start = new Date(y, m, 1, 0,0,0);
          end   = new Date(y, m+1, 0, 23,59,59);
          const month = String(m+1).padStart(2,'0');
          label = month + '/' + y;
        }
        const entries = db.caixa.filter(item=>{
          const dt = parseDateStr(item.data);
          return dt && dt >= start && dt <= end;
        });
        let totalEntradas = 0;
        let totalSaidas = 0;
        let totalVendas = 0;
        const porResp = {};
        const porCat  = {};
        entries.forEach(item=>{
          const val = Number(item.valor_c) || 0;
          if(val >= 0) totalEntradas += val; else totalSaidas += val;
          if(String(item.categoria||'').toLowerCase() === 'venda'){
            totalVendas += Math.abs(val);
          }
          const resp = String(item.responsavel||'Desconhecido');
          porResp[resp] = (porResp[resp] || 0) + val;
          const cat = String(item.categoria||'Sem categoria');
          porCat[cat] = (porCat[cat] || 0) + val;
        });
        const saldo = totalEntradas + totalSaidas;
        let html = '<h2 style="margin:0 0 10px 0;">Relat√≥rio de Fluxo ' + (modo === 'diario' ? 'Di√°rio' : 'Mensal') + '</h2>';
        html += '<p>Per√≠odo: ' + label + '</p>';
        html += '<p>Total Entradas: R$ ' + (typeof centsToBR === 'function' ? centsToBR(totalEntradas) : (totalEntradas/100).toFixed(2)) + '<br>';
        html += 'Total Sa√≠das: R$ ' + (typeof centsToBR === 'function' ? centsToBR(Math.abs(totalSaidas)) : (Math.abs(totalSaidas)/100).toFixed(2)) + '<br>';
        html += 'Saldo: R$ ' + (typeof centsToBR === 'function' ? centsToBR(saldo) : (saldo/100).toFixed(2)) + '<br>';
        html += 'Total Vendas: R$ ' + (typeof centsToBR === 'function' ? centsToBR(totalVendas) : (totalVendas/100).toFixed(2)) + '</p>';
        html += '<table style="border-collapse:collapse; width:100%; margin-top:10px; font-size:12px;">';
        html += '<thead><tr style="background:#f0f0f0;"><th style="border:1px solid #999;padding:4px;">Data/Hora</th><th style="border:1px solid #999;padding:4px;">Tipo</th><th style="border:1px solid #999;padding:4px;">Categoria</th><th style="border:1px solid #999;padding:4px;">Valor</th><th style="border:1px solid #999;padding:4px;">Descri√ß√£o</th><th style="border:1px solid #999;padding:4px;">Pagamento</th><th style="border:1px solid #999;padding:4px;">Respons√°vel</th></tr></thead><tbody>';
        entries.sort((a,b)=>{
          const da = parseDateStr(a.data) || 0;
          const dbb= parseDateStr(b.data) || 0;
          return da - dbb;
        }).forEach(item=>{
          const dt = parseDateStr(item.data);
          const dateStr = dt ? dt.toLocaleString('pt-BR') : (item.data||'');
          const val = Number(item.valor_c) || 0;
          const valBR = typeof centsToBR === 'function' ? centsToBR(Math.abs(val)) : (Math.abs(val)/100).toFixed(2);
          html += '<tr>';
          html += '<td style="border:1px solid #999;padding:4px;">' + dateStr + '</td>';
          html += '<td style="border:1px solid #999;padding:4px;">' + (item.tipo||'') + '</td>';
          html += '<td style="border:1px solid #999;padding:4px;">' + (item.categoria||'') + '</td>';
          html += '<td style="border:1px solid #999;padding:4px;text-align:right;">' + (val<0 ? '- R$ ' : 'R$ ') + valBR + '</td>';
          html += '<td style="border:1px solid #999;padding:4px;">' + (item.desc||'') + '</td>';
          html += '<td style="border:1px solid #999;padding:4px;">' + (item.pag||'') + '</td>';
          html += '<td style="border:1px solid #999;padding:4px;">' + (item.responsavel||'') + '</td>';
          html += '</tr>';
        });
        html += '</tbody></table>';
        html += '<h3 style="margin-top:12px;">Totais por Respons√°vel</h3>';
        html += '<table style="border-collapse:collapse; width:100%; font-size:12px;"><thead><tr style="background:#f0f0f0;"><th style="border:1px solid #999;padding:4px;">Respons√°vel</th><th style="border:1px solid #999;padding:4px;">Valor</th></tr></thead><tbody>';
        Object.keys(porResp).forEach(resp=>{
          const val = porResp[resp];
          const valBR = typeof centsToBR === 'function' ? centsToBR(Math.abs(val)) : (Math.abs(val)/100).toFixed(2);
          html += '<tr><td style="border:1px solid #999;padding:4px;">' + resp + '</td><td style="border:1px solid #999;padding:4px;text-align:right;">' + (val<0 ? '- R$ ' : 'R$ ') + valBR + '</td></tr>';
        });
        html += '</tbody></table>';
        html += '<h3 style="margin-top:12px;">Totais por Categoria</h3>';
        html += '<table style="border-collapse:collapse; width:100%; font-size:12px;"><thead><tr style="background:#f0f0f0;"><th style="border:1px solid #999;padding:4px;">Categoria</th><th style="border:1px solid #999;padding:4px;">Valor</th></tr></thead><tbody>';
        Object.keys(porCat).forEach(cat=>{
          const val = porCat[cat];
          const valBR = typeof centsToBR === 'function' ? centsToBR(Math.abs(val)) : (Math.abs(val)/100).toFixed(2);
          html += '<tr><td style="border:1px solid #999;padding:4px;">' + cat + '</td><td style="border:1px solid #999;padding:4px;text-align:right;">' + (val<0 ? '- R$ ' : 'R$ ') + valBR + '</td></tr>';
        });
        html += '</tbody></table>';
        html += '<p style="font-size:10px; margin-top:10px;">Gerado em ' + (new Date().toLocaleString('pt-BR')) + '</p>';
        const w = window.open('', '_blank');
        if(!w){
          alert('N√£o foi poss√≠vel abrir a janela de impress√£o. Verifique o bloqueador de pop-up.');
          return;
        }
        w.document.write('<html><head><title>Relat√≥rio de Fluxo</title><style>body{font-family:Arial,sans-serif;color:#000;background:#fff;margin:20px;} h2,h3{margin:0 0 10px 0;} table{width:100%; border-collapse:collapse; margin-top:4px;} th, td{border:1px solid #999;padding:4px;font-size:12px;} thead{background:#f0f0f0;} </style></head><body>' + html + '</body></html>');
        w.document.close();
        w.focus();
        w.print();
      }
      window.imprimirFluxo = imprimirFluxo;
      // ===== Fun√ß√£o para ajuste r√°pido de quantidade na venda r√°pida =====
      function changeQuickQty(delta){
        try{
          const qtyInput = document.getElementById('v_qtd');
          if(!qtyInput) return;
          let val = parseInt(qtyInput.value || '0', 10);
          if(!Number.isFinite(val)) val = 0;
          val += Number(delta);
          if(val < 1) val = 1;
          qtyInput.value = String(val);
          // Recalcular troco/total ap√≥s ajuste
          if(typeof calcQuickTroco === 'function') calcQuickTroco();
        }catch(e){ console.warn('changeQuickQty error', e); }
      }
      window.changeQuickQty = changeQuickQty;
    })();
    // ====== Scanner adaptador para aba Estoque ======
    (function(){
      /**
       * Faz a leitura de um c√≥digo usando o scanner. Caso a API BarcodeDetector esteja
       * dispon√≠vel, utiliza a c√¢mera; caso contr√°rio, exibe um prompt para digitar/colar.
       * Ap√≥s a leitura, o valor √© colocado no input alvo e opcionalmente chama um callback.
       * @param {{targetInputId:string, onResult?:function}} opts
       */
      async function scanAndFill(opts){
        const { targetInputId, onResult } = opts || {};
        const input = document.getElementById(targetInputId);
        if(!input) return;
        // Tente usar o BarcodeDetector somente se suportado e a p√°gina n√£o estiver
        // rodando via protocolo "file:". Para ambientes locais ou onde a c√¢mera
        // n√£o est√° dispon√≠vel (como neste projeto), pulamos essa etapa.
        let code = null;
        const canUseCamera = window.location.protocol !== 'file:' && window.BarcodeDetector && typeof navigator.mediaDevices?.getUserMedia === 'function';
        if(canUseCamera){
          try{
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' } });
            const video = document.createElement('video');
            video.srcObject = stream;
            await video.play();
            const track = stream.getVideoTracks()[0];
            const detector = new BarcodeDetector();
            const scanFrame = async () => {
              const bitMap = await createImageBitmap(video);
              const barcodes = await detector.detect(bitMap);
              if(barcodes && barcodes.length > 0){
                code = barcodes[0].rawValue || '';
              }
              bitMap.close();
            };
            const startTime = Date.now();
            while(!code && (Date.now() - startTime) < 5000){
              await scanFrame();
              await new Promise(r => setTimeout(r, 200));
            }
            track.stop();
          }catch(e){
            console.warn('Erro ao abrir c√¢mera para scanner:', e);
          }
        }
        // Fallback manual: exibe um modal personalizado para inser√ß√£o de c√≥digo
        if(!code){
          code = await new Promise((resolve) => {
            // Cria overlay escuro
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0,0,0,0.5)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10000';
            // Conte√∫do do modal
            const box = document.createElement('div');
            box.style.background = '#fff';
            box.style.padding = '20px';
            box.style.borderRadius = '8px';
            box.style.maxWidth = '90%';
            box.style.width = '320px';
            box.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
            box.innerHTML = `
              <h3 style="margin-top:0; font-size:1.2rem;">Digite ou cole o c√≥digo do produto</h3>
              <input id="manualCodeInput" style="width:100%; padding:10px; font-size:1rem; margin-bottom:10px;" autofocus />
              <div style="text-align:right;">
                <button id="manualCodeCancel" style="margin-right:10px; padding:6px 12px;">Cancelar</button>
                <button id="manualCodeOk" style="padding:6px 12px;">OK</button>
              </div>
            `;
            overlay.appendChild(box);
            document.body.appendChild(overlay);
            const inputField = box.querySelector('#manualCodeInput');
            const cancelBtn = box.querySelector('#manualCodeCancel');
            const okBtn = box.querySelector('#manualCodeOk');
            function cleanup(val){
              overlay.remove();
              resolve(val);
            }
            okBtn.addEventListener('click', () => {
              const val = inputField.value.trim();
              cleanup(val || null);
            });
            cancelBtn.addEventListener('click', () => {
              cleanup(null);
            });
            inputField.addEventListener('keydown', (e) => {
              if(e.key === 'Enter'){
                const val = inputField.value.trim();
                cleanup(val || null);
              } else if(e.key === 'Escape'){
                cleanup(null);
              }
            });
            // Focus input after a tick to ensure overlay is in DOM
            setTimeout(() => inputField.focus(), 50);
          });
        }
        if(code){
          input.value = code;
          if(typeof onResult === 'function'){
            try{ onResult(code); } catch(e) { console.warn(e); }
          }
        }
      }
      /**
       * Handler para o bot√£o de scanner de estoque. Verifica se o foco est√° no campo
       * de cadastro ou de busca e aciona o scanner apropriado.
       */
      function onScannerEstoqueClick(){
        // Exibe um toast simples para indicar que o bot√£o de scanner foi clicado. Isto ajuda no
        // diagn√≥stico para garantir que o evento esteja disparando corretamente.
        try { if (typeof toast === 'function') toast('Scanner do estoque acionado', 'info'); } catch(_e) {}
        // Se estiver com um modal de edi√ß√£o ativo (estoqueSearch), tentar ler para o campo de busca
        const active = document.activeElement;
        if(active && active.id === 'estoqueSearch'){
          scanAndFill({ targetInputId:'estoqueSearch', onResult:()=>{ updateEstoqueSearch(); render(true); } });
        }else{
          // Por padr√£o, preenche o campo de c√≥digo do formul√°rio
          scanAndFill({ targetInputId:'e_cod' });
        }
      }
      window.scanAndFill = scanAndFill;
      window.onScannerEstoqueClick = onScannerEstoqueClick;
    // Garante que o bot√£o de scanner de estoque sempre abra o leitor manual.
    // Em alguns contextos a propriedade onclick pode ser sobrescrita por outros
    // m√≥dulos do ERP. Para assegurar que a a√ß√£o desejada seja executada,
    // registramos explicitamente um listener ap√≥s o carregamento do DOM.
    // Como o script √© carregado ao final do corpo do documento, o DOM j√° est√°
    // pronto. Portanto, registramos diretamente o listener do scanner de
    // estoque sem aguardar o evento DOMContentLoaded. Este listener garante
    // que, ao clicar no bot√£o de scanner, seja aberto o modal de leitura de
    // c√≥digo (ao inv√©s de depender de comportamentos de outros m√≥dulos).
    try {
      const stockBtn = document.getElementById('skan_estoque_btn');
      if (stockBtn) {
        // Verifique se o bot√£o j√° est√° usando o novo m√≥dulo de scanner Skan. Se estiver,
        // n√£o registre o fallback manual (scanAndFill), pois o Skan oferece suporte
        // tanto a c√¢mera quanto a leitores USB. Caso contr√°rio, mantenha o
        // comportamento legado de abrir o modal de leitura manual.
        const existingHandler = stockBtn.getAttribute('onclick') || '';
        if (!existingHandler.includes('toggleSkan')) {
          stockBtn.addEventListener('click', function(ev) {
            ev.preventDefault();
            // Se o usu√°rio estiver pesquisando no campo de busca do estoque, use esse campo
            const active = document.activeElement;
            if (active && active.id === 'estoqueSearch') {
              scanAndFill({ targetInputId: 'estoqueSearch', onResult: () => { updateEstoqueSearch(); render(true); } });
            } else {
              scanAndFill({ targetInputId: 'e_cod' });
            }
          });
        }
      }
    } catch (e) {
      console.warn('Erro ao registrar listener do scanner de estoque:', e);
    }
    })();
    </script>

    <!-- Configura√ß√£o de navega√ß√£o com Enter no formul√°rio de cadastro de estoque.
         Quando o usu√°rio pressiona Enter em um campo, move o foco para o pr√≥ximo
         campo de cadastro. No √∫ltimo campo, foca o bot√£o de salvar. -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const order = ['e_cod','e_nome','e_qtd','e_min','e_custo','e_preco','e_lucro'];
        order.forEach((id, idx) => {
          const el = document.getElementById(id);
          if(!el) return;
          el.addEventListener('keydown', function(ev){
            if(ev.key === 'Enter'){
              ev.preventDefault();
              const nextId = order[idx+1];
              if(nextId){
                const nextEl = document.getElementById(nextId);
                if(nextEl) nextEl.focus();
              } else {
                // Se for o √∫ltimo campo, foca o bot√£o de salvar produto
                const btn = document.getElementById('btnSalvarProduto');
                if(btn) btn.focus();
              }
            }
          });
        });
      });
    </script>
    <!-- Scripts adicionais: or√ßamentos e dispositivos -->
    <script>
    /* ========== Or√ßamentos ========== */
    function renderOrcamentos(){
      try{
        // Suporte para m√∫ltiplos cont√™ineres de or√ßamentos (ajustes e ferramentas)
        const conts = ['orcamentosList','orcamentosListTool'].map(id => document.getElementById(id)).filter(c => c);
        if(conts.length === 0) return;
        const lista = Array.isArray(db.orcamentos) ? db.orcamentos : [];
        // Gera o HTML da tabela apenas uma vez para reuso em todos os cont√™ineres
        let html = '';
        if(lista.length === 0){
          html = '<div class="small">Nenhum or√ßamento salvo.</div>';
        } else {
          html = '<table style="width:100%; border-collapse:collapse; font-size:0.9em;"><thead><tr>';
          html += '<th style="border:1px solid var(--border); padding:6px;">#</th>';
          html += '<th style="border:1px solid var(--border); padding:6px;">N√∫mero</th>';
          html += '<th style="border:1px solid var(--border); padding:6px;">Cliente</th>';
          html += '<th style="border:1px solid var(--border); padding:6px;">Data</th>';
          html += '<th style="border:1px solid var(--border); padding:6px;">Total</th>';
          html += '<th style="border:1px solid var(--border); padding:6px;">Status</th>';
          html += '<th style="border:1px solid var(--border); padding:6px;">A√ß√µes</th>';
          html += '</tr></thead><tbody>';
          lista.forEach(function(orc, idx){
            const totalBR = centsToBR(Number(orc.total_c) || 0);
            html += '<tr>';
            html += '<td style="border:1px solid var(--border); padding:6px; text-align:center;">' + (idx+1) + '</td>';
            html += '<td style="border:1px solid var(--border); padding:6px;">' + escapeHTML(orc.numero || orc.id || '') + '</td>';
            html += '<td style="border:1px solid var(--border); padding:6px;">' + escapeHTML(orc.cliente || '-') + '</td>';
            html += '<td style="border:1px solid var(--border); padding:6px;">' + escapeHTML(orc.data || orc.createdAt || '') + '</td>';
            html += '<td style="border:1px solid var(--border); padding:6px; text-align:right;">R$ ' + totalBR + '</td>';
            html += '<td style="border:1px solid var(--border); padding:6px; text-transform:capitalize;">' + escapeHTML(orc.status || 'pendente') + '</td>';
            html += '<td style="border:1px solid var(--border); padding:6px; text-align:center;">';
            // Bot√£o para editar or√ßamentos, sempre dispon√≠vel
            html += '<button class="ghost" data-id="' + escapeHTML(String(orc.id)) + '" onclick="editOrcamento(this.dataset.id)">Editar</button> ';
            // Bot√£o de aprovar aparece apenas quando ainda n√£o aprovado
            if(orc.status !== 'aprovado'){
              html += '<button data-id="' + escapeHTML(String(orc.id)) + '" onclick="approveOrcamento(this.dataset.id)">Aprovar</button> ';
            }
            html += '<button class="ghost" data-id="' + escapeHTML(String(orc.id)) + '" onclick="deleteOrcamento(this.dataset.id)">Excluir</button>';
            html += '</td>';
            html += '</tr>';
          });
          html += '</tbody></table>';
        }
        conts.forEach(function(cont){ cont.innerHTML = html; });
      }catch(e){ console.warn('renderOrcamentos error', e); }
    }

    // ====================
    // Or√ßamento: edi√ß√£o
    // --------------------
    // Vari√°vel global que indica se h√° um or√ßamento sendo editado. Quando
    // definida (n√£o null), o pr√≥ximo salvamento de or√ßamento ir√° substituir
    // o or√ßamento com o mesmo id em vez de criar um novo registro. Ap√≥s
    // salvar, a vari√°vel √© redefinida para null.
    let editingOrcId = null;

    /**
     * Carrega um or√ßamento existente para edi√ß√£o. Copia todos os dados do
     * or√ßamento selecionado (itens, cliente, contato, m√£o de obra, validade,
     * observa√ß√µes) para os campos da UI de or√ßamento e exibe o cart√£o de
     * or√ßamento. Se o or√ßamento estiver aprovado, ainda permite editar os
     * campos b√°sicos, mas mant√©m o status ao salvar. Quando o id n√£o for
     * encontrado, exibe um aviso.
     *
     * @param {string|number} id Identificador do or√ßamento a ser editado
     */
    function editOrcamento(id){
      try{
        const lista = Array.isArray(db.orcamentos) ? db.orcamentos : [];
        const orcObj = lista.find(o => String(o.id) === String(id));
        if(!orcObj){ toast('Or√ßamento n√£o encontrado.', 'bad'); return; }
        // Sinaliza que estamos editando este or√ßamento
        editingOrcId = orcObj.id;
        // Copia itens (cod, nome, qtd, preco_c) para o or√ßamento em mem√≥ria
        orc.itens = (orcObj.itens || []).map(function(it){ return {
          cod: String(it.cod),
          nome: String(it.nome),
          qtd: Number(it.qtd) || 0,
          preco_c: Number(it.preco_c) || 0,
          total_c: mulCents(Number(it.preco_c)||0, Number(it.qtd)||0)
        }; });
        // Atualiza campos de cliente, contato, validade, m√£o de obra e observa√ß√µes
        if($("o_cliente")) $("o_cliente").value = String(orcObj.cliente || '');
        if($("o_contato")) $("o_contato").value = String(orcObj.contato || '');
        if($("o_validade")) $("o_validade").value = String(orcObj.validade || '');
        // Campo de m√£o de obra armazena centavos; converte para string em reais
        if($("o_servico")) $("o_servico").value = orcObj.mao_c ? centsToBR(orcObj.mao_c) : '';
        if($("o_obs")) $("o_obs").value = String(orcObj.obs || '');
        // Exibe UI de or√ßamento e renderiza itens
        const card = $("orcCard");
        if(card) card.style.display = 'block';
        renderOrc(true);
        toast('Editando or√ßamento #' + escapeHTML(String(orcObj.numero || '')), 'ok');
      }catch(e){ console.warn('editOrcamento error', e); }
    }

    function approveOrcamento(id){
      try{
        const lista = Array.isArray(db.orcamentos) ? db.orcamentos : [];
        const idx = lista.findIndex(o => String(o.id) === String(id));
        if(idx < 0){ toast('Or√ßamento n√£o encontrado.', 'bad'); return; }
        const orc = lista[idx];
        if(orc.status === 'aprovado'){ toast('Or√ßamento j√° aprovado.', 'warn'); return; }
        // Verificar estoque. Caso algum item esteja em falta, pergunta ao usu√°rio
        // se deseja prosseguir mesmo assim. Permite aprovar or√ßamentos que
        // contenham itens sem quantidade suficiente, ajustando o estoque para
        // refletir a retirada (pode ficar negativo).
        for(const it of (orc.itens || [])){
          const prod = (db.estoque || []).find(p => String(p.cod) === String(it.cod));
          if(!prod){ toast('Produto n√£o encontrado: ' + it.cod, 'bad'); return; }
          if(Number(prod.qtd) < Number(it.qtd)){
            const nome = s(prod.nome || prod.cod);
            const proceed = confirm('Estoque insuficiente para ' + nome + '. Deseja aprovar assim mesmo?');
            if(!proceed){ return; }
            // Se o usu√°rio concordou, continuamos sem retornar
          }
        }
        const groupId = 'ORC-' + Date.now();
        const agora = nowDateTime();
        // Processar itens
        (orc.itens || []).forEach(function(it, index){
          const prod = (db.estoque || []).find(p => String(p.cod) === String(it.cod));
          if(prod){ prod.qtd = clampInt(prod.qtd,0) - Number(it.qtd); }
          const totalLinha_c = Number(it.total_c) || 0;
          const servicoLinha_c = (index === 0 ? Number(orc.mao_c || 0) : 0);
          const custo = Number(prod && prod.custo_c ? prod.custo_c : 0);
          const lucroItem_c = mulCents((Number(it.preco_c) - custo), Number(it.qtd));
          const lucroLinha_c = addCents(lucroItem_c, servicoLinha_c);
          db.vendas.push({
            id: makeId(),
            data: agora,
            cod: String(it.cod),
            nome: String(it.nome),
            qtd: Number(it.qtd),
            servico_c: servicoLinha_c,
            total_c: addCents(totalLinha_c, servicoLinha_c),
            pag: 'orcamento',
            lucro_c: lucroLinha_c,
            cancelada: false,
            groupId: groupId
          });
        });
        // Registrar caixa
        db.caixa.push({
          data: agora,
          desc: 'Venda (Or√ßamento)',
          valor_c: Number(orc.total_c) || 0,
          tipo: 'entrada',
          pag: 'orcamento',
          groupId: groupId
        });
        // Atualizar status
        orc.status = 'aprovado';
        orc.approvedAt = agora;
        save(); render(true);
        // Montar recibo
        lastReceipt = {
          receiptId: 'REC-' + Date.now(),
          date: agora,
          payment: 'orcamento',
          items: (orc.itens || []).map(function(it){ return {
            cod: String(it.cod),
            nome: String(it.nome),
            qtd: Number(it.qtd),
            preco_c: Number(it.preco_c) || 0,
            total_c: Number(it.total_c) || 0
          }; }),
          subtotal_c: Number(orc.subtotal_c) || 0,
          service_c: Number(orc.mao_c) || 0,
          total_c: Number(orc.total_c) || 0,
          received_c: Number(orc.total_c) || 0,
          change_c: 0,
          groupId: groupId
        };
        if(typeof maybeEmitNotaFiscal === 'function') maybeEmitNotaFiscal(lastReceipt);
        toast('Or√ßamento aprovado com sucesso!', 'ok');
        // Toca som de conclus√£o de venda, se definido
        try{ if(typeof saleSound === 'function') saleSound(); }catch(_e){}
        renderOrcamentos();
      }catch(e){ console.warn('approveOrcamento error', e); }
    }

    function deleteOrcamento(id){
      try{
        if(!confirm('Deseja realmente excluir este or√ßamento?')) return;
        const lista = Array.isArray(db.orcamentos) ? db.orcamentos : [];
        const idx = lista.findIndex(o => String(o.id) === String(id));
        if(idx < 0){ toast('Or√ßamento n√£o encontrado.', 'bad'); return; }
        lista.splice(idx, 1);
        save();
        toast('Or√ßamento exclu√≠do.', 'ok');
        renderOrcamentos();
      }catch(e){ console.warn('deleteOrcamento error', e); }
    }

    /* ========== Configura√ß√µes de Dispositivos ========== */
    function setScanDevice(val){
      try{
        if(!db._meta) db._meta = {};
        db._meta.scanDevice = val;
        save();
        toast('Dispositivo de scanner atualizado.', 'ok');
      }catch(e){ console.warn('setScanDevice error', e); }
    }

    function setPrinterDevice(val){
      try{
        if(!db._meta) db._meta = {};
        db._meta.printerDevice = val;
        save();
        toast('Dispositivo de impressora atualizado.', 'ok');
      }catch(e){ console.warn('setPrinterDevice error', e); }
    }

    // Alterna a ordem do hist√≥rico de vendas (mais recente ‚Üî mais antigo). Atualiza
    // o r√≥tulo do bot√£o (opcional) e chama render(true) para recarregar a tabela.
    function toggleVendasOrder(){
      try{
        vendasOrderDesc = !vendasOrderDesc;
        const btn = document.getElementById('btnVendasOrder');
        if(btn){
          // Mant√©m o mesmo r√≥tulo para n√£o poluir a interface, apenas muda a dica.
          btn.title = vendasOrderDesc ? 'Mostrar da mais recente √† mais antiga' : 'Mostrar da mais antiga √† mais recente';
        }
        render(true);
      }catch(e){ console.warn('toggleVendasOrder error', e); }
    }
    </script>
</body>
</html>